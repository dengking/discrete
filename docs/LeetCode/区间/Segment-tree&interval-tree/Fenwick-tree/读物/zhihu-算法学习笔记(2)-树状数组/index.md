# zhihu [算法学习笔记(2) : 树状数组](https://zhuanlan.zhihu.com/p/93795692) 

现在我们试图寻找一种结构，一方面，单点修改时需要更新的区间不会太多；另一方面，区间查询时需要用来组合的区间也不会太多。

> NOTE:
>
> 一、本质上还是segment tree那一套

**树状数组**就是这样一种结构，它巧妙地利用了**二进制**（实际上，树状数组的英文名BIT，直译过来就是**二进制下标树**）。例如11，转化为二进制数就是 $(1011)_2$ ，如果我们要求前11项和，可以分别查询 $((0000)_2,(1000)_2]$ 、$((1000)_2,(1010)_2]$以及$((1010)_2,(1011)_2]$的和再相加。这三个区间怎么来的呢？其实就是**不断地去掉二进制数最右边的一个1**的过程（如下图）。

![img](https://pic4.zhimg.com/80/v2-a53a897f22763ef04a728f8263f06547_1440w.webp)

> NOTE:
>
> 一、上面表示的就是区间 $(A_i−lowbit(A_i),A_i]$ 

我们定义，二进制数最右边的一个1，连带着它之后的0为 `lowbit(x)` （稍后再来看如何实现）。

> NOTE:
>
> 一、`lowbit(x)` 其实就是最低有效位



那么我们用$C_i$ 维护区间 $(A_i−lowbit(A_i),A_i]$，这样显然查询前n项和时需要合并的区间数是少于 $\log_2⁡ n$ 的。树状数组的结构大概像下面这样：

![img](https://pic1.zhimg.com/80/v2-fbaeb49fdbad31a211fe37f068ca8bb0_1440w.webp)



那么如何更新呢，大家会发现更新就是一个“**爬树**”的过程。一路往上更新，直到MAXN（树状数组的容量）。

![img](https://pic3.zhimg.com/80/v2-df001651925903a86ab640482b78c2d6_1440w.webp)



我们举个例子来看看这树是怎么爬的。 现有二进制数$(100110)_2$ ，包含它的**最小区间**当然是$((100100)_2,(100110)_2]$。然后，它也肯定位于区间$((100000)_2,(101000)_2]$内。然后是$((100000)_2,(110000)_2]$，再然后是 $(0,(1000000)_2]$ ……