# [浅谈数位类统计问题](https://www.gydoc.com/p-5722.html) 

> NOTE: 
>
> 一、
>
> ppt: 
>
> https://max.book118.com/html/2019/1023/7015031056002065.shtm
>
> 可以正常访问，PPT的内容非常好，是论文的非常好的补充
>
> https://wenku.baidu.com/view/d2414ffe04a1b0717fd5dda8.html?_wkts_=1694272740500
>
> PDF，可以正常访问
>
> https://github.com/ericliu859/AcmPaper/blob/master/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%95%B0%E4%BD%8D%E9%97%AE%E9%A2%98/%E5%88%98%E8%81%AA/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E4%B9%8B%E3%80%8A%E6%B5%85%E8%B0%88%E6%95%B0%E4%BD%8D%E7%B1%BB%E7%BB%9F%E8%AE%A1%E9%97%AE%E9%A2%98%E3%80%8B.pdf
>
> PDF，可以正常访问
>
> 二、在阅读 CSDN Accagain  [【DP专辑】ACM动态规划总结](https://blog.csdn.net/cc_again/article/details/25866971?spm=1001.2014.3001.5502) 时，其中提及了这篇论文
>
> 

山东省青岛第二中学 刘聪

## 摘要

在信息学竞赛中，有一类与数位有关的区间统计问题。这类问题往往具有比较浓厚的数学味道，无法暴力求解，需要在数位上进行递推等操作。本文通过几个例子，简要介绍了解决此类问题的基本思想和方法。

## 关键字

数位、区间、统计、递推、树、二进制



## 正文

在信息学竞赛中，有这样一类问题: 求给定区间中，满足给定条件的某个D进制数或此类数的数量。所求的**限定条件**往往和**数位**有关，例如**数位**之和、指定数码**个数**、数的大小顺序分组等等。题目给定的区间往往很大，无法采用朴素的方法求解。此时，我们就需要利用**数位**的性质，设计 $log(n)$ 级别复杂度算法。解决这类问题的最基本思想就是"**逐位确定**"的方法。下面就让我们通过几道例题来具体了解一下这类问题及其思考方法。



## 【例题1】[ural 1057. Amount of Degrees](https://acm.timus.ru/problem.aspx?space=1&num=1057) 

![](./example-1-ural-1057.png)

> NOTE: 
>
> 一、这道题非常好，它结合了dp、greedy algorithm、tree
>
> 求解这个问题其实可以分为如下步骤:
>
> 1、读懂题目意思
>
> "所求的数为互不相等的幂之和，亦即其 $B$ 进制表示的各位数字都只能是 0 和 1。因此，我们只需讨论二进制的情况，其他进制都可以转化为二进制求解。"
>
> 上述分析其实少说了一句话，完整的内容是： 其 *B* 进制表示的各位数字都只能是 0 和 1，且 1 的个数位 $K$。 
>
> 结合一个具体的例子: B=10，则满足条件的数字为: 1100、1111、1001等
>
> 2、使用"**逐位确定**"法，对于上述符合题目要求的数字，它每一位有两个选择: 0、1，则显然它的[solution|state] space是 complete-2-ary-tree: 它的[solution|state] space的选择对应的是edge（left对应0，right对应1，这让我想到了trie的transition edge），需要注意的是，它的[solution|state] space complete-2-ary-tree相比于X、Y的量级是小很多的，这是由于我们仅仅关注符合要求的数字，它避免了对所有的数进行讨论，能够大幅提高算法的效率，这真是算法的威力
>
> 如何来计数？显然这个问题转换成了: 如何统计一棵高度为 $i$ 的 **完全二叉树** 内二进制表示中恰好含有 $j$ 个 $1$ 的数的个数。
>
> 显然它的递归方程: $f[i, j] = f[i - 1, j] + f[i - 1, j - 1]$ ，下面是一些例子:
>
> ```c++
> f[1, 1] = f[0, 1] + f[0, 0] = 1
> 
> f[2, 1] = f[1, 1] + f[1, 0] = 2 (01、10)
> 
> f[2, 2] = f[1, 2] + f[1, 1] = 1
> 
> f[3, 1] = f[2, 1] + f[2, 0] = 3
> ```
>
> 3、给定一个数字，如何得到答案呢？这部分内容是原文解释地不算清晰，首先需要清楚的是，需要使用greedy algorithm来思考这个问题: 
>
> step1: 找到"**不超过 $n$ 的最大 B 进制 表示只含 0、1 的数**"，这个数指的是最大的、符合题目要求的数，后面为了便于描述，将这个数称为`MaxLegal`(最大的合法的数字) ，结合后面的例子可知，它对应的是图中的红线（关于这个数的具体计算方法，后面会进行详细介绍）。在拿到这个数后，就可以计算出所有符合题目要求的数的个数了。
>
> step2: 显然符合题目要求的数可以分为两个部分:
>
> a、$n$ (**红线**对应的数即 $n$ 本身)
>
> b、小于$n$ 
>
> "小于$n$" 的部分，其实就是下述**红线**的**左侧部分**，那么如何统计**左侧部分**中符合题目要求的数的个数呢？找到 `MaxLegal` 在 [solution|state] space complete-2-ary-tree 对应的path，按照 [solution|state] space complete-2-ary-tree 的编排方式，显然小于它的数是path上各个node都left child；需要注意的是，如果path上某个节点的left node已经在path上了，显然这个node是需要pass的，所以最终概括起来就是: 需要统计的左子树都是path在"**右转**"(对应的digit 取值为1)时遇到的。

这道题满足**区间减法**，因此可以进一步简化问题: 令 $count[i..j]$ 表示 $[i..j]$ 区间内合法数的个数，则 $count[i..j] = count[0..j] - count[0..i-1] $ 。换句话说，给定 $n$，我们只需求出从 0 到 n 有多少个符合条件的数。

假设 $n=13$ ，其二进制表示为 $1101, K = 3$ 。我们的目标是求解出 $0$ 到 $13$ 中二进制表示含 $3$ 个 $1$ 的数的个数，为了方便思考，让我们画出一棵高度为 $4$ 的**完全二叉树**:



![](./complete-binary-tree.png)

为了方便起见，树的根用 $0$​​​​ 表示。这样，这棵高度为 $4$​​​​ 的**完全二叉树**就可以表示所有 $4$​​​​ 位二进制树 $(0..2^4 - 1)$​​​​，每个叶子节点代表一个数。其中，红色路径表示 $n$​​​​ 。

> NOTE:
>
> 一、"红色路径表示 $n$ "的含义是这条路径所到达的叶子结点对应的数字是$n$ 
>
> 二、上面的颜色是非常不清晰的，下面是比较清晰的描述:
>
> ![](./complete-binary-tree-tree-color.png)
>
> 上面进行了分解，更加容易理解。

所有小于 $n$​​​​ 的数形成了三棵子树，分别用**蓝色**、**绿色**、**紫色**表示。因此统计小于13的数，就只需要统计这三棵完整的二叉树:

1、统计**蓝色子树**内含3个1的数的个数

> NOTE: 
>
> **蓝色子树** 指的是上述最左边的子树，即`0***`

2、统计**绿色子树**内含2个1的数的个数(因为从根到此处的路径上已经有1个1了)

> NOTE: 
>
> 即 `10**`

3、统计**紫色子树**内含1个1的数的个数

> NOTE: 
>
> 即 `11**`

注意到，只要是高度相同的子树统计结果一定相同。而需要统计的子树都是"**右转**"时遇到的。当然，我们不能忘记统计 $n$ 本身，实际上，在算法最初时将 $n$ 自加 $1$，可以避免讨论 $n$ 本身，但是需要注意避免上溢。

> NOTE: 
>
> 一、"只要是高度相同的子树统计结果一定相同" 这句话如何理解？
>
> 二、"而需要统计的子树都是"**右转**"时遇到的" 这段话如何理解呢？前面已经进行了分析，此处不再赘述。

### 递归方程

剩下的问题是，如何统计一棵高度为 $i$​ 的**完全二叉树**内二进制表示中恰好含有 $j$​ 个 $1$​ 的数的个数。这很容易递推求出: 设 $f[i, j]$ 表示所求，则分别统计左右子树内符合条件数的个数，有 $f[i, j] = f[i - 1, j] + f[i - 1, j - 1]$ 。

> NOTE:
>
> 一、
>
> ![](./recurrence-relation-递归关系.png)
>
> 上述让我想起来"**树形DP**"
>
> 它没有定义base case，从下面的核心代码可知，它的base case: `f[0][0] = 1`
>
> 

### 核心代码

这样就可以得到询问的算法: 首先预处理 $f$ ，然后对于输入 $n$ ，我们在假想的**完全二叉树**中，从根走到 $n$ 所在的叶子，每次向右转时统计左子树内数的个数。下面是C++代码:

```C++
#include <cstdio>

const int N = 50;
int f[N][N]; //f[i][j] 前i个中选j个1的个数

/**
 * 预处理f
 */
void init() {
    f[0][0] = 1;
    for (int i = 1; i <= 31; ++i) {
        f[i][0] = f[i - 1][0];
        for (int j = 1; j <= i; ++j) {
            f[i][j] = f[i - 1][j] + f[i - 1][j - 1];
        }
    }
}

/**
 * 统计[0..x]内二进制表示含k个1的数的个数
 * @param x 
 * @param k 
 * @return 
 */
int calc(int x, int k) {
    int total = 0, ans = 0;//total记录当前路径上已有的1的数量，ans表示答案
    for (int i = 31; i > 0; --i) {
        if (x & (1 << i)) {
            ++total;
            if (total > k) break;
            x = x ^ (1 << i); // ^ 是 XOR operator，它实现的效果是将x的最高为设置为0
        }
        if ((1 << (i - 1)) <= x) {
            ans += f[i - 1][k - total];
        }
    }
    if (total + x == k) {
        ++ans;
    }
    return ans;
}

int main() {
    init();
    int x, y, k, c;
    while (~scanf("%d%d%d%d", &x, &y, &k, &c)) {
        printf("%d\n", calc(y, k) - calc(x - 1, k));
    }
    return 0;
}
```

最后的问题就是如何处理非二进制。对于询问 $n$，我们需要求出不超过 $n$ 的最大 B 进制 表示只含 0、1 的数:找到 $n$ 的左起第一位非 0、1 的数位，将它变为 1，并将右面所有数位 设为 1。将得到的 B 进制表示视为二进制进行询问即可。

> NOTE:
>
> 一、上面这段话的一些注解: 
>
> 1、"对于询问 $n$"即需要查询小于等于n的数中，符合条件的数的个数。
>
> 2、理解上面这段话需要使用**greedy algorithm**的思想
>
> "**不超过 $n$ 的最大 B 进制 表示只含 0、1 的数**"指的是最大的、符合题目要求的数，后面为了便于描述，这个数就是前面说的$MaxLegal$(最大的合法的数字) ，结合前面的例子来看，它对应的是上图中的红线。在拿到这个数后，就可以计算出所有的符合题目要求的数的个数了。
>
> 3、下面内容是PPT中的解释
>
> > 剩下的问题就是: 如何将任意进制问题转换为二进制问题？只需要贪心将 $n$ 的 $B$ 进制表示转换为只含01: 找到n的左起第一位大于1的数位，将它以及它右边的所有数位赋值为1。
>
> (这其实找到了上述红色的线，则这条红色的线的左侧都是符合题目要求的数字，其实它这里是典型的贪心思想，这种方式是非常巧妙的，它避免了对所有的数进行讨论，能够大幅提高算法的效率，这真是算法的威力)

实际上，最终的代码并不涉及树的操作，我们只是利用图形的方式来方便思考。因此也可以只从**数位**的角度考虑：对于询问 *n*，我们找到一个等于 1 的数位，将它赋为 0，则它右面的数位可以任意取，我们需要统计其中恰好含有 *K-tot* 个 1 的数的个数（其中 *tot* 表示这一位左边的 1 的个数），则可以利用组合数公式求解。逐位枚举所有”1”进行统计即可。

我们发现，之前推出的 *f* 正是**组合数**。同样是采用“逐位确定”的方法，两种方法异曲同工。当你觉得单纯从数位的角度较难思考时，不妨画出图形以方便思考。



### 完整代码

> NOTE: 
>
> 下面代码是截取自 CSDN [ural 1057 Amount of degrees 【数位dp】](https://blog.csdn.net/y990041769/article/details/40515677)



