# [Trie](https://en.wikipedia.org/wiki/Trie)

> NOTE: trie也可以称之为前缀树

In [computer science](https://en.wikipedia.org/wiki/Computer_science), a **trie**, also called **digital tree**, **radix tree** or **prefix tree**, is a kind of [search tree](https://en.wikipedia.org/wiki/Search_tree)—an ordered [tree](https://en.wikipedia.org/wiki/Tree_(data_structure)) [data structure](https://en.wikipedia.org/wiki/Data_structure) used to store a [dynamic set](https://en.wikipedia.org/wiki/Set_(abstract_data_type)) or [associative array](https://en.wikipedia.org/wiki/Associative_array) where the keys are usually [strings](https://en.wikipedia.org/wiki/String_(computer_science)). Unlike a [binary search tree](https://en.wikipedia.org/wiki/Binary_search_tree), no node in the tree stores the **key** associated with that node; instead, its position in the tree defines the key with which it is associated. All the descendants of a node have a common [prefix](https://en.wikipedia.org/wiki/Prefix) of the string associated with that node, and the root is associated with the [empty string](https://en.wikipedia.org/wiki/Empty_string). Keys tend to be associated with leaves, though some inner nodes may correspond to keys of interest. Hence, keys are not necessarily associated with every node. For the space-optimized presentation of prefix tree, see [compact prefix tree](https://en.wikipedia.org/wiki/Compact_prefix_tree).

In the example shown, keys are listed in the nodes and values below them. Each complete English word has an arbitrary integer value associated with it. A trie can be seen as a tree-shaped [deterministic finite automaton](https://en.wikipedia.org/wiki/Deterministic_finite_automaton) （即DFA，确定有穷自动机）. Each [finite language](https://en.wikipedia.org/wiki/Finite_language) is generated by a **trie automaton**, and each trie can be compressed into a [deterministic acyclic finite state automaton](https://en.wikipedia.org/wiki/Deterministic_acyclic_finite_state_automaton).

***SUMMARY*** : 关于finite automata的内容参见《Automata theory-formal languages and formal grammars》目录，其中收录关于finite automata的知识。

***SUMMARY*** : 其实感觉trie更加类似于graph，因为trie的edge有label，类似于weighted graph，所以它的实现除了需要保存节点之间的edge，还需要保存每条edge的label，其实这就非常类似finite automata；

Though tries can be keyed by character strings, they need not be. The same algorithms can be adapted to serve similar functions on **ordered lists** of any construct, e.g. permutations on a list of digits or shapes. In particular, a **bitwise trie** is keyed on the individual bits making up any fixed-length binary datum, such as an integer or memory address.

[![img](https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/250px-Trie_example.svg.png)](https://en.wikipedia.org/wiki/File:Trie_example.svg)

A trie for keys "A", "to", "tea", "ted", "ten", "i", "in", and "inn". Note that this example does not have all the children alphabetically sorted from left to right as it should be (the root and node 't').



## Applications

### As a replacement for other data structures

As discussed below, a trie has a number of advantages over binary search trees.

A trie can also be used to replace a [hash table](https://en.wikipedia.org/wiki/Hash_table), over which it has the following advantages:

- Looking up data in a trie is faster in the worst case, O(m) time (where m is the length of a search string), compared to an imperfect hash table. An imperfect hash table can have key collisions. A key collision is the hash function mapping of different keys to the same position in a hash table. The worst-case lookup speed in an imperfect hash table is [O(N)](https://en.wikipedia.org/wiki/Hash_table#Chaining) time, but far more typically is O(1), with O(m) time spent evaluating the hash.
- There are no collisions of different keys in a trie.
- Buckets in a trie, which are analogous to hash table buckets that store key collisions, are necessary only if a single key is associated with more than one value.
- There is no need to provide a hash function or to change hash functions as more keys are added to a trie.
- A trie can provide an alphabetical ordering of the entries by key.

However, a trie also has some drawbacks compared to a hash table:

- Trie lookup can be slower than hash table lookup, especially if the data is directly accessed on a hard disk drive or some other secondary storage device where the random-access time is high compared to main memory.[[7\]](https://en.wikipedia.org/wiki/Trie#cite_note-triememory-7)
- Some keys, such as floating point numbers, can lead to long chains and prefixes that are not particularly meaningful. Nevertheless, a bitwise trie can handle standard IEEE single and double format floating point numbers.[*citation needed*]
- Some tries can require more space than a hash table, as memory may be allocated for each character in the search string, rather than a single chunk of memory for the whole entry, as in most hash tables.



### Dictionary representation

A common application of a trie is storing a [predictive text](https://en.wikipedia.org/wiki/Predictive_text) or [autocomplete](https://en.wikipedia.org/wiki/Autocomplete) dictionary, such as found on a [mobile telephone](https://en.wikipedia.org/wiki/Mobile_telephone). Such applications take advantage of a trie's ability to quickly search for, insert, and delete entries; however, if storing dictionary words is all that is required (i.e., storage of information auxiliary to each word is not required), a minimal [deterministic acyclic finite state automaton](https://en.wikipedia.org/wiki/Deterministic_acyclic_finite_state_automaton) (DAFSA) would use less space than a trie. This is because a DAFSA can compress identical branches from the trie which correspond to the same suffixes (or parts) of different words being stored.

Tries are also well suited for implementing approximate matching algorithms,[[8\]](https://en.wikipedia.org/wiki/Trie#cite_note-8) including those used in [spell checking](https://en.wikipedia.org/wiki/Spell_checking) and [hyphenation](https://en.wikipedia.org/wiki/Hyphenation_algorithm)[[4\]](https://en.wikipedia.org/wiki/Trie#cite_note-Liang1983-4) software.



### Term indexing

A [discrimination tree](https://en.wikipedia.org/w/index.php?title=Discrimination_tree&action=edit&redlink=1) [term index](https://en.wikipedia.org/wiki/Term_indexing) stores its information in a trie data structure.[[9\]](https://en.wikipedia.org/wiki/Trie#cite_note-9)



## Algorithms

The trie is a tree of nodes which supports `Find` and `Insert` operations. `Find` returns the value for a key string, and Insert inserts a string (the key) and a value into the trie. Both Insert and Find run in O(*n*) time, where `n` is the length of the key.

A simple Node class can be used to represent nodes in the trie:

```python
class Node():
   def __init__(self):
       # Note that using dictionary for children (as in this implementation) would not allow lexicographic sorting mentioned in the next section (Sorting),
       # because ordinary dictionary would not preserve the order of the keys
       self.children : Dict[str, Node] = {}  # mapping from character ==> Node
       self.value : Any = None
```

Note that `children` is a dictionary of characters to a node's children; and it is said that a "terminal" node is one which represents a complete string.
A trie's value can be looked up as follows:

```python
def find(node: Node, key: str) -> Any:
    for char in key:
        if char in node.children:
            node = node.children[char]
        else:
            return None
    return node.value
```

Insertion proceeds by walking the trie according to the string to be inserted, then appending new nodes for the suffix of the string that is not contained in the trie:

```python
def insert(node: Node, key: str, value: Any) -> None:
    for char in key:
        if char not in node.children:
            node.children[char] = Node()
        node = node.children[char]
    node.value = value
```



### Sorting

Lexicographic sorting of a set of keys can be accomplished by building a **trie** from them, and traversing it in [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order), printing only the leaves' values. This algorithm is a form of [radix sort](https://en.wikipedia.org/wiki/Radix_sort).[[10\]](https://en.wikipedia.org/wiki/Trie#cite_note-10)

A trie forms the fundamental data structure of [Burstsort](https://en.wikipedia.org/wiki/Burstsort), which (in 2007) was the fastest known string sorting algorithm.[[11\]](https://en.wikipedia.org/wiki/Trie#cite_note-cachestringsort-11) However, now there are faster string sorting algorithms.[[12\]](https://en.wikipedia.org/wiki/Trie#cite_note-stringradix-12)



### Full text search

A special kind of trie, called a [suffix tree](https://en.wikipedia.org/wiki/Suffix_tree), can be used to index all suffixes in a text in order to carry out fast full text searches.

***SUMMARY*** :  [suffix tree](https://en.wikipedia.org/wiki/Suffix_tree)的确很强大；



## Implementation strategies



There are several ways to represent tries, corresponding to different trade-offs between **memory use** and speed of the operations. The basic form is that of a linked set of nodes, where each node contains an array of child pointers, one for each symbol in the [alphabet](https://en.wikipedia.org/wiki/Alphabet_(computer_science)) (so for the [English alphabet](https://en.wikipedia.org/wiki/English_alphabet), one would store 26 child pointers and for the alphabet of bytes, 256 pointers). This is simple but wasteful in terms of memory: using the alphabet of bytes (size 256) and four-byte pointers, each node requires a kilobyte of storage, and when there is little overlap in the strings' prefixes, the number of required nodes is roughly the combined length of the stored strings.[[2\]](https://en.wikipedia.org/wiki/Trie#cite_note-brass-2):341 Put another way, the nodes near the bottom of the tree tend to have few children and there are many of them, so the structure wastes space storing null pointers.[[13\]](https://en.wikipedia.org/wiki/Trie#cite_note-allison-13)

The storage problem can be alleviated by an implementation technique called *alphabet reduction*, whereby the original strings are reinterpreted as longer strings over a smaller alphabet. E.g., a string of *n* bytes can alternatively be regarded as a string of 2*n* [four-bit units](https://en.wikipedia.org/wiki/Nibble) and stored in a trie with sixteen pointers per node. Lookups need to visit twice as many nodes in the worst case, but the storage requirements go down by a factor of eight.[[2\]](https://en.wikipedia.org/wiki/Trie#cite_note-brass-2):347–352

An alternative implementation represents a node as a triple (symbol, child, next) and links the children of a node together as a [singly linked list](https://en.wikipedia.org/wiki/Singly_linked_list): child points to the node's first child, next to the parent node's next child.[[13\]](https://en.wikipedia.org/wiki/Trie#cite_note-allison-13)[[14\]](https://en.wikipedia.org/wiki/Trie#cite_note-14) The set of children can also be represented as a [binary search tree](https://en.wikipedia.org/wiki/Binary_search_tree); one instance of this idea is the [ternary search tree](https://en.wikipedia.org/wiki/Ternary_search_tree) developed by [Bentley](https://en.wikipedia.org/wiki/Jon_Bentley_(computer_scientist)) and [Sedgewick](https://en.wikipedia.org/wiki/Robert_Sedgewick_(computer_scientist)).[[2\]](https://en.wikipedia.org/wiki/Trie#cite_note-brass-2):353

Another alternative in order to avoid the use of an array of 256 pointers (ASCII), as suggested before, is to store the alphabet array as a **bitmap** of 256 bits representing the ASCII alphabet, reducing dramatically the size of the nodes.[[15\]](https://en.wikipedia.org/wiki/Trie#cite_note-15)

### Bitwise tries

**Bitwise tries** are much the same as a normal character-based trie except that individual bits are used to traverse what effectively becomes a form of binary tree. Generally, implementations use a special CPU instruction to very quickly find the first set bit in a fixed length key (e.g., GCC's `__builtin_clz()` intrinsic). This value is then used to index a 32- or 64-entry table which points to the first item in the bitwise trie with that number of leading zero bits. The search then proceeds by testing each subsequent bit in the key and choosing `child[0]` or `child[1]` appropriately until the item is found.

Although this process might sound slow, it is very cache-local and highly parallelizable due to the lack of register dependencies and therefore in fact has excellent performance on modern [out-of-order execution](https://en.wikipedia.org/wiki/Out-of-order_execution) CPUs. A [red-black tree](https://en.wikipedia.org/wiki/Red-black_tree) for example performs much better on paper, but is highly cache-unfriendly and causes multiple pipeline and [TLB](https://en.wikipedia.org/wiki/Translation_lookaside_buffer) stalls on modern CPUs which makes that algorithm bound by memory latency rather than CPU speed. In comparison, a bitwise trie rarely accesses memory, and when it does, it does so only to read, thus avoiding SMP cache coherency overhead. Hence, it is increasingly becoming the algorithm of choice for code that performs many rapid insertions and deletions, such as memory allocators (e.g., recent versions of the famous [Doug Lea's allocator (dlmalloc) and its descendants](https://en.wikipedia.org/wiki/Malloc#dlmalloc)).

### Compressing tries

Compressing the trie and merging the common branches can sometimes yield large performance gains. This works best under the following conditions:

- The trie is mostly static (key insertions to or deletions from a pre-filled trie are disabled).[*citation needed*]
- Only lookups are needed.
- The trie nodes are not keyed by node-specific data, or the nodes' data are common.[[16\]](https://en.wikipedia.org/wiki/Trie#cite_note-16)
- The total set of stored keys is very sparse within their representation space.[*citation needed*]

For example, it may be used to represent sparse [bitsets](https://en.wikipedia.org/wiki/Bitset), i.e., subsets of a much larger, fixed enumerable set. In such a case, the trie is keyed by the bit element position within the full set. The key is created from the string of bits needed to encode the integral position of each element. Such tries have a very degenerate form with many missing branches. After detecting the repetition of common patterns or filling the unused gaps, the unique leaf nodes (bit strings) can be stored and compressed easily, reducing the overall size of the trie.

Such compression is also used in the implementation of the various fast lookup tables for retrieving [Unicode](https://en.wikipedia.org/wiki/Unicode) character properties. These could include case-mapping tables (e.g. for the [Greek](https://en.wikipedia.org/wiki/Greek_language) letter [pi](https://en.wikipedia.org/wiki/Pi_(letter)), from Π to π), or lookup tables normalizing the combination of base and combining characters (like the a-[umlaut](https://en.wikipedia.org/wiki/Umlaut_(diacritic)) in [German](https://en.wikipedia.org/wiki/German_language), ä, or the [dalet](https://en.wikipedia.org/wiki/Dalet#Hebrew_Dalet)-[patah](https://en.wikipedia.org/wiki/Patah)-[dagesh](https://en.wikipedia.org/wiki/Dagesh)-[ole](https://en.wikipedia.org/wiki/Ole_(cantillation)) in [Biblical Hebrew](https://en.wikipedia.org/wiki/Biblical_Hebrew), דַּ֫). For such applications, the representation is similar to transforming a very large, unidimensional, sparse table (e.g. Unicode code points) into a multidimensional matrix of their combinations, and then using the coordinates in the hyper-matrix as the string key of an uncompressed trie to represent the resulting character. The compression will then consist of detecting and merging the common columns within the hyper-matrix to compress the last dimension in the key. For example, to avoid storing the full, multibyte Unicode code point of each element forming a matrix column, the groupings of similar code points can be exploited. Each dimension of the hyper-matrix stores the start position of the next dimension, so that only the offset (typically a single byte) need be stored. The resulting vector is itself compressible when it is also sparse, so each dimension (associated to a layer level in the trie) can be compressed separately.

Some implementations do support such data compression within dynamic sparse tries and allow insertions and deletions in compressed tries. However, this usually has a significant cost when compressed segments need to be split or merged. Some tradeoff has to be made between data compression and update speed. A typical strategy is to limit the range of global lookups for comparing the common branches in the sparse trie.[*citation needed*]

The result of such compression may look similar to trying to transform the trie into a [directed acyclic graph](https://en.wikipedia.org/wiki/Directed_acyclic_graph) (DAG), because the reverse transform from a DAG to a trie is obvious and always possible. However, the shape of the DAG is determined by the form of the key chosen to index the nodes, in turn constraining the compression possible.

Another compression strategy is to "unravel" the data structure into a single byte array.[[17\]](https://en.wikipedia.org/wiki/Trie#cite_note-17) This approach eliminates the need for node pointers, substantially reducing the memory requirements. This in turn permits memory mapping and the use of virtual memory to efficiently load the data from disk.

One more approach is to "pack" the trie.[[4\]](https://en.wikipedia.org/wiki/Trie#cite_note-Liang1983-4) Liang describes a space-efficient implementation of a sparse packed trie applied to automatic [hyphenation](https://en.wikipedia.org/wiki/Hyphenation_algorithm), in which the descendants of each node may be interleaved in memory.