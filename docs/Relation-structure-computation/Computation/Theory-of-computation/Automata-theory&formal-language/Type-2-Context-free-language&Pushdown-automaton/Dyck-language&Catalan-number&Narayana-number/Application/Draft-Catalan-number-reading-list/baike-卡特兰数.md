# baike [卡特兰数](https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/6125746) 

 卡特兰数又称卡塔兰数，卡特兰数是[组合数学](https://baike.baidu.com/item/组合数学/821134)中一个常出现在各种[计数](https://baike.baidu.com/item/计数/9276342)问题中的[数列](https://baike.baidu.com/item/数列/731531)。以[比利时](https://baike.baidu.com/item/比利时/421128)的数学家欧仁·查理·卡塔兰 (1814–1894)的名字来[命名](https://baike.baidu.com/item/命名/754576)。 



## 应用

 实质上都是**递推等式**的应用 

###  **括号化** 

 矩阵连乘： P=a1×a2×a3×……×an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？(h(n)种) [3]  

###  **出栈次序** 

 一个栈(无穷大)的[进栈](https://baike.baidu.com/item/进栈)序列为1，2，3，…，n，有多少个不同的[出栈](https://baike.baidu.com/item/出栈)序列? 

####  常规分析 

 首先，我们设`f（n）=序列个数为n的出栈序列种数`。（我们假定，最后出栈的元素为k（显然k的取值范围是`1-n`），显然，`k`取不同值时的情况是**相互独立**的，也就是求出每种`k`最后出栈的情况数后可用**加法原则**，由于`k`最后出栈，因此，在`k`入栈之前，比`k`小的值均出栈（因为比`k`小的数肯定是比`k`先入栈的），此处情况有`f(k-1)`种，而之后比`k`大的值入栈，且都在`k`之前出栈，因此有`f(n-k)`种方式，由于比`k`小和比`k`大的值入栈出栈情况是**相互独立**的，此处可用**乘法原则**，`f(n-k)*f(k-1)`种，求和便是Catalan递归式。ps.author.陶百百） 

***SUMMARY*** : `k`的取值范围是`1-n`，即共有`n`种可能性；那每种可能性中，有多少种组合情况呢？是`f(n-k)*f(k-1)`因为需要将前`k-1`个元素的出栈情况和后`n-k`个元素的出栈情况组合起来才能够得到这个n个元素的最终的出栈情况，`f(n-k)`中的每一种情况都可以和`f(k-1)`中的每一种情况进行组合，每一种组合都是一种合理的，所以需要使用**乘法**，而不是使用**加法**；所以最终的公式就是: $ C_{0}=1\quad {\text{and}}\quad C_{n+1}=\sum _{i=0}^{n}C_{i}\,C_{n-i}\quad {\text{for }}n\geq 0, $

 此时，我们若把`k`视为确定一个序数，那么根据[乘法原理](https://baike.baidu.com/item/乘法原理)，`f（n）`的问题就等价于——序列个数为`k-1`的出栈序列种数乘以序列个数为`n - k`的出栈序列种数，即选择`k`这个序数的`f（n）=f（k-1）×f（n-k）`。而k可以选1到n，所以再根据[加法原理](https://baike.baidu.com/item/加法原理)，将`k`取不同值的序列种数相加，得到的总序列种数为：`f（n）=f（0）f（n-1）+f（1）f（n-2）+……+f（n-1）f（0）`。 

看到此处，再看看卡特兰数的递推式，答案不言而喻，即为`f（n）=h（n）= C（2n,n）/（n+1）= c（2n,n）-c（2n,n-1）（n=0，1，2，……）`。

最后，令`f（0）=1，f（1）=1`。

***SUMMARY*** : 上述递归解释非常好；

#### 非常规分析 

 对于每一个数来说，必须进栈一次、出栈一次。我们把[进栈](https://baike.baidu.com/item/进栈)设为状态‘1’，出栈设为状态‘0’。n个数的所有状态对应n个1和n个0组成的2n位[二进制数](https://baike.baidu.com/item/二进制数)。由于等待入栈的操作数按照1‥n的顺序排列、入栈的操作数`b`大于等于[出栈](https://baike.baidu.com/item/出栈)的操作数`a`(`a≤b`)（`a`要出栈，说明`a`已经入过栈的），因此输出序列的总数目=由左而右扫描由`n`个1和`n`个0组成的`2n`位二进制数，1（表示进栈）的累计数不小于0（表示出栈）（表示出栈）的累计数的方案种数。 

***SUMMARY*** : 对于本问题，限制条件是：`1`（表示进栈）的累计数不小于`0`（表示出栈）（表示出栈）的累计数

***SUMMARY*** : 这是这类问题的常规思考方式，它实际是[bijection](https://en.wikipedia.org/wiki/Bijection)；

 在`2n`位二进制数中填入n个1的方案数为`c(2n,n)`,不填1的其余n位自动填0。从中减去不符合要求（由左而右扫描，0的累计数大于1的累计数）的方案数即为所求。 

不符合要求的数的特征是由左而右扫描时，必然在某一奇数位`2m+1`位上首先出现`m+1`个0的累计数和`m`个1的累计数，此后的`2(n-m)-1`位上有`n-m`个 1和`n-m-1`个0。如若把后面这`2(n-m)-1`位上的0和1互换，使之成为`n-m`个0和`n-m-1`个1，结果得1个由`n+1`个0和`n-1`个1组成的`2n`位数，即一个不合要求的数对应于一个由`n+1`个0和`n-1`个1组成的排列。

反过来，任何一个由n+1个0和n-1个1组成的2n位[二进制数](https://baike.baidu.com/item/二进制数)，由于0的个数多2个，2n为[偶数](https://baike.baidu.com/item/偶数)，故必在某一个奇数位上出现0的累计数超过1的累计数。同样在后面部分0和1互换，使之成为由n个0和n个1组成的2n位数，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。

因而不合要求的2n位数与n+1个0，n－1个1组成的排列一一对应。

显然，不符合要求的方案数为c(2n,n+1)。由此得出`输出序列的总数目=c(2n,n)-c(2n,n-1)=c(2n,n)/(n+1)=h(n)`。

***SUMMARY*** : 上述对此问题的解释是不好的，参考如下文章： [折现法——卡特兰数证明](http://blog.sina.com.cn/s/blog_6917f47301010cno.html) 

###  

### 买票找零 

 有2n个人排成一行进入剧场。入场费5元。其中只有n个人有一张5元钞票，另外n人只有10元钞票，剧院无其它钞票，问有多少种方法使得只要有10元的人买票，售票处就有5元的钞票找零？(将持5元者到达视作将5元入栈，持10元者到达视作使栈中某5元出栈) 

***SUMMARY*** : 



### 凸多边形三角划分 

 在一个[凸多边形](https://baike.baidu.com/item/凸多边形)中，通过若干条互不相交的对角线，把这个多边形划分成了若干个三角形。任务是键盘上输入凸多边形的边数n，求不同划分的方案数f（n）。比如当n=6时，f（6）=14。 

#### 分析 

 如果纯粹从f（4）=2，f（5）=5，f（6）=14，……，f（n）=n慢慢去归纳，恐怕很难找到问题的递推式，我们必须从一般情况出发去找规律。 

 因为凸多边形的任意一条边必定属于某一个三角形，所以我们以某一条边为基准，以这条边的两个顶点为起点P1和终点Pn（P即Point），将该凸多边形的顶点依序标记为P1、P2、……、Pn，再在该凸多边形中找任意一个不属于这两个点的顶点Pk（2<=k<=n-1），来构成一个三角形，用这个三角形把一个凸多边形划分成两个凸多边形，其中一个凸多边形，是由P1，P2，……，Pk构成的凸k边形（顶点数即是边数），另一个凸多边形，是由Pk，Pk+1，……，Pn构成的凸n-k+1边形。 

 此时，我们若把Pk视为确定一点，那么根据[乘法原理](https://baike.baidu.com/item/乘法原理)（两个子问题是彼此独立的），f（n）的问题就等价于——凸k多边形的划分方案数乘以凸n-k+1多边形的划分方案数，即选择Pk这个顶点的f（n）=f（k）×f（n-k+1）。而k可以选2到n-1，所以再根据加法原理，将k取不同值的划分方案相加，得到的总方案数为：f（n）=f（2）f（n-2+1）+f（3）f（n-3+1）+……+f（n-1）f（2）。看到此处，再看看卡特兰数的递推式，答案不言而喻，即为f（n）=h（n-2） （n=2，3，4，……）。 

***SUMMARY*** : 上述分析方案是非常好的，它和《计算机算法设计与分析 第四版 王晓东》中分析矩阵连乘问题的思路是一模一样的，由此也可以看出**凸多边形三角划分问题**和**矩阵连乘问题**本质上是类似的；



***SUMMARY*** : 在使用分而治之思想来解释诸如**出栈次序问题**、**凸多边形三角划分问题**的时候，发现这些它们之间的一个共性是子问题之间是**彼此独立**的，在**凸多边形三角划分问题**中，这意味中两个子多边形之间是不可能存在节点之间的相互连接的，在**出栈次序问题**中意味着前k-1个元素已经完全出栈了，所以它压根就不会影响第k个元素（这个比较好理解）；



最后，令f（2）=1，f（3）=1。

此处f（2）=1和f（3）=1的具体缘由须参考详尽的“卡特兰数”，也许可从[凸四边形](https://baike.baidu.com/item/凸四边形)f（4）=f（2）f（3）+ f（3）f（2）=2×f（2）f（3）倒推，四边形的划分方案不用规律推导都可以知道是2，那么2×f（2）f（3）=2，则f（2）f（3）=1，又f（2）和f（3）若存在的话一定是整数，则f（2）=1，f（3）=1。（因为我没研究过卡特兰数的由来，此处仅作刘抟羽的臆测）。



#### 类似问题 

 一位大城市的律师在她住所以北n个街区和以东n个街区处工作。每天她走2n个街区去上班。如果她从不穿越（但可以碰到）从家到办公室的对角线，那么有多少条可能的道路？ 



### 给定节点组成二叉搜索树 

给定N个[节点](https://baike.baidu.com/item/节点)，能构成多少种不同的[二叉搜索树](https://baike.baidu.com/item/二叉搜索树)？

（能构成h（N）个）

（这个公式的下标是从h(0)=1开始的）



### n对括号正确匹配数目 

给定n对括号，求括号正确配对的字符串数，例如：

0对括号：[空序列] 1种可能

1对括号：() 1种可能

2对括号：()() (()) 2种可能

3对括号：((())) ()(()) ()()() (())() (()()) 5种可能

那么问题来了，n对括号有多少种正确配对的可能呢？

考虑n对括号时的任意一种配对方案，最后一个右括号有唯一的与之匹配的左括号，于是有唯一的表示A(B)，其中A和B也是合法的括号匹配序列

假设S(n)为n对括号的正确配对数目，那么有递推关系S(n)=S(0)S(n-1)+S(1)S(n-2) +...+S(n-1)S(0)，显然S(n)是卡特兰数。