# [浅谈数位类统计问题](https://www.gydoc.com/p-5722.html) 

> NOTE: 
>
> 一、ppt
>
> https://max.book118.com/html/2019/1023/7015031056002065.shtm
>
> PPT的内容非常好，是论文的非常好的补充
>
> 二、在阅读 CSDN Accagain  [【DP专辑】ACM动态规划总结](https://blog.csdn.net/cc_again/article/details/25866971?spm=1001.2014.3001.5502) 时，其中提及了这篇论文
>
> 

山东省青岛第二中学 刘聪

## 摘要

在信息学竞赛中，有一类与数位有关的区间统计问题。这类问题往往具有比较浓厚的数学味道，无法暴力求解，需要在数位上进行递推等操作。本文通过几个例子，简要介绍了解决此类问题的基本思想和方法。

## 关键字

数位、区间、统计、递推、树、二进制

## 正文

在信息学竞赛中，有这样一类问题: 求给定区间中，满足给定条件的某个D进制数或此类数的数量。所求的**限定条件**往往和**数位**有关，例如**数位**之和、指定数码个数、数的大小顺序分组等等。题目给定的区间往往很大，无法采用朴素的方法求解。此时，我们就需要利用数位的性质，设计 $log(n)$ 级别复杂度算法。解决这类问题的最基本思想就是"逐位确定"的方法。下面就让我们通过几道例题来具体了解一下这类问题及其思考方法。



## 【例题1】[ural 1057. Amount of Degrees](https://acm.timus.ru/problem.aspx?space=1&num=1057) 

![](./example-1-ural-1057.png)

> NOTE: 
>
> 一、上述分析非常关键
>
> 

这道题满足**区间减法**，因此可以进一步简化问题: 令 $count[i..j]$ 表示 $[i..j]$ 区间内合法数的个数，则 $count[i..j] = count[0..j] - count[0..i-1] $ 。

假设 $n=13$ ，其二进制表示为 $1101, K = 3$ 。我们的目标是求解出 $0$ 到 $13$ 中二进制表示含 $3$ 个 $1$ 的数的个数，为了方便思考，让我们画出一棵高度为 $4$ 的完全二叉树:

![](./complete-binary-tree.png)

为了方便起见，树的根用 $0$​​​ 表示。这样，这棵高度为 $4$​​​ 的完全二叉树就可以表示所有 $4$​​​ 位二进制树 $(0..2^4 - 1)$​​​，每个叶子节点代表一个数。其中，红色路径表示 $n$​​​ 。所有小于 $n$​​​ 的数形成了三棵子树，分别用**蓝色**、**绿色**、**紫色**表示。因此统计小于13的数，就只需要统计这三棵完整的二叉树:

1、统计**蓝色子树**内含3个1的数的个数

> NOTE: 
>
> **蓝色子树** 指的是上述最左边的子树

2、统计**绿色子树**内含2个1的数的个数(因为从根到此处的路径上已经有1个1了)

3、统计**紫色子树**内含1个1的数的个数

注意到，只要是高度相同的子树统计结果一定相同。而需要统计的子树都是"**右转**"时遇到的。

> NOTE: 
>
> 上述"**右转**"如何理解？

当然，我们不能忘记统计 $n$ 本身，实际上，在算法最初时将 $n$ 自加 $1$，可以避免讨论 $n$ 本身，但是需要注意避免上溢。

剩下的问题是，如何统计一棵高度为 $i$ 的完全二叉树内二进制表示中恰好含有 $j$ 个 $1$ 的数的个数。这很容易递推求出:

设 $f[i, j]$ 表示所求，则分别统计左右子树内符合条件数的个数，有 $f[i, j] = f[i - 1, j] + f[i - 1, j - 1]$ 。

这样就可以得到询问的算法: 首先预处理 $f$ ，然后对于深入 $n$ ，我们在假象的完全二叉树中，从根走到 $n$ 所在的叶子，每次向右转时统计左子树内数的个数。下面是C++代码:

```C++
#include <bits/stdc++.h>
using namespace std;

void init()
{
	f[0][0] = 1;
	for (int i = 0; i <= 31; ++i)
	{
		f[i][0] = f[i - 1][0];
		for (int j = 1; j <= i; ++i)
		{
			f[i][j] = f[i - 1][j] + f[i - 1][j - 1];
		}
	}
}
int calc(int x, int k) // 统计[0..x]内二进制表示含k个1的数的个数
{
	int tol = 0, ans = 0; // tol 记录当前路径上已有的1的数量，ans表示答案
	for (int i = 31; i > 0; ++i)
	{
		if (x & (1 << i))
		{
			++tol;
			if (tol > k)
				break;
			x = x ^ (1 << 1);
		}
		if (1 << (i - 1) <= x)
		{
			ans += f[i - 1][k - tol];
		}
	}
	if (tol + x == k)
	{
		++ans;
	}
	return ans;
}
int main()
{
}
// g++ test.cpp --std=c++11 -pedantic -Wall -Wextra -g


```

