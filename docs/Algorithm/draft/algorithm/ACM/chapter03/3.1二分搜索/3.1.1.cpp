//在使用二分查找进行查找的时候，查找的目标是非常多样化的，比如我可以查找在数组中是否有和某个元素相等的元素，也可以查找数组中所有比某个元素都要大的元素，下面罗列是二分查找中的目标的分类：
/*
1. 查找数组中和k相等的元素的最小或最大下标，不存在和k相等的元素的情况下返回-1
2. 查找满足a[i]>=k条件的最小的i
3. 查找满足a[i]<=k条件的最大的i
（注意绝对不会想要你查找满足a[i]>=k的最大的i，这是一个非常明显的问题，数组的最后一个元素是数组中最大的元素，所只要它满足条件那么他就是最大i）
*/



//因为我要找的是使a[i]>=k的最小的i的值，所以如果a[n/2]==k，存在的可能性是在a[n/2]的左侧还有值与k相等，这时还是要到左段去寻找，和基本的二分查找不相同的是即使相等也不能够停止。
//我现在的问题是为什么最终的解是ub呢？
//答：最终的终止条件是ub-lb==1，即两者指向的元素为相邻的两个元素，在程序中，第一个条件判断分支为a[mid]>=k的时候就将ub赋值为mid，注意其中包含了一个等于，所以在程序中一直只有ub保存了与k相等的元素的下标。因为程序的目的是寻找等于k的最小的i，所以即使和k相等依旧需要不断地寻找，lb所保存的元素的下标是与k不相等的元素的下标，所以当两者ub-lb等于1的时候，即两个元素为相邻的元素的时候，lb所标识的元素为与k不相等的元素而ub所标识的元素为与k相等的元素，那么我们就可以判断ub所标识的元素一定是数组中第一个出现的和k相等的元素。
//在理解这段程序的过程中，我突然想到了其实这个问题的本质和这一节后续问题的本质是非常相同的。在数组中可能存在多个和k相等的元素，但是我要寻找的是这些和k相等的元素中的第一个，即下标最小的一个。后续的问题多讨论的是在问题的众多解中寻找最小的解，你看它们是不是本质相同的。正因为它们相同的本质，所以二分查找才能够奏效。

int n,k;
int a[MAX_N];//MAX_N是n的最大值

void solve(){
	//初始化解的存在范围
	int lb=0,ub=n-1;
	while(ub-lb>1){
		int mid=(ub+lb)/2;
		if(a[mid]>=k)ub=mid;//在程序中只有ub记录了和k值相等的元素的下标，因此最终的结果为ub
		else lb=mid;//lb记录的始终是和k不相等的元素的下标，因此当lb和ub为相邻元素的时候就表示ub即为最终解
	}
	printf("%d\n",ub)；
}


//变式：求满足a[i]<=k的最大的i,也就是说，在k的左侧的元素皆比k小，在k的右边的元素皆比k大
void solve(){
	//初始化解的存在范围
	int lb=0,ub=n-1;
	while(ub-lb>1){
		int mid=(ub+lb)/2;
		if(a[mid]<=k)lb=mid;//说明解不小于mid
		else ub=mid;//lb记录的始终是不满足条件的元素的下标，因此当lb和ub为相邻元素的时候就表示lb即为最终解
	}
	printf("%d\n",lb)；
}