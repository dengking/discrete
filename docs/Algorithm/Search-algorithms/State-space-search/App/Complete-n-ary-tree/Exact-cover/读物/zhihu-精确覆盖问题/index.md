# zhihu [精确覆盖问题](https://zhuanlan.zhihu.com/p/617477033) 

## 精确覆盖问题的定义

精确覆盖问题（Exact cover）的定义如下：

> 给定一个大集合X={a1, a2, ..., am}（本文我们默认集合中不包含重复元素，且集合元素无序，下文不再赘述），以及一系列X的子集S1, S2, ..., Sn。要求从这n个子集中选出若干个，使得选出的所有子集两两互斥，且它们的并集恰好等于X。

用通俗的说法：我们需要从大集合X的一组子集中选出若干个，使得这些子集能够不重不漏的恰好构成大集合X。如果一个子集包含一个元素，我们称这个子集**覆盖**这个元素。精确覆盖，顾名思义，就是每个元素都恰好被一个子集覆盖了。

下图中给出了一个例子。大集合X包含6个元素。不失一般性，我们用0~5这6个编号来表示这6个元素。S1~S5是X的5个子集，它们各自包含的元素分别如下图所示。可以看到，S1+S2构成对X的精确覆盖，因为它们的交集为空，且它们的并集恰好等于大集合X。同样的，S2+S4+S5也构成对X的精确覆盖。

除此之外，其它任意子集合的组合均不构成对X的精确覆盖。例如S2+S3，虽然它们的并集等于大集合X，但是它们的交集不为空。如果两个子集合的交集非空，我们称这两个子集之间存在**冲突**。再例如S2+S4，虽然它们之间没有冲突，但是它们的并集不等于X，所以这仍旧不是**精确覆盖**。

![img](https://pic3.zhimg.com/80/v2-5850c6be6d8da6d28ccd012b73890bd6_1440w.webp)

这个例子中包含两个精确覆盖：S1+S2，或者S2+S4+S5。

已经证明，**精确覆盖问题**是NP完全的，所以不存在多项式时间内的解法。但是没关系，我们只需要尽可能找到更优秀的解法就可以了。

## 基于深度优先搜索（DFS）的解法

既然已经知道**精确覆盖问题**是NP完全的了，搜索自然而然就成为了最合适的解法。对于搜索算法有一定了解的读者都可以比较容易的想到利用DFS解决精确覆盖问题的大致框架：

## 精确覆盖问题能用来做什么

### 方块覆盖问题

> NOTE:
>
> 一、将方格看作是元素，因此每种**摆放方式**对应一个子集；怎么才能让同一个方块的不同摆放方式不能被重复选择呢？只需要特意制造冲突就可以了。我们给k个方块从0到k-1编号，然后把这k个编号也看做是一部分元素。这样每种摆放方式也就包含了方块信息了。通过这额外添加的、对应着一个方块的元素，我们就保证了同一个方块的不同摆放方式中最多只可能选中一个。

### 数独

按照上一节介绍的一般性方法，我们先分析数独中有哪些操作。这是比较显然的：【在某个格子中填写某个数字】就是一个操作，可以对应到一个子集。因为一共有$9*9=81$个格子，每个格子里可能填写1~9，所以一共有$81*9=729$个操作，也就是729个子集。

然后我们分析，有哪些子集之间应当是互斥的，也就是至多选择一个。这也很简单，直接根据数独的定义就可以分析出来：

1、在同一个格子内填写数字的操作之间应当是互斥的，因为每个格子只能填写一个数字。

> NOTE:
>
> 避免在同一个格子中写入数字的子集被包含



每个操作对应的子集，都恰好包含4个元素，每组一个。

> NOTE:
>
> 一、其实非常简单: 共有81个子集，然后每个子集包含上述4个元素，这样就描述了所有的可能性和限制了
>
> 将可能性和限制一起进行编码，然后使用DLX算法进行实现
>
> 将限制也进行编码
