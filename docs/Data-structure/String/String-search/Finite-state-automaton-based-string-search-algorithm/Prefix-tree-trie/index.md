# 关于本章

---

> References:
>
> - wikipedia [Trie](https://en.wikipedia.org/wiki/Trie) 
> - 宫水三叶
>   - [宫水三叶-Trie](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE3MTEyMA==&action=getalbum&album_id=2049538161285955584&scene=173&from_msgid=2247488490&from_itemidx=1&count=3&nolastread=1#wechat_redirect) 
>   - [宫水三叶-字典树](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE3MTEyMA==&action=getalbum&album_id=2049538161051074564&scene=173&from_msgid=2247488490&from_itemidx=1&count=3&nolastread=1#wechat_redirect) 
>   - [宫水三叶【设计数据结构】实现 Trie (前缀树)](https://mp.weixin.qq.com/s/DBTQyNYsEgmN0Vb5fbolUg) 
>   - [宫水三叶【设计数据结构】Trie 运用题](https://mp.weixin.qq.com/s/TPVBlNBLlUpQKXK_XkR-3Q) 
> - geeksforgeeks [Trie | (Insert and Search)](https://www.geeksforgeeks.org/tag/trie/) 

---



## Trie-is-DFA

Trie本质上是DFA，它指定了每个节点在当前字符下的转移到下一个节点，它可以使用weighted-directed-graph来进行实现。



## wikipedia [Trie](https://en.wikipedia.org/wiki/Trie) 

> NOTE: 
>
> 一、trie也可以称之为前缀树

In [computer science](https://en.wikipedia.org/wiki/Computer_science), a **trie**, also called **digital tree**, **radix tree** or **prefix tree**, is a kind of [search tree](https://en.wikipedia.org/wiki/Search_tree)—an ordered [tree](https://en.wikipedia.org/wiki/Tree_(data_structure)) [data structure](https://en.wikipedia.org/wiki/Data_structure) used to store a [dynamic set](https://en.wikipedia.org/wiki/Set_(abstract_data_type)) or [associative array](https://en.wikipedia.org/wiki/Associative_array) where the keys are usually [strings](https://en.wikipedia.org/wiki/String_(computer_science)). Unlike a [binary search tree](https://en.wikipedia.org/wiki/Binary_search_tree), no node in the tree stores the **key** associated with that node; instead, its position in the tree defines the key with which it is associated. All the descendants of a node have a common [prefix](https://en.wikipedia.org/wiki/Prefix) of the string associated with that node, and the root is associated with the [empty string](https://en.wikipedia.org/wiki/Empty_string). Keys tend to be associated with leaves, though some inner nodes may correspond to keys of interest. Hence, keys are not necessarily associated with every node. For the space-optimized presentation of prefix tree, see [compact prefix tree](https://en.wikipedia.org/wiki/Compact_prefix_tree).

In the example shown, keys are listed in the nodes and values below them. Each complete English word has an arbitrary integer value associated with it. A trie can be seen as a tree-shaped [deterministic finite automaton](https://en.wikipedia.org/wiki/Deterministic_finite_automaton) （即DFA，确定有穷自动机）. Each [finite language](https://en.wikipedia.org/wiki/Finite_language) is generated by a **trie automaton**, and each trie can be compressed into a [deterministic acyclic finite state automaton](https://en.wikipedia.org/wiki/Deterministic_acyclic_finite_state_automaton).

> NOTE: 
>
> 一、关于finite automata的内容参见《Automata theory-formal languages and formal grammars》目录，其中收录关于finite automata的知识。
>
> 二、其实感觉trie更加类似于graph，因为trie的edge有label，类似于weighted directed graph，所以它的实现除了需要保存节点之间的edge，还需要保存每条edge的label，其实这就非常类似finite automata；

Though tries can be keyed by character strings, they need not be. The same algorithms can be adapted to serve similar functions on **ordered lists** of any construct, e.g. permutations on a list of digits or shapes. In particular, a **bitwise trie** is keyed on the individual bits making up any fixed-length binary datum, such as an integer or memory address.

[![img](https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/250px-Trie_example.svg.png)](https://en.wikipedia.org/wiki/File:Trie_example.svg)

A trie for keys "A", "to", "tea", "ted", "ten", "i", "in", and "inn". Note that this example does not have all the children alphabetically sorted from left to right as it should be (the root and node 't').

​	

### Algorithms

The trie is a tree of nodes which supports `Find` and `Insert` operations. `Find` returns the value for a key string, and Insert inserts a string (the key) and a value into the trie. Both Insert and Find run in O(*n*) time, where `n` is the length of the key.

A simple Node class can be used to represent nodes in the trie:

```python
class Node():
   def __init__(self):
       # Note that using dictionary for children (as in this implementation) would not allow lexicographic sorting mentioned in the next section (Sorting),
       # because ordinary dictionary would not preserve the order of the keys
       self.children : Dict[str, Node] = {}  # mapping from character ==> Node
       self.value : Any = None
```

Note that `children` is a dictionary of characters to a node's children; and it is said that a "terminal" node is one which represents a complete string.
A trie's value can be looked up as follows:

```python
def find(node: Node, key: str) -> Any:
    for char in key:
        if char in node.children:
            node = node.children[char]
        else:
            return None
    return node.value
```

Insertion proceeds by walking the trie according to the string to be inserted, then appending new nodes for the suffix of the string that is not contained in the trie:

```python
def insert(node: Node, key: str, value: Any) -> None:
    for char in key:
        if char not in node.children:
            node.children[char] = Node()
        node = node.children[char]
    node.value = value
```

### Implementation strategies

#### Compressed tries

*Main article:* [Radix tree](https://en.wikipedia.org/wiki/Radix_tree)

##### Patricia trees



### Code

#### Python

```python
import unittest
from typing import Dict


class TrieNode:
    def __init__(self):
        self.children: Dict[str, TrieNode] = {}
        self.is_end_of_word = False


class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True

    def search(self, word: str):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end_of_word

    def starts_with(self, prefix: str):
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True


class TestTrie(unittest.TestCase):
    def test_trie(self):
        # Example usage
        trie = Trie()
        trie.insert("apple")
        print(trie.search("apple"))  # Returns True
        print(trie.search("app"))  # Returns False
        print(trie.starts_with("app"))  # Returns True
        trie.insert("app")
        print(trie.search("app"))  # Returns True

```







## Applications



### [Predictive text](https://en.wikipedia.org/wiki/Predictive_text) or [autocomplete](https://en.wikipedia.org/wiki/Autocomplete) dictionaries 

> NOTE:
>
> 在 [stanford.-Tries and Suffix Trees](https://web.stanford.edu/class/cs166/lectures/04/Slides04.pdf) 中，有着很好的描述

### Sorting

Lexicographic sorting of a set of keys can be accomplished by building a **trie** from them, and traversing it in [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order), printing only the leaves' values. This algorithm is a form of [radix sort](https://en.wikipedia.org/wiki/Radix_sort).[[10\]](https://en.wikipedia.org/wiki/Trie#cite_note-10)

A trie forms the fundamental data structure of [Burstsort](https://en.wikipedia.org/wiki/Burstsort), which (in 2007) was the fastest known string sorting algorithm.[[11\]](https://en.wikipedia.org/wiki/Trie#cite_note-cachestringsort-11) However, now there are faster string sorting algorithms.[[12\]](https://en.wikipedia.org/wiki/Trie#cite_note-stringradix-12)

### Full text search

A special kind of trie, called a [suffix tree](https://en.wikipedia.org/wiki/Suffix_tree), can be used to index all suffixes in a text in order to carry out fast full text searches.

> NOTE:  [suffix tree](https://en.wikipedia.org/wiki/Suffix_tree)的确很强大；



### [Aho–Corasick algorithm](https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm)

KMP-failure-function+trie



### [Huffman coding](https://en.wikipedia.org/wiki/Huffman_coding)

Huffman coding tree也可以看作是一种trie

