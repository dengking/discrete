# 关于本章

---

> References:
>
> - wikipedia [Trie](https://en.wikipedia.org/wiki/Trie) 
> - 宫水三叶
>   - [宫水三叶-Trie](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE3MTEyMA==&action=getalbum&album_id=2049538161285955584&scene=173&from_msgid=2247488490&from_itemidx=1&count=3&nolastread=1#wechat_redirect) 
>   - [宫水三叶-字典树](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE3MTEyMA==&action=getalbum&album_id=2049538161051074564&scene=173&from_msgid=2247488490&from_itemidx=1&count=3&nolastread=1#wechat_redirect) 
>   - [宫水三叶【设计数据结构】实现 Trie (前缀树)](https://mp.weixin.qq.com/s/DBTQyNYsEgmN0Vb5fbolUg) 
>   - [宫水三叶【设计数据结构】Trie 运用题](https://mp.weixin.qq.com/s/TPVBlNBLlUpQKXK_XkR-3Q) 
> - geeksforgeeks [Trie | (Insert and Search)](https://www.geeksforgeeks.org/tag/trie/) 
> - stanford [CS166](https://web.stanford.edu/class/cs166/) # [**Tries and Suffix Trees**](https://web.stanford.edu/class/cs166/) 

---



## Trie-is-DFA

Trie本质上是DFA，它指定了每个节点在当前字符下的转移到下一个节点，它可以使用**weighted-directed-graph**来进行实现。



## wikipedia [Trie](https://en.wikipedia.org/wiki/Trie) 

> NOTE: 
>
> 一、trie也可以称之为前缀树

In [computer science](https://en.wikipedia.org/wiki/Computer_science), a **trie**, also called **digital tree**, **radix tree** or **prefix tree**, is a kind of [search tree](https://en.wikipedia.org/wiki/Search_tree)—an ordered [tree](https://en.wikipedia.org/wiki/Tree_(data_structure)) [data structure](https://en.wikipedia.org/wiki/Data_structure) used to store a [dynamic set](https://en.wikipedia.org/wiki/Set_(abstract_data_type)) or [associative array](https://en.wikipedia.org/wiki/Associative_array) where the keys are usually [strings](https://en.wikipedia.org/wiki/String_(computer_science)). Unlike a [binary search tree](https://en.wikipedia.org/wiki/Binary_search_tree), no node in the tree stores the **key** associated with that node; instead, its position in the tree defines the key with which it is associated. All the descendants of a node have a common [prefix](https://en.wikipedia.org/wiki/Prefix) of the string associated with that node, and the root is associated with the [empty string](https://en.wikipedia.org/wiki/Empty_string). Keys tend to be associated with leaves, though some inner nodes may correspond to keys of interest. Hence, keys are not necessarily associated with every node. For the space-optimized presentation of prefix tree, see [compact prefix tree](https://en.wikipedia.org/wiki/Compact_prefix_tree).

In the example shown, keys are listed in the nodes and values below them. Each complete English word has an arbitrary integer value associated with it. A trie can be seen as a tree-shaped [deterministic finite automaton](https://en.wikipedia.org/wiki/Deterministic_finite_automaton) （即DFA，确定有穷自动机）. Each [finite language](https://en.wikipedia.org/wiki/Finite_language) is generated by a **trie automaton**, and each trie can be compressed into a [deterministic acyclic finite state automaton](https://en.wikipedia.org/wiki/Deterministic_acyclic_finite_state_automaton).

> NOTE: 
>
> 一、关于finite automata的内容参见《Automata theory-formal languages and formal grammars》目录，其中收录关于finite automata的知识。
>
> 二、其实感觉trie更加类似于graph，因为trie的edge有label，类似于weighted directed graph，所以它的实现除了需要保存节点之间的edge，还需要保存每条edge的label，其实这就非常类似finite automata；

Though tries can be keyed by character strings, they need not be. The same algorithms can be adapted for ordered lists of any underlying type, e.g. [permutations](https://en.wikipedia.org/wiki/Permutation) of digits or shapes. In particular, a **bitwise trie** is keyed on the individual bits making up a piece of fixed-length binary data, such as an integer or [memory address](https://en.wikipedia.org/wiki/Memory_address). The key lookup complexity of a trie remains proportional to the key size. Specialized trie implementations such as compressed tries are used to deal with the enormous space requirement of a trie in naive implementations.

> NOTE:
>
> 一、trie-permutation: 
>
> trie-string
>
> trie-digital-radix-tree: radix sort
>
> 

[![img](https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/250px-Trie_example.svg.png)](https://en.wikipedia.org/wiki/File:Trie_example.svg)

A trie for keys "A", "to", "tea", "ted", "ten", "i", "in", and "inn". Note that this example does not have all the children alphabetically sorted from left to right as it should be (the root and node 't').

​	

### Operations

The trie is a tree of nodes which supports `Find` and `Insert` operations. `Find` returns the value for a key string, and Insert inserts a string (the key) and a value into the trie. Both Insert and Find run in O(*n*) time, where `n` is the length of the key.

A simple Node class can be used to represent nodes in the trie:

```python
class Node():
   def __init__(self):
       # Note that using dictionary for children (as in this implementation) would not allow lexicographic sorting mentioned in the next section (Sorting),
       # because ordinary dictionary would not preserve the order of the keys
       self.children : Dict[str, Node] = {}  # mapping from character ==> Node
       self.value : Any = None
```

Note that `children` is a dictionary of characters to a node's children; and it is said that a "terminal" node is one which represents a complete string.
A trie's value can be looked up as follows:

```python
def find(node: Node, key: str) -> Any:
    for char in key:
        if char in node.children:
            node = node.children[char]
        else:
            return None
    return node.value
```

#### Insertion

Insertion into trie is guided by using the [character sets](https://en.wikipedia.org/wiki/Character_encoding#Character_sets,_character_maps_and_code_pages) as indexes to the **children array** until the last character of the string key is reached. Each node in the trie corresponds to one call of the [radix sorting](https://en.wikipedia.org/wiki/Radix_sorting) routine, as the trie structure reflects the execution of pattern of the top-down **radix sort**. 

```pseudocode
Trie-Insert(x, key, value)
    for 0 ≤ i < key.length do
        if x.Children[key[i]] = nil then
            x.Children[key[i]] := Node()
        end if
        x := x.Children[key[i]]
    repeat
    x.Value := value
    x.Is-Terminal := True
```



### Implementation strategies

#### Compressed tries

*Main article:* [Radix tree](https://en.wikipedia.org/wiki/Radix_tree)

##### Patricia trees



### Code

#### Python



```python
import unittest
from typing import Dict


class TrieNode:
    def __init__(self):
        self.children: Dict[str, TrieNode] = {}
        self.is_end_of_word = False


class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True

    def search(self, word: str):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end_of_word

    def starts_with(self, prefix: str):
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True


class TestTrie(unittest.TestCase):
    def test_trie(self):
        # Example usage
        trie = Trie()
        trie.insert("apple")
        self.assertTrue(trie.search("apple"))  # Returns True
        self.assertFalse(trie.search("app"))  # Returns False
        self.assertTrue(trie.starts_with("app"))  # Returns True
        trie.insert("app")
        self.assertTrue(trie.search("app"))  # Returns True

```





```python
import unittest
from typing import List


class TrieNode:
    def __init__(self):
        self.children = [-1] * 26  # 共26个字母，-1表示null
        self.is_end_of_word = False


class Trie:
    def __init__(self):
        self.nodes: List[TrieNode] = [TrieNode()]

    def insert(self, word: str):
        node_idx = 0  # root node
        for char in word:
            char_idx = ord(char) - ord('a')
            if self.nodes[node_idx].children[char_idx] == -1:
                self.nodes[node_idx].children[char_idx] = len(self.nodes)
                self.nodes.append(TrieNode())
            node_idx = self.nodes[node_idx].children[char_idx]
        self.nodes[node_idx].is_end_of_word = True

    def search(self, word: str):
        node_idx = 0
        for char in word:
            char_idx = ord(char) - ord('a')
            if self.nodes[node_idx].children[char_idx] == -1:
                return False
            node_idx = self.nodes[node_idx].children[char_idx]
        return self.nodes[node_idx].is_end_of_word

    def starts_with(self, prefix: str):
        node_idx = 0
        for char in prefix:
            char_idx = ord(char) - ord('a')
            if self.nodes[node_idx].children[char_idx] == -1:
                return False
            node_idx = self.nodes[node_idx].children[char_idx]
        return True


class TestTrie(unittest.TestCase):
    def test_trie(self):
        # Example usage
        trie = Trie()
        trie.insert("apple")
        self.assertTrue(trie.search("apple"))  # Returns True
        self.assertFalse(trie.search("app"))  # Returns False
        self.assertTrue(trie.starts_with("app"))  # Returns True
        trie.insert("app")
        self.assertTrue(trie.search("app"))  # Returns True

```



## Applications



### [Predictive text](https://en.wikipedia.org/wiki/Predictive_text) or [autocomplete](https://en.wikipedia.org/wiki/Autocomplete) dictionaries 

> NOTE:
>
> 在 [stanford.-Tries and Suffix Trees](https://web.stanford.edu/class/cs166/lectures/04/Slides04.pdf) 中，有着很好的描述

### [Longest prefix match](https://en.wikipedia.org/wiki/Longest_prefix_match) 

> NOTE:
>
> 一、trie非常适合于实现这种任务。
>
> 二、[LeetCode-14. Longest Common Prefix-Easy](https://leetcode.com/problems/longest-common-prefix/) 
>
> 

### Sorting

[Lexicographic sorting](https://en.wikipedia.org/wiki/Lexicographic_order) of a set of keys can be accomplished by building a **trie** from them, and traversing it in [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order), printing only the leaves' values. This algorithm is a form of [radix sort](https://en.wikipedia.org/wiki/Radix_sort).

> NOTE:
>
> 一、[LeetCode-386. Lexicographical Numbers-Medium](https://leetcode.cn/problems/lexicographical-numbers/) 
>
> 

A trie forms the fundamental data structure of [Burstsort](https://en.wikipedia.org/wiki/Burstsort), which (in 2007) was the fastest known string sorting algorithm.[[11\]](https://en.wikipedia.org/wiki/Trie#cite_note-cachestringsort-11) However, now there are faster string sorting algorithms.[[12\]](https://en.wikipedia.org/wiki/Trie#cite_note-stringradix-12)

### Full text search

A special kind of trie, called a [suffix tree](https://en.wikipedia.org/wiki/Suffix_tree), can be used to index all suffixes in a text in order to carry out fast full text searches.

> NOTE:  [suffix tree](https://en.wikipedia.org/wiki/Suffix_tree)的确很强大；



### [Aho–Corasick algorithm](https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm)



### [Huffman coding](https://en.wikipedia.org/wiki/Huffman_coding)

Huffman coding tree也可以看作是一种trie



## LeetCode

参加 `LeetCode-trie` 章节。



[LeetCode-386. Lexicographical Numbers-Medium](https://leetcode.cn/problems/lexicographical-numbers/) 

```python
import unittest
from typing import *


class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        ans = []
        for digit in range(1, 10):
            self.dfs(digit, n, ans)
        return ans

    def dfs(self, num, n, ans: List[int]):
        if num > n:
            return
        ans.append(num)
        for digit in range(0, 10):
            self.dfs(num * 10 + digit, n, ans)


class TestSolution(unittest.TestCase):
    def test_solution(self):
        solution = Solution()
        ans = solution.lexicalOrder(13)
        self.assertEqual(ans, [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9])
        ans = solution.lexicalOrder(2)
        self.assertEqual(ans, [1, 2])

```

