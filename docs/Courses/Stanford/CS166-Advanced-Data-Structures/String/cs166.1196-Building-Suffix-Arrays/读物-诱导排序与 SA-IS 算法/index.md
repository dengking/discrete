# riteme [诱导排序与 SA-IS 算法](https://riteme.site/blog/2016-6-19/sais.html)



## 2. SA-IS 算法

```pseudocode
function SA-IS(S):
    t = bool[]
    S1 = int[]
    P = int[]
    bucket = int[]
    扫描倒序字符串确定每一个后缀的类型 -> t
    扫描t数组确定所有的 LMS 子串 -> P
    对所有的 LMS 子串进行诱导排序
    对每一个 LMS 子串重新命名，生成新的串 S1

    if S1 中的每一个字符都不一样:
        直接计算 SA1
    else
        SA1 = SA-IS(S1)  # 递归计算 SA1

    利用 SA1 来进行诱导排序，计算 SA
    return SA
```

### 2.1 后缀类型



关于后缀类型，我们还可得出另外一个比较重要的性质：



#### **引理 2.2**　(后缀类型指导排序)

对于两个后缀 A 和 B，如果 $A[0]=B[0]$ 且 *A* 是 *S* 型，*B* 是 *L* 型，则 *A*>*B*。



### 2.2 LMS 子串

然而光有后缀类型，还不足以进行排序。因此我们在后缀类型的 *S* 型中挑出特别的一类，记为 ∗ 型。∗ 型是 *S* 型的一种，它的特殊之处在于它要求它的左边的后缀必须是 *L* 型的。依然以 `mmiissiissiippii` 为例：

```pseudocode
      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
S[i]: m  m  i  i  s  s  i  i  s  s  i  i  p  p  i  i  #
t[i]: L  L  S  S  L  L  S  S  L  L  S  S  L  L  L  L  S
            *           *           *                 *
```



可以将其理解为一连串的 *S* 型中最靠左的一个。LMS (LeftMost S-type) 也正是这个意思。

同时我们注意到，后缀 `#` 始终是 ∗ 型的。

对于每一个 ∗ 型所对应上的字符，我们称为 LMS 字符。上面的示例中，下标为 2,6,10,16都是 LMS 字符。 位置相邻的两个 LMS 字符中间（包括这两个字符）所构成的子串，称为 **LMS 子串**。特殊的，最后一个字符 `#` 单独作为一个平凡的 LMS 子串。



对于 LMS 子串间的大小比较，除了对每个字符的字典序进行比较外，还要对比每个字符所对应的后缀类型。字符相同的情况下，*S* 型的字典序更大，因为根据引理 2.2 可得，首字符相同的情况下，*S* 型的后缀字典序更大。只有当每一个字符以及后缀类型都相同时，这两个 LMS 子串才被称为是相同的。 换言之，两个 LMS 子串之间的字典序比较是将原串转为 `(字符，后缀类型)` 的序列后再比较的。

**引理 2.7**　对任意两个 LMS 子串，不存在一个 LMS 子串是另外一个 LMS 子串的真前缀。

> NOTE:
>
> 一、这里的真前缀比较其实也是基于  `(字符，后缀类型)` 来进行比较的

比较的时候加上后缀类型是为了方便之后引理 2.8 的论证，同时后面介绍的 LMS 子串诱导排序的过程实际上也是按这个比较方式来排序的。

**引理 2.8**　(问题缩减) S1 中两个后缀的字典序关系，就是 S 中对应的 `∗` 型后缀的字典序关系。
