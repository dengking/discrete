# [oi-wiki-旋转卡壳](https://oi-wiki.org/geometry/rotating-calipers/)

## 求凸包直径

### 过程

首先使用任何一种凸包算法求出给定所有点的凸包，有着最长距离的点对一定在凸包上。而由于凸包的形状，我们发现，逆时针地遍历凸包上的边，对于每条边都找到离这条边最远的点，那么这时随着边的转动，对应的最远点也在逆时针旋转，不会有反向的情况，这意味着我们可以在逆时针枚举凸包上的边时，记录并维护一个当前最远点，并不断计算、更新答案。

> NOTE:
>
> 一、"逆时针地遍历凸包上的边，对于每条边都找到离这条边最远的点，那么这时随着边的转动，对应的最远点也在逆时针旋转"
>
> 边和点都同时、同向移动保证了算法的简单性

求出凸包后的数组自然地是按照逆时针旋转的顺序排列，不过要记得提前将最左下角的 1 节点补到数组最后，这样在挨个枚举边 $(i,i+1)$ 时，才能把所有边都枚举到。

![img](https://oi-wiki.org/geometry/images/rotating-calipers1.png)

枚举过程中，对于每条边，都检查 $j+1$ 和边 $(i,i+1)$ 的距离是不是比 $j$ 更大，如果是就将 $j$ 加一，否则说明 $j$ 是此边的最优点。判断点到边的距离大小时可以用**叉积**分别算出两个三角形的面积（如图，黄、蓝两个同底三角形的面积)并直接比较。



## 求最小矩形覆盖

[Luogu P3187 最小矩形覆盖](https://www.luogu.com.cn/problem/P3187)

给定一些点的坐标，求能够覆盖所有点的最小面积的矩形。（$3\leq n \leq 50000$)

### 过程

有了上一道题做铺垫，这道题比较直观的想法仍然是使用**旋转卡壳法**，不过这次要求的是面积，像上一题一样只维护一个最优点就只能找到一对距离最小的**平行线**，我们还需要确定矩形的左右边界。所以这次我们需要维护三个点：一个在所枚举的直线对面的点、两个在不同侧面的点。对面的**最优点**仍然是用**叉积**算面积来比较，此时比较面积就是在比较这个矩形的一个边长。侧面的最优点则是用**点积**来比较，因为比较点积就是比较投影的长度，左右两个投影长度相加可以代表这个矩形的另一个边长。这两个边长的最优性**相互独立**，因此找到三个最优点的位置就能够确定以当前边所在直线为矩阵的一条边时，能覆盖所有点的矩形最小面积。

![img](https://oi-wiki.org/geometry/images/rotating-calipers2.png)

最后统计答案时，如果题目没有要求将四个顶点都求出来，其实有一种较为巧妙的利用**叉积**和**点积**的方式直接算出矩阵的面积。设紫色部分面积的两倍为 $S$，最后的面积就是

 $S\times (|\overrightarrow{AD}\cdot \overrightarrow{AB}|+|\overrightarrow{BC}\cdot \overrightarrow{BA}|-|\overrightarrow{AB}\cdot \overrightarrow{BA}|)/|\overrightarrow{AB}\cdot \overrightarrow{BA}|$ 



