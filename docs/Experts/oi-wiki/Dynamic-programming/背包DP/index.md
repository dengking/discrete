# [oi-wiki-背包 DP](https://oi-wiki.org/dp/knapsack/) 

## 引入

[「USACO07 DEC」Charm Bracelet](https://www.luogu.com.cn/problem/P2871)



在上述例题中，由于每个物体只有两种可能的状态（取与不取），对应二进制中的 $0$ 和 $1$，这类问题便被称为「0-1 背包问题」。

## 0-1 背包



例题中已知条件有第 $i$ 个物品的重量 $w_{i}$，价值 $v_{i}$，以及背包的总容量 ![W](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)。

设 DP 状态 $f_{i,j}$ 为在只能放前 $i$ 个物品的情况下，容量为 $j$ 的背包所能达到的**最大总价值**。

考虑转移。假设当前已经处理好了前 $i-1$ 个物品的所有状态，那么对于第 $i$ 个物品，当其不放入背包时，背包的剩余容量不变，背包中物品的总价值也不变，故这种情况的最大价值为 $f_{i-1,j}$；当其放入背包时，背包的剩余容量会减小 $w_{i}$，背包中物品的总价值会增大 $v_{i}$，故这种情况的最大价值为 $f_{i-1,j-w_{i}}+v_{i}$。

> NOTE:
>
> 一、$j-w_{i}$ 的原因是由于题目要求解的是最优值，所以尽可能的将背包装满

由此可以得出状态转移方程：

 $f_{i,j}=\max(f_{i-1,j},f_{i-1,j-w_{i}}+v_{i})$ 

这里如果直接采用二维数组对状态进行记录，会出现 MLE。可以考虑改用**滚动数组**的形式来优化。

由于对 $f_i$ 有影响的只有 $f_{i-1}$，可以去掉第一维，直接用 $f_{j}$ 来表示处理到当前物品时背包容量为 $j$ 的最大价值，得出以下方程：
 $f_j=\max \left(f_j,f_{j-w_i}+v_i\right)$ 

**务必牢记并理解这个转移方程，因为大部分背包问题的转移方程都是在此基础上推导出来的。**

### 实现

还有一点需要注意的是，很容易写出这样的 **错误核心代码**：

```c++
for (int i = 1; i <= n; i++)
  for (int l = 0; l <= W - w[i]; l++)
    // f[l] + v[i]   将第i个物品放入背包中
    // f[l + w[i]] 不将第i个物品放入背包中
    f[l + w[i]] = max(f[l] + v[i], f[l + w[i]]);
    // 由 f[i][l + w[i]] = max(max(f[i - 1][l + w[i]], f[i - 1][l] + w[i]), f[i][l + w[i]]); 简化而来
```

这段代码哪里错了呢？枚举顺序错了。

