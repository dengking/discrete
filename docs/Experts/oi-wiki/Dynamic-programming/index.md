# [oi-wiki-动态规划](https://oi-wiki.org/dp/)



## [动态规划部分简介](https://oi-wiki.org/dp/)



动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。由于动态规划并不是某种具体的算法，而是一种解决特定问题的方法，因此它会出现在各式各样的数据结构中，与之相关的题目种类也更为繁杂。

> NOTE:
>
> 一、"由于动态规划并不是某种具体的算法，而是一种解决特定问题的方法" 这段话如何理解？
>
> 它的意思是: 动态规划并不是解决某个具体的算法(比如排序算法等非常具体的算法)，它是一种解决问题的算法思想



在 OI 中，计数等非最优化问题的递推解法也常被不规范地称作 DP。

> NOTE:
>
> 一、DP解计数问题，在**LeetCode**上有很多这类问题。



## [动态规划基础](https://oi-wiki.org/dp/basic/) 



### 引入



#### [「IOI1994 」数字三角形](https://www.luogu.com.cn/problem/P1216)

> NOTE:
>
> 一、在 [CSDN【动态规划】线性DP](https://blog.csdn.net/weixin_42638946/article/details/117324704) 中将它归入了**线性DP**的范畴



### 动态规划原理

能用动态规划解决的问题，需要满足三个条件：最优子结构，无后效性和子问题重叠。

#### 无后效性

已经求解的子问题，不会再受到后续决策的影响。



#### 基本思路

对于一个能用动态规划解决的问题，一般采用如下思路解决：

1、将原问题划分为若干 **阶段**，每个阶段对应若干个子问题，提取这些子问题的特征（称之为 **状态**）；

2、寻找每一个状态的可能 **决策**，或者说是各状态间的相互转移方式（用数学的语言描述就是 **状态转移方程**）。

3、按顺序求解每一个阶段的问题。

如果用图论的思想理解，我们建立一个 [有向无环图](https://oi-wiki.org/graph/dag/)，每个状态对应图上一个节点，决策对应节点间的连边。这样问题就转变为了一个在 DAG 上寻找最长（短）路的问题（参见：[DAG 上的 DP](https://oi-wiki.org/dp/dag/)）。

> NOTE:
>
> 一、上面描述的就是**DP状态机**



### 最长公共子序列

设 $f(i,j)$ 表示只考虑 $A$ 的前 $i$ 个元素，$B$ 的前 $j$ 个元素时的最长公共子序列的长度，求这时的最长公共子序列的长度就是 **子问题**。$f(i,j)$ 就是我们所说的 **状态**，则 $f(n,m)$ 是最终要达到的状态，即为所求结果。

对于每个 $f(i,j)$，存在三种决策：如果 $A_i=B_j$，则可以将它接到公共子序列的末尾；另外两种决策分别是跳过 $A_i$ 或者 $B_j$。状态转移方程如下：


$$
f(i,j)=\begin{cases}f(i-1,j-1)+1&A_i=B_j\\\max(f(i-1,j),f(i,j-1))&A_i\ne B_j\end{cases}
$$


可参考 [SourceForge 的 LCS 交互网页](http://lcs-demo.sourceforge.net/) 来更好地理解 LCS 的实现过程。



### 最长不下降子序列

设 $f(i)$ 表示以 $A_i$ 为结尾的最长不下降子序列的长度，则所求为 $\max_{1 \leq i \leq n} f(i)$。

计算 $f(i)$ 时，尝试将 $A_i$ 接到其他的最长不下降子序列后面，以更新答案。于是可以写出这样的状态转移方程：$f(i)=\max_{1 \leq j < i, A_j \leq A_i} (f(j)+1)$。



$\color{red}\text{dalao}$



## 区间 DP

> NOTE:
>
> 一、非常好的总结

**区间类动态规划**是**线性动态规划**的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。

> NOTE:
>
> 一、divide&conquer&merge
>
> 二、关于线性动态规划，参见:
>
> 1、[CSDN【动态规划】线性DP](https://blog.csdn.net/weixin_42638946/article/details/117324704) 

令状态 $f(i,j)$ 表示将下标位置 $i$ 到 $j$ 的所有元素合并能获得的价值的最大值，那么 $f(i,j)=\max\{f(i,k)+f(k+1,j)+cost\}$，$cost$ 为将这两组元素合并起来的代价。

> NOTE:
>
> 一、matrix chain multiply是典型的区间DP



### 性质

区间 DP 有以下特点：

**合并**：即将两个或多个部分进行整合，当然也可以反过来；

**特征**：能将问题分解为能两两合并的形式；

**求解**：对整个问题设最优值，枚举**合并点**，将问题分解为左右两个部分，最后合并两个部分的**最优值**得到原问题的最优值。



### [「NOI1995」石子合并](https://loj.ac/problem/10147)

需要考虑不在环上，而在一条链上的情况。

令 $f(i,j)$ 表示将区间 $[i,j$ 内的所有石子合并到一起的最大得分。

写出 **状态转移方程**：$f(i,j)=\max\{f(i,k)+f(k+1,j)+\sum_{t=i}^{j} a_t \}~(i\le k<j)$

令 $sum_i$ 表示 $a$ 数组的前缀和，状态转移方程变形为 $f(i,j)=\max\{f(i,k)+f(k+1,j)+sum_j-sum_{i-1} \}$。

## [DAG 上的 DP](https://oi-wiki.org/dp/dag/)



## [树形 DP](https://oi-wiki.org/dp/tree/)



## [数位 DP](https://oi-wiki.org/dp/number/)