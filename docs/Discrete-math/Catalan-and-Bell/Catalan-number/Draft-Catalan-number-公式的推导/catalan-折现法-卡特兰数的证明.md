
# sina [折现法——卡特兰数证明](http://blog.sina.com.cn/s/blog_6917f47301010cno.html) 

1.饭后，姐姐洗碗，妹妹把姐姐洗过的碗**一个一个地**放进碗橱摞成一摞。一共有n个不同的碗，洗前也是摞成一摞的，也许因为小妹贪玩而使碗拿进碗橱不及时，姐姐则把洗过的碗摞在旁边，问：小妹摞起的碗有多少种可能的方式？

2.给定n个数，有多少种出栈序列？

3.一个有*n*个1和*n*个-1组成的字串，且前k个数的和均不小于0，那这种字串的总数为多少？

***SUMMARY*** : 上述问题最终都可以通过[bijection](https://en.wikipedia.org/wiki/Bijection)转换为同一类问题；

这三个问题具有相同的结构，三个问题是可以互相转化。将姐姐放碗看做入栈操作，将妹妹放碗看做出栈操作。则问题一变为问题二。将入栈操作记为1，出栈记为-1，问题2变为问题3。

问题的答案是一个著名的数列，**卡特兰数**。该问题的代数解法比较抽象，而运用到几何上，用图片来描述，却有让人恍然大悟的感觉。



事实上，可以认为问题是，任意两种操作，要求每种操作的总次数一样，且进行第k次**操作2**前必须先进行至少k次**操作1**。我们假设一个人在原点，**操作1**是此人沿右上角45°走一个单位（一个单位设为根号2，这样他第一次进行操作1就刚好走到（1,1）点），**操作2**是此人沿右下角45°走一个单位。第k次**操作2**前必须先进行至少k次**操作1**，就是说明所走出来的折线不能跨越x轴走到`y=-1`这条线上！在进行n次操作1和n此操作2后，此人必将到到达`（2n，0）`！若无跨越x轴的限制，折线的种数将为`C（2n，n）`，即在2n次操作中选出n次作为操作1的方法数。

 ![合法](https://img-blog.csdn.net/20171001220107091?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvelAxbkc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)  

现在只要减去跨越了x轴的情况数。对于任意跨越x轴的情况，必有将与`y=-1`相交。找出第一个与y=-1相交的点`k`，将`k`点以右的折线根据y=-1对称（即操作1与操作2互换了）。可以发现终点最终都会从`（2n，0）`对称到`（2n，-2）`。由于对称总是能进行的，且是可逆的。我们可以得出所有跨越了x轴的折线总数是与从（0,0）到（2n,-2）的折线总数。而后者的**操作2**比**操作1**要多0-（-2）=2次。即操作1为n-1,操作2为n+1。总数为`C（2n，n-1）`。

 ![不合法](https://img-blog.csdn.net/20171001220951823?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvelAxbkc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)  

 



***SUMMARY*** : 要充分理解上述证明方法中为什么要求：**所走出来的折线不能跨越x轴走到`y=-1`这条线上**，需要结合实际问题来进行考虑；首先明确的是，**要求所走出来的折线不能跨越x轴走到`y=-1`这条线上**其实是要求：第k次**操作2**前必须先进行至少k次**操作1**（即如何时刻，**操作1**执行的次数都大于等于**操作2**执行的次数）；这个限制是源于实际问题，比如：

问题：给定n个数，有多少种出栈序列？这个问题中，我们会将**入栈**抽象为**操作1**，将**出栈**抽象为**操作2**，显然，只有栈中有元素，才可能出栈，如果栈中没有元素，是不可能出栈的，所以在该问题中的一个明显的限制是：如何时刻，**操作1**执行的次数都大于等于**操作2**执行的次数

问题：括号匹配问题？在这个问题中，我们会将‘（’抽象为**操作1**，将‘）’抽象为**操作2**，显然，只有有了‘（’，才能够考虑匹配‘）’，所以在该问题中的一个明显的限制是：如何时刻，**操作1**执行的次数都大于等于**操作2**执行的次数；

类似的问题都需要满足上述的这种限制，这种限制最终在图像上表现出来就是：**所走出来的折线不能跨越x轴走到`y=-1`这条线上**。



# [【证明】卡特兰数（折线法）](https://blog.csdn.net/zP1nG/article/details/78149209)