{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u5173\u4e8e\u672c\u5de5\u7a0b # \u4f5c\u4e3a\u4e00\u4e2asoftware engineer\uff0c\u6211\u8d8a\u6765\u8d8a\u89c9\u5f97\uff1a Computer science is discrete. \u8fd9\u4e5f\u662f\u6211\u5199\u4f5c\u672c\u5de5\u7a0b\u7684\u52a8\u673a\u3002 \u672c\u5de5\u7a0b\u4e3b\u8981\u662f\u5173\u4e8ediscrete math\uff08\u79bb\u6563\u6570\u5b66\uff09\u7684\u77e5\u8bc6\uff0c\u662f\u6211\u4ee5\u4e00\u4e2a\u6709\u4e00\u5b9a\u5de5\u4f5c\u7ecf\u9a8c\u7684software engineer\u7684\u89c6\u89d2\u6765\u56de\u987e\u5728\u5927\u5b66\u4e8c\u5e74\u7ea7\u65f6\u5b66\u4e60\u8fd9\u95e8\u8bfe\u7a0b\uff0c\u4f7f\u7528\u7684\u6559\u6750\u662f\u975e\u5e38\u7ecf\u5178\u7684 Discrete Mathematics and Its Applications \u3002","title":"Home"},{"location":"#_1","text":"\u4f5c\u4e3a\u4e00\u4e2asoftware engineer\uff0c\u6211\u8d8a\u6765\u8d8a\u89c9\u5f97\uff1a Computer science is discrete. \u8fd9\u4e5f\u662f\u6211\u5199\u4f5c\u672c\u5de5\u7a0b\u7684\u52a8\u673a\u3002 \u672c\u5de5\u7a0b\u4e3b\u8981\u662f\u5173\u4e8ediscrete math\uff08\u79bb\u6563\u6570\u5b66\uff09\u7684\u77e5\u8bc6\uff0c\u662f\u6211\u4ee5\u4e00\u4e2a\u6709\u4e00\u5b9a\u5de5\u4f5c\u7ecf\u9a8c\u7684software engineer\u7684\u89c6\u89d2\u6765\u56de\u987e\u5728\u5927\u5b66\u4e8c\u5e74\u7ea7\u65f6\u5b66\u4e60\u8fd9\u95e8\u8bfe\u7a0b\uff0c\u4f7f\u7528\u7684\u6559\u6750\u662f\u975e\u5e38\u7ecf\u5178\u7684 Discrete Mathematics and Its Applications \u3002","title":"\u5173\u4e8e\u672c\u5de5\u7a0b"},{"location":"Discrete-math-and-computer-science/","text":"Discrete math and computer science # \u6b63\u5982\u5728\u7ef4\u57fa\u767e\u79d1 Discrete mathematics \u4e2d\u6240\u8ff0\uff1a Concepts and notations from discrete mathematics are useful in studying and describing objects and problems in branches of computer science , such as computer algorithms , programming languages , cryptography , automated theorem proving , and software development . Conversely, computer implementations are significant in applying ideas from discrete mathematics to real-world problems, such as in operations research . \u4f5c\u4e3a\u4e00\u4e2asoftware engineer\uff0c\u5bf9\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u611f\u53d7\u8d8a\u6765\u8d8a\u6df1\u523b\uff0c\u603b\u7684\u6765\u8bf4\uff0c\u6211\u8d8a\u6765\u8d8a\u89c9\u5f97\uff1a Computer science is discrete. Example of discrete objects # discrete structure \u3001 recurrence relation Computation on discrete objects # \u5728 Discrete math \u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u603b\u7ed3\u4e86discrete\u7684computable\u7684\u7279\u6027\uff0c\u90a3\u5982\u4f55\u6765\u8fdb\u884c\u5b9e\u73b0\u5462\uff1f","title":"Discrete-math-and-computer-science"},{"location":"Discrete-math-and-computer-science/#discrete-math-and-computer-science","text":"\u6b63\u5982\u5728\u7ef4\u57fa\u767e\u79d1 Discrete mathematics \u4e2d\u6240\u8ff0\uff1a Concepts and notations from discrete mathematics are useful in studying and describing objects and problems in branches of computer science , such as computer algorithms , programming languages , cryptography , automated theorem proving , and software development . Conversely, computer implementations are significant in applying ideas from discrete mathematics to real-world problems, such as in operations research . \u4f5c\u4e3a\u4e00\u4e2asoftware engineer\uff0c\u5bf9\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u611f\u53d7\u8d8a\u6765\u8d8a\u6df1\u523b\uff0c\u603b\u7684\u6765\u8bf4\uff0c\u6211\u8d8a\u6765\u8d8a\u89c9\u5f97\uff1a Computer science is discrete.","title":"Discrete math and computer science"},{"location":"Discrete-math-and-computer-science/#example-of-discrete-objects","text":"discrete structure \u3001 recurrence relation","title":"Example of discrete objects"},{"location":"Discrete-math-and-computer-science/#computation-on-discrete-objects","text":"\u5728 Discrete math \u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u603b\u7ed3\u4e86discrete\u7684computable\u7684\u7279\u6027\uff0c\u90a3\u5982\u4f55\u6765\u8fdb\u884c\u5b9e\u73b0\u5462\uff1f","title":"Computation on discrete objects"},{"location":"Thoughts-on-discrete/","text":"Discrete # \u53ea\u6709\u79bb\u6563\u624d\u80fd\u591f\u8ba1\u6570\uff0c\u8fd9\u5c31\u884d\u751f\u51fa\u4e86 Combinatorics \u3002 \u4ecestructure\u5230discrete structures\u3002 \u8ba1\u7b97\u673a\u79d1\u5b66\u662f\u79bb\u6563\u7684 # \u8ba1\u7b97\u601d\u7ef4 # \u54ea\u4e9b\u95ee\u9898\u662f\u53ef\u8ba1\u7b97\u7684\uff1f # \u5176\u5b9e\u662f\u5206\u6790\u7ed3\u6784\u3001formal\u3001\u89c4\u5f8b\uff0c\u800c\u8fd9\u4e9b\u90fd\u662f\u79bb\u6563\u7684\u3002 \u7ed3\u6784\u662f\u79bb\u6563\u7684 # \u7ed3\u6784\u5c31\u662f\u79bb\u6563\u7684\u3002\u5173\u7cfb\u662f\u5728\u79bb\u6563\u6570\u5b66\u8bfe\u7a0b\u4e2d\u8bb2\u8ff0\u7684\u3002\u5b83\u4eec\u90fd\u53ef\u4ee5\u4f7f\u7528graph\u6765\u8fdb\u884c\u8868\u793a\uff0c\u800cgraph\u662f\u5178\u578b\u7684\u79bb\u6563\u7ed3\u6784\u3002 \u51fd\u6570\u8c03\u7528\u8fc7\u7a0b\u662f\u79bb\u6563\u7684 # \u51fd\u6570\u7684\u8c03\u7528\u8fc7\u7a0b\u4e5f\u662f\u79bb\u6563\u7684\uff0c\u5c06\u8c03\u7528\u4e00\u4e2a\u51fd\u6570\u770b\u505a\u662f\u753b\u4e00\u4e2a\u70b9\u7684\u8bdd\u3002 \u5982\u4f55\u89e3\u51b3\u79bb\u6563\u95ee\u9898 # one-by-one \u79bb\u6563\u7684\u7ed3\u6784\u3001\u95ee\u9898\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u9012\u5f52\u3001iteration\u7684\u65b9\u5f0f\u5bf9\u5b83\u4eec\u8fdb\u884c\u89e3\u51b3\u3002 \u79bb\u6563 and \u9012\u5f52 # \u79bb\u6563\u7684\u7ed3\u6784\u53ef\u80fd\u5177\u5907\u9012\u5f52\u7279\u6027\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u8fdb\u884c\u9012\u5f52\u5b9a\u4e49\u4e86\uff0c\u5c31\u53ef\u4ee5\u4f7f\u7528structural recursion\u6765\u8fdb\u884c\u89e3\u51b3\u4e86\u3002 Discrete mathematics # Discrete Computational Structures # https://books.google.com/books/about/Discrete_Computational_Structures.html?id=KrLiBQAAQBAJ&source=kp_book_description https://www.elsevier.com/books/discrete-computational-structures/korfhage/978-0-12-420850-6 \u79bb\u6563\u7ed3\u6784\u6765\u63cf\u8ff0\u7269\u7406\u7ed3\u6784\u548c\u6570\u5b66\u516c\u5f0f # \u6570\u5b66\u4f7f\u7528relation\u6765\u63cf\u8ff0\u7ed3\u6784\uff0crelation\u662f\u4e00\u4e2a\u4e00\u4e2a\u7684ordered pair\uff0c recurrence relation \u5176\u5b9e\u6240\u63cf\u8ff0\u7684\u662f\u4e24\u4e2a\u5143\u7d20\u7684\u5173\u7cfb\uff0c\u8fd9\u79cd\u5173\u7cfb\u53ef\u80fd\u662f\u7ebf\u6027\u7684\u3002 recurrence relation \u662f\u975e\u5e38\u9002\u5408\u4e8e\u4f7f\u7528computer algorithm\u6765\u5b9e\u73b0\u7684\uff0c\u56e0\u4e3a\u5b83\u662f\u79bb\u6563\u7684\uff0c\u5b83\u662f\u53ef\u4ee5\u4f7f\u7528one-by-one\u6765\u8ba1\u7b97\u51fa\u6765\u7684\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u8bf4\u5b83\u5177\u6709\u79bb\u6563\u7ed3\u6784\u3002 \u5176\u5b9e\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u5df2\u7ecf\u4f53\u73b0\u4e86\u4f7f\u7528\u7ed3\u6784\u7684\u601d\u7ef4\u6765\u770b\u5f85\u6570\u5b66\u516c\u5f0f\u4e86\uff0c\u6211\u89c9\u5f97\u8ba1\u7b97\u673a\u79d1\u5b66\u662f\u9700\u8981\u8fd9\u79cd\u601d\u7ef4\u7684\uff0c\u53ea\u6709\u7ed3\u6784\u5316\u4e86\u4e4b\u540e\uff0c\u8ba1\u7b97\u673a\u624d\u80fd\u591f\u8fdb\u884c\u8ba1\u7b97\uff0c\u8fd9\u91cc\u6240\u8bf4\u7684\u7ed3\u6784\u5316\u5982\u679c\u5f80\u66f4\u9ad8\u5c42\u9762\u6765\u601d\u8003\u7684\u8bdd\uff0c\u5176\u5b9e\u662f\uff1a\u5f62\u5f0f\u5316\uff0c\u53ea\u6709\u5f62\u5f0f\u5316\u540e\u624d\u80fd\u591f\u4f7f\u7528\u8ba1\u7b97\u673a\u7b97\u6cd5\u6765\u8fdb\u884c\u8ba1\u7b97\uff0c\u6216\u8005\u66f4\u52a0\u901a\u4fd7\u5730\u6765\u8bf4\uff1a\u7ed3\u6784\u5316\u662f\u5f62\u5f0f\u5316\u7684\u4e00\u79cd\u3002 \u57fa\u672c\u4e0a\u76ee\u524d\u6211\u78b0\u5230\u7684\u8fd9\u4e9b\u79bb\u6563\u7684\u7ed3\u6784\uff0c\u90fd\u53ef\u4ee5\u4f7f\u7528one-by-one\u7684\u65b9\u5f0f\u6765\u8bbe\u8ba1\u7b97\u6cd5\u3002 recursive definition and discrete # \u4efb\u4f55recursive definition\uff0c\u90fd\u662f\u79bb\u6563\u7684\uff0c\u90fd\u53ef\u4ee5\u8fdb\u884c\u8ba1\u7b97 \u79bb\u6563\u548c\u56fe\u7075\u673a #","title":"Discrete"},{"location":"Thoughts-on-discrete/#discrete","text":"\u53ea\u6709\u79bb\u6563\u624d\u80fd\u591f\u8ba1\u6570\uff0c\u8fd9\u5c31\u884d\u751f\u51fa\u4e86 Combinatorics \u3002 \u4ecestructure\u5230discrete structures\u3002","title":"Discrete"},{"location":"Thoughts-on-discrete/#_1","text":"","title":"\u8ba1\u7b97\u673a\u79d1\u5b66\u662f\u79bb\u6563\u7684"},{"location":"Thoughts-on-discrete/#_2","text":"","title":"\u8ba1\u7b97\u601d\u7ef4"},{"location":"Thoughts-on-discrete/#_3","text":"\u5176\u5b9e\u662f\u5206\u6790\u7ed3\u6784\u3001formal\u3001\u89c4\u5f8b\uff0c\u800c\u8fd9\u4e9b\u90fd\u662f\u79bb\u6563\u7684\u3002","title":"\u54ea\u4e9b\u95ee\u9898\u662f\u53ef\u8ba1\u7b97\u7684\uff1f"},{"location":"Thoughts-on-discrete/#_4","text":"\u7ed3\u6784\u5c31\u662f\u79bb\u6563\u7684\u3002\u5173\u7cfb\u662f\u5728\u79bb\u6563\u6570\u5b66\u8bfe\u7a0b\u4e2d\u8bb2\u8ff0\u7684\u3002\u5b83\u4eec\u90fd\u53ef\u4ee5\u4f7f\u7528graph\u6765\u8fdb\u884c\u8868\u793a\uff0c\u800cgraph\u662f\u5178\u578b\u7684\u79bb\u6563\u7ed3\u6784\u3002","title":"\u7ed3\u6784\u662f\u79bb\u6563\u7684"},{"location":"Thoughts-on-discrete/#_5","text":"\u51fd\u6570\u7684\u8c03\u7528\u8fc7\u7a0b\u4e5f\u662f\u79bb\u6563\u7684\uff0c\u5c06\u8c03\u7528\u4e00\u4e2a\u51fd\u6570\u770b\u505a\u662f\u753b\u4e00\u4e2a\u70b9\u7684\u8bdd\u3002","title":"\u51fd\u6570\u8c03\u7528\u8fc7\u7a0b\u662f\u79bb\u6563\u7684"},{"location":"Thoughts-on-discrete/#_6","text":"one-by-one \u79bb\u6563\u7684\u7ed3\u6784\u3001\u95ee\u9898\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u9012\u5f52\u3001iteration\u7684\u65b9\u5f0f\u5bf9\u5b83\u4eec\u8fdb\u884c\u89e3\u51b3\u3002","title":"\u5982\u4f55\u89e3\u51b3\u79bb\u6563\u95ee\u9898"},{"location":"Thoughts-on-discrete/#and","text":"\u79bb\u6563\u7684\u7ed3\u6784\u53ef\u80fd\u5177\u5907\u9012\u5f52\u7279\u6027\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u8fdb\u884c\u9012\u5f52\u5b9a\u4e49\u4e86\uff0c\u5c31\u53ef\u4ee5\u4f7f\u7528structural recursion\u6765\u8fdb\u884c\u89e3\u51b3\u4e86\u3002","title":"\u79bb\u6563 and \u9012\u5f52"},{"location":"Thoughts-on-discrete/#discrete-mathematics","text":"","title":"Discrete mathematics"},{"location":"Thoughts-on-discrete/#discrete-computational-structures","text":"https://books.google.com/books/about/Discrete_Computational_Structures.html?id=KrLiBQAAQBAJ&source=kp_book_description https://www.elsevier.com/books/discrete-computational-structures/korfhage/978-0-12-420850-6","title":"Discrete Computational Structures"},{"location":"Thoughts-on-discrete/#_7","text":"\u6570\u5b66\u4f7f\u7528relation\u6765\u63cf\u8ff0\u7ed3\u6784\uff0crelation\u662f\u4e00\u4e2a\u4e00\u4e2a\u7684ordered pair\uff0c recurrence relation \u5176\u5b9e\u6240\u63cf\u8ff0\u7684\u662f\u4e24\u4e2a\u5143\u7d20\u7684\u5173\u7cfb\uff0c\u8fd9\u79cd\u5173\u7cfb\u53ef\u80fd\u662f\u7ebf\u6027\u7684\u3002 recurrence relation \u662f\u975e\u5e38\u9002\u5408\u4e8e\u4f7f\u7528computer algorithm\u6765\u5b9e\u73b0\u7684\uff0c\u56e0\u4e3a\u5b83\u662f\u79bb\u6563\u7684\uff0c\u5b83\u662f\u53ef\u4ee5\u4f7f\u7528one-by-one\u6765\u8ba1\u7b97\u51fa\u6765\u7684\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u8bf4\u5b83\u5177\u6709\u79bb\u6563\u7ed3\u6784\u3002 \u5176\u5b9e\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u5df2\u7ecf\u4f53\u73b0\u4e86\u4f7f\u7528\u7ed3\u6784\u7684\u601d\u7ef4\u6765\u770b\u5f85\u6570\u5b66\u516c\u5f0f\u4e86\uff0c\u6211\u89c9\u5f97\u8ba1\u7b97\u673a\u79d1\u5b66\u662f\u9700\u8981\u8fd9\u79cd\u601d\u7ef4\u7684\uff0c\u53ea\u6709\u7ed3\u6784\u5316\u4e86\u4e4b\u540e\uff0c\u8ba1\u7b97\u673a\u624d\u80fd\u591f\u8fdb\u884c\u8ba1\u7b97\uff0c\u8fd9\u91cc\u6240\u8bf4\u7684\u7ed3\u6784\u5316\u5982\u679c\u5f80\u66f4\u9ad8\u5c42\u9762\u6765\u601d\u8003\u7684\u8bdd\uff0c\u5176\u5b9e\u662f\uff1a\u5f62\u5f0f\u5316\uff0c\u53ea\u6709\u5f62\u5f0f\u5316\u540e\u624d\u80fd\u591f\u4f7f\u7528\u8ba1\u7b97\u673a\u7b97\u6cd5\u6765\u8fdb\u884c\u8ba1\u7b97\uff0c\u6216\u8005\u66f4\u52a0\u901a\u4fd7\u5730\u6765\u8bf4\uff1a\u7ed3\u6784\u5316\u662f\u5f62\u5f0f\u5316\u7684\u4e00\u79cd\u3002 \u57fa\u672c\u4e0a\u76ee\u524d\u6211\u78b0\u5230\u7684\u8fd9\u4e9b\u79bb\u6563\u7684\u7ed3\u6784\uff0c\u90fd\u53ef\u4ee5\u4f7f\u7528one-by-one\u7684\u65b9\u5f0f\u6765\u8bbe\u8ba1\u7b97\u6cd5\u3002","title":"\u79bb\u6563\u7ed3\u6784\u6765\u63cf\u8ff0\u7269\u7406\u7ed3\u6784\u548c\u6570\u5b66\u516c\u5f0f"},{"location":"Thoughts-on-discrete/#recursive-definition-and-discrete","text":"\u4efb\u4f55recursive definition\uff0c\u90fd\u662f\u79bb\u6563\u7684\uff0c\u90fd\u53ef\u4ee5\u8fdb\u884c\u8ba1\u7b97","title":"recursive definition and discrete"},{"location":"Thoughts-on-discrete/#_8","text":"","title":"\u79bb\u6563\u548c\u56fe\u7075\u673a"},{"location":"Book-Discrete-Mathematics-and-Its-Applications/","text":"\u5173\u4e8e\u672c\u7ae0 # \u672c\u7ae0\u662f\u6211\u9605\u8bfb Discrete Mathematics and Its Applications \u7684\u7b14\u8bb0\u3002","title":"Introduction"},{"location":"Book-Discrete-Mathematics-and-Its-Applications/#_1","text":"\u672c\u7ae0\u662f\u6211\u9605\u8bfb Discrete Mathematics and Its Applications \u7684\u7b14\u8bb0\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Book-Discrete-Mathematics-and-Its-Applications/Preface/","text":"Preface # Goals of a Discrete Mathematics Course # NOTE: \u539f\u4e66\u7684\u8fd9\u4e00\u6bb5\u6211\u89c9\u5f97\u603b\u7ed3\u5730\u975e\u5e38\u597d\uff0c\u89e3\u91ca\u4e86\u4e3a\u4ec0\u4e48software engineer\u9700\u8981\u5b66\u4e60discrete math\u3002 A discrete mathematics course has more than one purpose. Students should learn a particular set of mathematical facts and how to apply them; more importantly, such a course should teach students how to think logically and mathematically . To achieve these goals, this text stresses mathematical reasoning and the different ways problems are solved. Five important themes are interwoven in this text: mathematical reasoning , combinatorial analysis , discrete structures , algorithmic thinking , and applications and modeling . A successful discrete mathematics course should carefully blend\uff08\u6df7\u5408\uff09 and balance all five themes. Mathematical Reasoning # NOTE: \u6570\u5b66\u63a8\u7406 Students must understand mathematical reasoning in order to read, comprehend, and construct mathematical arguments. This text starts with a discussion of mathematical logic , which serves as the foundation for the subsequent discussions of methods of proof . Both the science and the art of constructing proofs are addressed. The technique of mathematical induction is stressed through many different types of examples of such proofs and a careful explanation of why mathematical induction is a valid proof technique. Combinatorial Analysis # An important problem-solving skill is the ability to count or enumerate objects. The discussion of enumeration in this book begins with the basic techniques of counting . The stress is on performing combinatorial analysis to solve counting problems and analyze algorithms, not on applying formulae\uff08\u516c\u5f0f\uff09. Discrete Structures # A course in discrete mathematics should teach students how to work with discrete structures , which are the abstract mathematical structures used to represent discrete objects and relationships between these objects. These discrete structures include sets , permutations , relations , graphs , trees , and finite-state machines . Algorithmic Thinking # Certain classes of problems are solved by the specification of an algorithm. After an algorithm has been described, a computer program can be constructed implementing it. The mathematical portions of this activity, which include the specification of the algorithm, the verification that it works properly, and the analysis of the computer memory and time required to perform it,are all covered in this text. Algorithms are described using both English and an easily understood form of pseudocode. Applications and Modeling # Discrete mathematics has applications to almost every conceivable area of study. There are many applications to computer science and data networking in this text, as well as applications to such diverse areas as chemistry, biology, linguistics, geography, business, and the Internet. These applications are natural and important uses of discrete mathematics and are not contrived. Modeling with discrete mathematics is an extremely important problem-solving skill, which students have the opportunity to develop by constructing their own models in some of the exercises.","title":"Preface"},{"location":"Book-Discrete-Mathematics-and-Its-Applications/Preface/#preface","text":"","title":"Preface"},{"location":"Book-Discrete-Mathematics-and-Its-Applications/Preface/#goals-of-a-discrete-mathematics-course","text":"NOTE: \u539f\u4e66\u7684\u8fd9\u4e00\u6bb5\u6211\u89c9\u5f97\u603b\u7ed3\u5730\u975e\u5e38\u597d\uff0c\u89e3\u91ca\u4e86\u4e3a\u4ec0\u4e48software engineer\u9700\u8981\u5b66\u4e60discrete math\u3002 A discrete mathematics course has more than one purpose. Students should learn a particular set of mathematical facts and how to apply them; more importantly, such a course should teach students how to think logically and mathematically . To achieve these goals, this text stresses mathematical reasoning and the different ways problems are solved. Five important themes are interwoven in this text: mathematical reasoning , combinatorial analysis , discrete structures , algorithmic thinking , and applications and modeling . A successful discrete mathematics course should carefully blend\uff08\u6df7\u5408\uff09 and balance all five themes.","title":"Goals of a Discrete Mathematics Course"},{"location":"Book-Discrete-Mathematics-and-Its-Applications/Preface/#mathematical-reasoning","text":"NOTE: \u6570\u5b66\u63a8\u7406 Students must understand mathematical reasoning in order to read, comprehend, and construct mathematical arguments. This text starts with a discussion of mathematical logic , which serves as the foundation for the subsequent discussions of methods of proof . Both the science and the art of constructing proofs are addressed. The technique of mathematical induction is stressed through many different types of examples of such proofs and a careful explanation of why mathematical induction is a valid proof technique.","title":"Mathematical Reasoning"},{"location":"Book-Discrete-Mathematics-and-Its-Applications/Preface/#combinatorial-analysis","text":"An important problem-solving skill is the ability to count or enumerate objects. The discussion of enumeration in this book begins with the basic techniques of counting . The stress is on performing combinatorial analysis to solve counting problems and analyze algorithms, not on applying formulae\uff08\u516c\u5f0f\uff09.","title":"Combinatorial Analysis"},{"location":"Book-Discrete-Mathematics-and-Its-Applications/Preface/#discrete-structures","text":"A course in discrete mathematics should teach students how to work with discrete structures , which are the abstract mathematical structures used to represent discrete objects and relationships between these objects. These discrete structures include sets , permutations , relations , graphs , trees , and finite-state machines .","title":"Discrete Structures"},{"location":"Book-Discrete-Mathematics-and-Its-Applications/Preface/#algorithmic-thinking","text":"Certain classes of problems are solved by the specification of an algorithm. After an algorithm has been described, a computer program can be constructed implementing it. The mathematical portions of this activity, which include the specification of the algorithm, the verification that it works properly, and the analysis of the computer memory and time required to perform it,are all covered in this text. Algorithms are described using both English and an easily understood form of pseudocode.","title":"Algorithmic Thinking"},{"location":"Book-Discrete-Mathematics-and-Its-Applications/Preface/#applications-and-modeling","text":"Discrete mathematics has applications to almost every conceivable area of study. There are many applications to computer science and data networking in this text, as well as applications to such diverse areas as chemistry, biology, linguistics, geography, business, and the Internet. These applications are natural and important uses of discrete mathematics and are not contrived. Modeling with discrete mathematics is an extremely important problem-solving skill, which students have the opportunity to develop by constructing their own models in some of the exercises.","title":"Applications and Modeling"},{"location":"Book-Discrete-Mathematics-and-Its-Applications/Chapter-2-Basic-Structures/","text":"2 Basic Structures: Sets, Functions, Sequences, Sums, and Matrices # Much of discrete mathematics is devoted to the study of discrete structures, used to represent discrete objects . Many important discrete structures are built using sets, which are collections of objects. Among the discrete structures built from sets are combinations ,unordered collections of objects used extensively in counting; relations , sets of ordered pairs that represent relationships between objects; graphs , sets of vertices and edges that connect vertices; and finite state machines, used to model computing machines. These are some of the topics we will study in later chapters.","title":"Chapter-2-Basic-Structures"},{"location":"Book-Discrete-Mathematics-and-Its-Applications/Chapter-2-Basic-Structures/#2-basic-structures-sets-functions-sequences-sums-and-matrices","text":"Much of discrete mathematics is devoted to the study of discrete structures, used to represent discrete objects . Many important discrete structures are built using sets, which are collections of objects. Among the discrete structures built from sets are combinations ,unordered collections of objects used extensively in counting; relations , sets of ordered pairs that represent relationships between objects; graphs , sets of vertices and edges that connect vertices; and finite state machines, used to model computing machines. These are some of the topics we will study in later chapters.","title":"2 Basic Structures: Sets, Functions, Sequences, Sums, and Matrices"},{"location":"Book-Discrete-Mathematics-and-Its-Applications/Chapter-5-Induction-and-Recursion/","text":"5 Induction and Recursion # Proofs using mathematical induction have two parts. First, they show that the statement holds for the positive integer 1. Second, they show that if the statement holds for a positive integer then it must also hold for the next larger integer. Mathematical induction is based on the rule of inference that tells us that if P(1) and \u2200k(P(k) \u2192 P(k + 1)) are true for the domain of positive integers,then \u2200nP(n) is true. Mathematical induction can be used to prove a tremendous variety of results. Understanding how to read and construct proofs by mathematical induction is a key goal of learning discrete mathematics. In Chapter 2 we explicitly defined sets and functions. That is, we described sets by listing their elements or by giving some property that characterizes these elements. We gave formulae for the values of functions. There is another important way to define such objects, based on mathematical induction. To define functions, some initial terms are specified, and a rule is given for finding subsequent values from values already known. (We briefly touched on this sort of definition in Chapter 2 when we showed how sequences can be defined using recurrence relations.)Sets can be defined by listing some of the i r elements and giving rules for constructing elements from those already known to be in the set. Such definitions,called recursive definitions, are used throughout discrete mathematics and computer science. Once we have defined a set recursively, we can use a proof method called structural induction to prove results about this set.","title":"Chapter-5-Induction-and-Recursion"},{"location":"Book-Discrete-Mathematics-and-Its-Applications/Chapter-5-Induction-and-Recursion/#5-induction-and-recursion","text":"Proofs using mathematical induction have two parts. First, they show that the statement holds for the positive integer 1. Second, they show that if the statement holds for a positive integer then it must also hold for the next larger integer. Mathematical induction is based on the rule of inference that tells us that if P(1) and \u2200k(P(k) \u2192 P(k + 1)) are true for the domain of positive integers,then \u2200nP(n) is true. Mathematical induction can be used to prove a tremendous variety of results. Understanding how to read and construct proofs by mathematical induction is a key goal of learning discrete mathematics. In Chapter 2 we explicitly defined sets and functions. That is, we described sets by listing their elements or by giving some property that characterizes these elements. We gave formulae for the values of functions. There is another important way to define such objects, based on mathematical induction. To define functions, some initial terms are specified, and a rule is given for finding subsequent values from values already known. (We briefly touched on this sort of definition in Chapter 2 when we showed how sequences can be defined using recurrence relations.)Sets can be defined by listing some of the i r elements and giving rules for constructing elements from those already known to be in the set. Such definitions,called recursive definitions, are used throughout discrete mathematics and computer science. Once we have defined a set recursively, we can use a proof method called structural induction to prove results about this set.","title":"5 Induction and Recursion"},{"location":"Book-Discrete-Mathematics-and-Its-Applications/Chapter-6-Counting/","text":"6 Counting # Combinatorics, the study of arrangements of objects, is an important part of discrete mathematics. This subject was studied as long ago as the seventeenth century, when combinatorial questions arose in the study of gambling games. Enumeration, the counting of objects with certain properties, is an important part of combinatorics. We must count objects to solve many different types of problems. For instance, counting is used to determine the complexity of algorithms. Counting is also required to determine whether there are enough telephone numbers or Internet protocol addresses to meet demand. Recently,it has played a key role in mathematical biology, especially in sequencing DNA. Furthermore, counting techniques are used extensively when probabilities of events are computed. 6.1 The Basics of Counting # Tree Diagrams # Counting problems can be solved using tree diagrams. A tree consists of a root, a number of branches leaving the root, and possible additional branches leaving the endpoints of other branches. (We will study trees in detail in Chapter 11.)To use trees in counting, we use a branch to represent each possible choice. We represent the possible outcomes by the leaves , which are the endpoints of branches not having other branches starting at them. Note that when a tree diagram is used to solve a counting problem, the number of choices of which branch to follow to reach a leaf can vary (see Example 21, for example). EXAMPLE 22 A play off between two teams consists of at most five games. The first team that wins three games wins the playoff. In how many different ways can the playoff occur? Solution : The tree diagram in Figure 3 displays all the ways the playoff can proceed, with the winner of each game shown. We see that there are 20 different ways for the playoff to occur.","title":"Chapter-6-Counting"},{"location":"Book-Discrete-Mathematics-and-Its-Applications/Chapter-6-Counting/#6-counting","text":"Combinatorics, the study of arrangements of objects, is an important part of discrete mathematics. This subject was studied as long ago as the seventeenth century, when combinatorial questions arose in the study of gambling games. Enumeration, the counting of objects with certain properties, is an important part of combinatorics. We must count objects to solve many different types of problems. For instance, counting is used to determine the complexity of algorithms. Counting is also required to determine whether there are enough telephone numbers or Internet protocol addresses to meet demand. Recently,it has played a key role in mathematical biology, especially in sequencing DNA. Furthermore, counting techniques are used extensively when probabilities of events are computed.","title":"6 Counting"},{"location":"Book-Discrete-Mathematics-and-Its-Applications/Chapter-6-Counting/#61-the-basics-of-counting","text":"","title":"6.1 The Basics of Counting"},{"location":"Book-Discrete-Mathematics-and-Its-Applications/Chapter-6-Counting/#tree-diagrams","text":"Counting problems can be solved using tree diagrams. A tree consists of a root, a number of branches leaving the root, and possible additional branches leaving the endpoints of other branches. (We will study trees in detail in Chapter 11.)To use trees in counting, we use a branch to represent each possible choice. We represent the possible outcomes by the leaves , which are the endpoints of branches not having other branches starting at them. Note that when a tree diagram is used to solve a counting problem, the number of choices of which branch to follow to reach a leaf can vary (see Example 21, for example). EXAMPLE 22 A play off between two teams consists of at most five games. The first team that wins three games wins the playoff. In how many different ways can the playoff occur? Solution : The tree diagram in Figure 3 displays all the ways the playoff can proceed, with the winner of each game shown. We see that there are 20 different ways for the playoff to occur.","title":"Tree Diagrams"},{"location":"Book-Discrete-Mathematics-and-Its-Applications/Chpater-9-Relations/","text":"9 Relations # Relationships between elements of sets are represented using the structure called a relation , which is just as sub set of the Cartesian product of the sets. Relations can be used to solve problems such as determining which pairs of cities are linked by airline flights in a network, finding a viable order for the different phases of a complicated project, or producing a useful way to store information in computer databases.","title":"Chpater-9-Relations"},{"location":"Book-Discrete-Mathematics-and-Its-Applications/Chpater-9-Relations/#9-relations","text":"Relationships between elements of sets are represented using the structure called a relation , which is just as sub set of the Cartesian product of the sets. Relations can be used to solve problems such as determining which pairs of cities are linked by airline flights in a network, finding a viable order for the different phases of a complicated project, or producing a useful way to store information in computer databases.","title":"9 Relations"},{"location":"Guide/","text":"\u5173\u4e8e\u672c\u7ae0 # \u672c\u7ae0\u662f\u5bf9discrete math\u4e2d\u7684\u4e00\u4e9b\u5185\u5bb9\u7684\u8fdb\u884c\u4e13\u9898\u6027\u5730\u603b\u7ed3\u3002","title":"Introduction"},{"location":"Guide/#_1","text":"\u672c\u7ae0\u662f\u5bf9discrete math\u4e2d\u7684\u4e00\u4e9b\u5185\u5bb9\u7684\u8fdb\u884c\u4e13\u9898\u6027\u5730\u603b\u7ed3\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Guide/Combinatorics/","text":"\u5173\u4e8e\u672c\u7ae0 # \u201ccombinatorics\u201d\u5373\u201c\u7ec4\u5408\u5b66\u201d\uff0c\u662fdiscrete math\u7684\u4e00\u4e2a\u91cd\u8981\u5206\u652f\u3002\u5728 Discrete Mathematics and Its Applications \u7684 Preface \u4e2d\u63d0\u53ca\u7684\u201cCombinatorial Analysis\u201d\u5176\u5b9e\u5c31\u662f\u8fd0\u7528combinatorics\u4e2d\u7684\u7406\u8bba\u4e0e\u65b9\u6cd5\u3002\u5728 Discrete Mathematics and Its Applications \u7684\u201cCombinatorial Analysis\u201d\u5c31\u5c5e\u4e8ecombinatorics\u3002 Discrete Mathematics and Its Applications \u7684 chapter 6 \u4e2d\u5bf9\u5b83\u8fdb\u884c\u4e86\u63cf\u8ff0\u3002","title":"Introduction"},{"location":"Guide/Combinatorics/#_1","text":"\u201ccombinatorics\u201d\u5373\u201c\u7ec4\u5408\u5b66\u201d\uff0c\u662fdiscrete math\u7684\u4e00\u4e2a\u91cd\u8981\u5206\u652f\u3002\u5728 Discrete Mathematics and Its Applications \u7684 Preface \u4e2d\u63d0\u53ca\u7684\u201cCombinatorial Analysis\u201d\u5176\u5b9e\u5c31\u662f\u8fd0\u7528combinatorics\u4e2d\u7684\u7406\u8bba\u4e0e\u65b9\u6cd5\u3002\u5728 Discrete Mathematics and Its Applications \u7684\u201cCombinatorial Analysis\u201d\u5c31\u5c5e\u4e8ecombinatorics\u3002 Discrete Mathematics and Its Applications \u7684 chapter 6 \u4e2d\u5bf9\u5b83\u8fdb\u884c\u4e86\u63cf\u8ff0\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Guide/Combinatorics/Combinatorics/","text":"Combinatorics # Combinatorics is an area of mathematics primarily concerned with counting\uff08\u8ba1\u6570\uff09, both as a means and an end in obtaining results, and certain properties of finite structures \uff08\u6709\u9650\u7ed3\u6784\uff09. It is closely related to many other areas of mathematics and has many applications ranging from logic to statistical physics , from evolutionary biology to computer science , etc. To fully understand the scope of combinatorics requires a great deal of further amplification\uff08\u653e\u5927\uff09, the details of which are not universally agreed upon.[ 1] According to H.J. Ryser , a definition of the subject is difficult because it crosses so many mathematical subdivisions.[ 2] Insofar as an area can be described by the types of problems it addresses, combinatorics is involved with the enumeration (counting) of specified structures, sometimes referred to as arrangements or configurations in a very general sense, associated with finite systems, the existence of such structures that satisfy certain given criteria, the construction of these structures, perhaps in many ways, and optimization , finding the \"best\" structure or solution among several possibilities, be it the \"largest\", \"smallest\" or satisfying some other optimality criterion. Leon Mirsky has said: \"combinatorics is a range of linked studies which have something in common and yet diverge widely in their objectives, their methods, and the degree of coherence they have attained.\"[ 3] One way to define combinatorics is, perhaps, to describe its subdivisions with their problems and techniques. This is the approach that is used below. However, there are also purely historical reasons for including or not including some topics under the combinatorics umbrella.[ 4] Although primarily concerned with finite systems, some combinatorial questions and techniques can be extended to an infinite (specifically, countable ) but discrete setting. Combinatorics is well known for the breadth of the problems it tackles. Combinatorial problems arise in many areas of pure mathematics , notably in algebra , probability theory , topology , and geometry ,[ 5] as well as in its many application areas. Many combinatorial questions have historically been considered in isolation, giving an ad hoc solution to a problem arising in some mathematical context. In the later twentieth century, however, powerful and general theoretical methods were developed, making combinatorics into an independent branch of mathematics in its own right.[ 6] One of the oldest and most accessible parts of combinatorics is graph theory , which by itself has numerous natural connections to other areas. Combinatorics is used frequently in computer science to obtain formulas and estimates in the analysis of algorithms . A mathematician who studies combinatorics is called a combinatorialist . Approaches and subfields of combinatorics # Enumerative combinatorics # Main article: Enumerative combinatorics Enumerative combinatorics is the most classical area of combinatorics and concentrates on counting the number of certain combinatorial objects . Although counting the number of elements in a set is a rather broad mathematical problem , many of the problems that arise in applications have a relatively simple combinatorial description. Fibonacci numbers is the basic example of a problem in enumerative combinatorics. The twelvefold way provides a unified framework for counting permutations , combinations and partitions . Five binary trees on three vertices , an example of Catalan numbers . Analytic combinatorics # Main article: Analytic combinatorics Analytic combinatorics concerns the enumeration of combinatorial structures using tools from complex analysis and probability theory . In contrast with enumerative combinatorics, which uses explicit combinatorial formulae and generating functions to describe the results, analytic combinatorics aims at obtaining asymptotic formulae . Partition theory # Main article: Partition theory Partition theory studies various enumeration and asymptotic problems related to integer partitions , and is closely related to q-series , special functions and orthogonal polynomials . Originally a part of number theory and analysis , it is now considered a part of combinatorics or an independent field. It incorporates the bijective approach and various tools in analysis and analytic number theory and has connections with statistical mechanics . Related fields # Combinatorial optimization # Combinatorial optimization is the study of optimization on discrete and combinatorial objects. It started as a part of combinatorics and graph theory, but is now viewed as a branch of applied mathematics and computer science, related to operations research , algorithm theory and computational complexity theory .","title":"Combinatorics"},{"location":"Guide/Combinatorics/Combinatorics/#combinatorics","text":"Combinatorics is an area of mathematics primarily concerned with counting\uff08\u8ba1\u6570\uff09, both as a means and an end in obtaining results, and certain properties of finite structures \uff08\u6709\u9650\u7ed3\u6784\uff09. It is closely related to many other areas of mathematics and has many applications ranging from logic to statistical physics , from evolutionary biology to computer science , etc. To fully understand the scope of combinatorics requires a great deal of further amplification\uff08\u653e\u5927\uff09, the details of which are not universally agreed upon.[ 1] According to H.J. Ryser , a definition of the subject is difficult because it crosses so many mathematical subdivisions.[ 2] Insofar as an area can be described by the types of problems it addresses, combinatorics is involved with the enumeration (counting) of specified structures, sometimes referred to as arrangements or configurations in a very general sense, associated with finite systems, the existence of such structures that satisfy certain given criteria, the construction of these structures, perhaps in many ways, and optimization , finding the \"best\" structure or solution among several possibilities, be it the \"largest\", \"smallest\" or satisfying some other optimality criterion. Leon Mirsky has said: \"combinatorics is a range of linked studies which have something in common and yet diverge widely in their objectives, their methods, and the degree of coherence they have attained.\"[ 3] One way to define combinatorics is, perhaps, to describe its subdivisions with their problems and techniques. This is the approach that is used below. However, there are also purely historical reasons for including or not including some topics under the combinatorics umbrella.[ 4] Although primarily concerned with finite systems, some combinatorial questions and techniques can be extended to an infinite (specifically, countable ) but discrete setting. Combinatorics is well known for the breadth of the problems it tackles. Combinatorial problems arise in many areas of pure mathematics , notably in algebra , probability theory , topology , and geometry ,[ 5] as well as in its many application areas. Many combinatorial questions have historically been considered in isolation, giving an ad hoc solution to a problem arising in some mathematical context. In the later twentieth century, however, powerful and general theoretical methods were developed, making combinatorics into an independent branch of mathematics in its own right.[ 6] One of the oldest and most accessible parts of combinatorics is graph theory , which by itself has numerous natural connections to other areas. Combinatorics is used frequently in computer science to obtain formulas and estimates in the analysis of algorithms . A mathematician who studies combinatorics is called a combinatorialist .","title":"Combinatorics"},{"location":"Guide/Combinatorics/Combinatorics/#approaches-and-subfields-of-combinatorics","text":"","title":"Approaches and subfields of combinatorics"},{"location":"Guide/Combinatorics/Combinatorics/#enumerative-combinatorics","text":"Main article: Enumerative combinatorics Enumerative combinatorics is the most classical area of combinatorics and concentrates on counting the number of certain combinatorial objects . Although counting the number of elements in a set is a rather broad mathematical problem , many of the problems that arise in applications have a relatively simple combinatorial description. Fibonacci numbers is the basic example of a problem in enumerative combinatorics. The twelvefold way provides a unified framework for counting permutations , combinations and partitions . Five binary trees on three vertices , an example of Catalan numbers .","title":"Enumerative combinatorics"},{"location":"Guide/Combinatorics/Combinatorics/#analytic-combinatorics","text":"Main article: Analytic combinatorics Analytic combinatorics concerns the enumeration of combinatorial structures using tools from complex analysis and probability theory . In contrast with enumerative combinatorics, which uses explicit combinatorial formulae and generating functions to describe the results, analytic combinatorics aims at obtaining asymptotic formulae .","title":"Analytic combinatorics"},{"location":"Guide/Combinatorics/Combinatorics/#partition-theory","text":"Main article: Partition theory Partition theory studies various enumeration and asymptotic problems related to integer partitions , and is closely related to q-series , special functions and orthogonal polynomials . Originally a part of number theory and analysis , it is now considered a part of combinatorics or an independent field. It incorporates the bijective approach and various tools in analysis and analytic number theory and has connections with statistical mechanics .","title":"Partition theory"},{"location":"Guide/Combinatorics/Combinatorics/#related-fields","text":"","title":"Related fields"},{"location":"Guide/Combinatorics/Combinatorics/#combinatorial-optimization","text":"Combinatorial optimization is the study of optimization on discrete and combinatorial objects. It started as a part of combinatorics and graph theory, but is now viewed as a branch of applied mathematics and computer science, related to operations research , algorithm theory and computational complexity theory .","title":"Combinatorial optimization"},{"location":"Guide/Combinatorics/Enumerative-combinatorics/Enumerative-combinatorics/","text":"Enumerative combinatorics # Enumerative combinatorics is an area of combinatorics that deals with the number of ways that certain patterns can be formed. Two examples of this type of problem are counting combinations and counting permutations . More generally, given an infinite collection of finite sets S_i S_i indexed by the natural numbers , enumerative combinatorics seeks to describe a counting function which counts the number of objects in S_n S_n for each n . Although counting the number of elements in a set is a rather broad mathematical problem , many of the problems that arise in applications have a relatively simple combinatorial description. The twelvefold way provides a unified framework for counting permutations , combinations and partitions . SUMMARY : \u5bf9\u4e8eprogram\u800c\u8a00\uff0c Enumeration \u6bd4 counting \u66f4\u52a0\u91cd\u8981\uff0c\u5c24\u5176\u662f\u5728optimization\u95ee\u9898\u4e2d\uff0c\u53ea\u6709\u7ecf\u8fc7 Enumeration \u3001\u6bd4\u8f83\u624d\u80fd\u591f\u5f97\u5230\u6700\u4f18\u7684\u89e3\uff1b counting \u5f80\u5f80\u662f\u5728\u8fdb\u884ccomplexity\u5206\u6790\u7684\u65f6\u5019\u9700\u8981\u4f7f\u7528\u7684\uff1b The simplest such functions are closed formulas , which can be expressed as a composition of elementary functions such as factorials , powers, and so on. For instance, as shown below, the number of different possible orderings of a deck of n cards is f ( n ) = n !. The problem of finding a closed formula is known as algebraic enumeration , and frequently involves deriving a recurrence relation or generating function and using this to arrive at the desired closed form. Often, a complicated closed formula yields little insight into the behavior of the counting function as the number of counted objects grows. In these cases, a simple asymptotic approximation may be preferable. A function $ g(n) $ is an asymptotic approximation to $ f(n) $ if $ f(n)/g(n)\\rightarrow 1 $ as $ n\\rightarrow \\infty $. In this case, we write $ f(n)\\sim g(n).\\, $ Generating functions # Generating functions are used to describe families of combinatorial objects. Let $ {\\mathcal {F}} $ denote the family of objects and let F ( x ) be its generating function. Then $ F(x)=\\sum {n=0}^{\\infty }f {n}x^{n} $ where $ f_{n} $ denotes the number of combinatorial objects of size n . The number of combinatorial objects of size n is therefore given by the coefficient of $ x^{n} $. Some common operation on families of combinatorial objects and its effect on the generating function will now be developed. The exponential generating function is also sometimes used. In this case it would have the form $ F(x)=\\sum {n=0}^{\\infty }f {n}{\\frac {x^{n}}{n!}} $ Once determined, the generating function yields the information given by the previous approaches. In addition, the various natural operations on generating functions such as addition, multiplication, differentiation, etc., have a combinatorial significance; this allows one to extend results from one combinatorial problem in order to solve others. Union # Given two combinatorial families, $ {\\mathcal {F}} $ and $ {\\mathcal {G}} $ with generating functions F ( x ) and G ( x ) respectively, the disjoint union of the two families ($ {\\mathcal {F}}\\cup {\\mathcal {G}} $) has generating function F ( x ) + G ( x ). Pairs # For two combinatorial families as above the Cartesian product (pair) of the two families ($ {\\mathcal {F}}\\times {\\mathcal {G}} $) has generating function F ( x ) G ( x ). Sequences # A sequence generalizes the idea of the pair as defined above. Sequences are arbitrary Cartesian products of a combinatorial object with itself. Formally: $ {\\mbox{Seq}}({\\mathcal {F}})=\\epsilon \\cup {\\mathcal {F}} \\cup {\\mathcal {F}}\\times {\\mathcal {F}} \\cup {\\mathcal {F}}\\times {\\mathcal {F}}\\times {\\mathcal {F}} \\cup \\cdots $ To put the above in words: An empty sequence or a sequence of one element or a sequence of two elements or a sequence of three elements, etc. The generating function would be: $ 1+F(x)+[F(x)] {2}+[F(x)] {3}+\\cdots ={\\frac {1}{1-F(x)}} $ Combinatorial structures # The above operations can now be used to enumerate common combinatorial objects including trees (binary and plane), Dyck paths and cycles. A combinatorial structure is composed of atoms. For example, with trees the atoms would be the nodes. The atoms which compose the object can either be labeled or unlabeled. Unlabeled atoms are indistinguishable from each other, while labelled atoms are distinct. Therefore, for a combinatorial object consisting of labeled atoms a new object can be formed by simply swapping two or more atoms. Binary and plane trees # Binary and plane trees are examples of an unlabeled combinatorial structure. Trees consist of nodes linked by edges in such a way that there are no cycles. There is generally a node called the root, which has no parent node. In Plane trees each node can have an arbitrary number of children. In binary trees, a special case of plane trees, each node can have either two or no children. Let $ {\\mathcal {P}} $ denote the family of all plane trees. Then this family can be recursively defined as follows: $ {\\mathcal {P}}={\\bullet }\\times {\\mbox{Seq}}({\\mathcal {P}}) $ In this case $ {\\bullet } $ represents the family of objects consisting of one node. This has generating function x . Let P ( x ) denote the generating function $ {\\mathcal {P}} $. Putting the above description in words: A plane tree consists of a node to which is attached an arbitrary number of subtrees, each of which is also a plane tree. Using the operation on families of combinatorial structures developed earlier this translates to a recursive generating function: $ P(x)=x{\\frac {1}{1-P(x)}} $ After solving for P ( x ): $ P(x)={\\frac {1-{\\sqrt {1-4x}}}{2}} $ An explicit formula for the number of plane trees of size n can now be determined by extracting the coefficient of x^n x^n . $ {\\begin{aligned}p_{n}&=[x {n}]P(x)=[x {n}]{\\frac {1-{\\sqrt {1-4x}}}{2}}\\[6pt]&=[x^{n}]{\\frac {1}{2}}-[x^{n}]{\\frac {1}{2}}{\\sqrt {1-4x}}\\[6pt]&=-{\\frac {1}{2}}[x^{n}]\\sum _{k=0}^{\\infty }{{\\frac {1}{2}} \\choose k}(-4x)^{k}\\[6pt]&=-{\\frac {1}{2}}{{\\frac {1}{2}} \\choose n}(-4)^{n}\\[6pt]&={\\frac {1}{n}}{2n-2 \\choose n-1}\\end{aligned}} $ Note: The notation [ x**n ] f ( x ) refers to the coefficient of x**n in f ( x ). The series expansion of the square root is based on Newton's generalization of the binomial theorem . To get from the fourth to fifth line manipulations using the generalized binomial coefficient is needed. The expression on the last line is equal to the ( n \u2212 1)th Catalan number . Therefore p**n = c**n \u22121.","title":"Enumerative-combinatorics"},{"location":"Guide/Combinatorics/Enumerative-combinatorics/Enumerative-combinatorics/#enumerative-combinatorics","text":"Enumerative combinatorics is an area of combinatorics that deals with the number of ways that certain patterns can be formed. Two examples of this type of problem are counting combinations and counting permutations . More generally, given an infinite collection of finite sets S_i S_i indexed by the natural numbers , enumerative combinatorics seeks to describe a counting function which counts the number of objects in S_n S_n for each n . Although counting the number of elements in a set is a rather broad mathematical problem , many of the problems that arise in applications have a relatively simple combinatorial description. The twelvefold way provides a unified framework for counting permutations , combinations and partitions . SUMMARY : \u5bf9\u4e8eprogram\u800c\u8a00\uff0c Enumeration \u6bd4 counting \u66f4\u52a0\u91cd\u8981\uff0c\u5c24\u5176\u662f\u5728optimization\u95ee\u9898\u4e2d\uff0c\u53ea\u6709\u7ecf\u8fc7 Enumeration \u3001\u6bd4\u8f83\u624d\u80fd\u591f\u5f97\u5230\u6700\u4f18\u7684\u89e3\uff1b counting \u5f80\u5f80\u662f\u5728\u8fdb\u884ccomplexity\u5206\u6790\u7684\u65f6\u5019\u9700\u8981\u4f7f\u7528\u7684\uff1b The simplest such functions are closed formulas , which can be expressed as a composition of elementary functions such as factorials , powers, and so on. For instance, as shown below, the number of different possible orderings of a deck of n cards is f ( n ) = n !. The problem of finding a closed formula is known as algebraic enumeration , and frequently involves deriving a recurrence relation or generating function and using this to arrive at the desired closed form. Often, a complicated closed formula yields little insight into the behavior of the counting function as the number of counted objects grows. In these cases, a simple asymptotic approximation may be preferable. A function $ g(n) $ is an asymptotic approximation to $ f(n) $ if $ f(n)/g(n)\\rightarrow 1 $ as $ n\\rightarrow \\infty $. In this case, we write $ f(n)\\sim g(n).\\, $","title":"Enumerative combinatorics"},{"location":"Guide/Combinatorics/Enumerative-combinatorics/Enumerative-combinatorics/#generating-functions","text":"Generating functions are used to describe families of combinatorial objects. Let $ {\\mathcal {F}} $ denote the family of objects and let F ( x ) be its generating function. Then $ F(x)=\\sum {n=0}^{\\infty }f {n}x^{n} $ where $ f_{n} $ denotes the number of combinatorial objects of size n . The number of combinatorial objects of size n is therefore given by the coefficient of $ x^{n} $. Some common operation on families of combinatorial objects and its effect on the generating function will now be developed. The exponential generating function is also sometimes used. In this case it would have the form $ F(x)=\\sum {n=0}^{\\infty }f {n}{\\frac {x^{n}}{n!}} $ Once determined, the generating function yields the information given by the previous approaches. In addition, the various natural operations on generating functions such as addition, multiplication, differentiation, etc., have a combinatorial significance; this allows one to extend results from one combinatorial problem in order to solve others.","title":"Generating functions"},{"location":"Guide/Combinatorics/Enumerative-combinatorics/Enumerative-combinatorics/#union","text":"Given two combinatorial families, $ {\\mathcal {F}} $ and $ {\\mathcal {G}} $ with generating functions F ( x ) and G ( x ) respectively, the disjoint union of the two families ($ {\\mathcal {F}}\\cup {\\mathcal {G}} $) has generating function F ( x ) + G ( x ).","title":"Union"},{"location":"Guide/Combinatorics/Enumerative-combinatorics/Enumerative-combinatorics/#pairs","text":"For two combinatorial families as above the Cartesian product (pair) of the two families ($ {\\mathcal {F}}\\times {\\mathcal {G}} $) has generating function F ( x ) G ( x ).","title":"Pairs"},{"location":"Guide/Combinatorics/Enumerative-combinatorics/Enumerative-combinatorics/#sequences","text":"A sequence generalizes the idea of the pair as defined above. Sequences are arbitrary Cartesian products of a combinatorial object with itself. Formally: $ {\\mbox{Seq}}({\\mathcal {F}})=\\epsilon \\cup {\\mathcal {F}} \\cup {\\mathcal {F}}\\times {\\mathcal {F}} \\cup {\\mathcal {F}}\\times {\\mathcal {F}}\\times {\\mathcal {F}} \\cup \\cdots $ To put the above in words: An empty sequence or a sequence of one element or a sequence of two elements or a sequence of three elements, etc. The generating function would be: $ 1+F(x)+[F(x)] {2}+[F(x)] {3}+\\cdots ={\\frac {1}{1-F(x)}} $","title":"Sequences"},{"location":"Guide/Combinatorics/Enumerative-combinatorics/Enumerative-combinatorics/#combinatorial-structures","text":"The above operations can now be used to enumerate common combinatorial objects including trees (binary and plane), Dyck paths and cycles. A combinatorial structure is composed of atoms. For example, with trees the atoms would be the nodes. The atoms which compose the object can either be labeled or unlabeled. Unlabeled atoms are indistinguishable from each other, while labelled atoms are distinct. Therefore, for a combinatorial object consisting of labeled atoms a new object can be formed by simply swapping two or more atoms.","title":"Combinatorial structures"},{"location":"Guide/Combinatorics/Enumerative-combinatorics/Enumerative-combinatorics/#binary-and-plane-trees","text":"Binary and plane trees are examples of an unlabeled combinatorial structure. Trees consist of nodes linked by edges in such a way that there are no cycles. There is generally a node called the root, which has no parent node. In Plane trees each node can have an arbitrary number of children. In binary trees, a special case of plane trees, each node can have either two or no children. Let $ {\\mathcal {P}} $ denote the family of all plane trees. Then this family can be recursively defined as follows: $ {\\mathcal {P}}={\\bullet }\\times {\\mbox{Seq}}({\\mathcal {P}}) $ In this case $ {\\bullet } $ represents the family of objects consisting of one node. This has generating function x . Let P ( x ) denote the generating function $ {\\mathcal {P}} $. Putting the above description in words: A plane tree consists of a node to which is attached an arbitrary number of subtrees, each of which is also a plane tree. Using the operation on families of combinatorial structures developed earlier this translates to a recursive generating function: $ P(x)=x{\\frac {1}{1-P(x)}} $ After solving for P ( x ): $ P(x)={\\frac {1-{\\sqrt {1-4x}}}{2}} $ An explicit formula for the number of plane trees of size n can now be determined by extracting the coefficient of x^n x^n . $ {\\begin{aligned}p_{n}&=[x {n}]P(x)=[x {n}]{\\frac {1-{\\sqrt {1-4x}}}{2}}\\[6pt]&=[x^{n}]{\\frac {1}{2}}-[x^{n}]{\\frac {1}{2}}{\\sqrt {1-4x}}\\[6pt]&=-{\\frac {1}{2}}[x^{n}]\\sum _{k=0}^{\\infty }{{\\frac {1}{2}} \\choose k}(-4x)^{k}\\[6pt]&=-{\\frac {1}{2}}{{\\frac {1}{2}} \\choose n}(-4)^{n}\\[6pt]&={\\frac {1}{n}}{2n-2 \\choose n-1}\\end{aligned}} $ Note: The notation [ x**n ] f ( x ) refers to the coefficient of x**n in f ( x ). The series expansion of the square root is based on Newton's generalization of the binomial theorem . To get from the fourth to fifth line manipulations using the generalized binomial coefficient is needed. The expression on the last line is equal to the ( n \u2212 1)th Catalan number . Therefore p**n = c**n \u22121.","title":"Binary and plane trees"},{"location":"Guide/Combinatorics/Enumerative-combinatorics/Catalan-number/Catalan-number/","text":"Catalan number # In combinatorial mathematics , the Catalan numbers form a sequence of natural numbers that occur in various counting problems , often involving recursively -defined objects. They are named after the Belgian mathematician Eug\u00e8ne Charles Catalan (1814\u20131894). The *n*th Catalan number is given directly in terms of binomial coefficients by $ C_{n}={\\frac {1}{n+1}}{2n \\choose n}={\\frac {(2n)!}{(n+1)!\\,n!}}=\\prod \\limits _{k=2}^{n}{\\frac {n+k}{k}}\\qquad {\\text{for }}n\\geq 0. $ SUMMARY : \u6ce8\u610f\u662f\u8fde\u4e58\uff0c\u4e0a\u5f0f\u7ed9\u51fa\u7684\u662fCatalan number\u7684\u8ba1\u7b97\u65b9\u5f0f\uff0c\u4f46\u662f\u5728\u5b9e\u9645\u5730\u89e3\u51b3\u95ee\u9898\u8fc7\u7a0b\u4e2d\uff0c\u6211\u4eec\u66f4\u591a\u7684\u662f\u4f7f\u7528Catalan number\u7684\u9012\u5f52\u8868\u8fbe\u5f0f\uff1b The first Catalan numbers for n = 0, 1, 2, 3, ... are 1 , 1, 2 , 5 , 14 , 42 , 132 , 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, ... (sequence A000108 in the OEIS ). The C_5 = 42 C_5 = 42 noncrossing partitions of a 5-element set (below, the other 10 of the 52 partitions ) Properties # An alternative expression for C_n C_n is $ C_{n}={2n \\choose n}-{2n \\choose n+1}={1 \\over n+1}{2n \\choose n}\\quad {\\text{ for }}n\\geq 0, $ which is equivalent to the expression given above because $ {\\tbinom {2n}{n+1}}={\\tfrac {n}{n+1}}{\\tbinom {2n}{n}} $. This shows that C_n C_n is an integer , which is not immediately obvious from the first formula given. This expression forms the basis for a proof of the correctness of the formula . The Catalan numbers satisfy the recurrence relations [ 1] $ C_{0}=1\\quad {\\text{and}}\\quad C_{n+1}=\\sum {i=0}^{n}C {i}\\,C_{n-i}\\quad {\\text{for }}n\\geq 0, $ SUMMARY : \u4e3a\u4ec0\u4e48\u662f C_{i} C_{i} \u4e58\u4ee5 C_{n-i} C_{n-i} \uff0c\u800c\u4e0d\u662f\u76f8\u52a0\u5462\uff1f\u5982\u4f55\u6765\u7ed3\u548c\u5177\u4f53\u6848\u4f8b\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u5206\u6790\uff1f $ \\sum {i {1}+\\cdots +i_{m}=n,i_{1},\\ldots ,i_{m}\\geq 0}C_{i_{1}}\\cdots C_{i_{m}}={\\begin{cases}{\\dfrac {m(n+1)(n+2)\\cdots (n+m/2-1)}{2(n+m/2+2)(n+m/2+3)\\cdots (n+m)}}C_{n+m/2},&m{\\text{ even}}\\[5pt]{\\dfrac {m(n+1)(n+2)\\cdots (n+(m-1)/2)}{(n+(m+3)/2)(n+(m+3)/2+1)\\cdots (n+m)}}C_{n+(m-1)/2},&m{\\text{ odd,}}\\end{cases}} $ and $ C_{0}=1\\quad {\\text{and}}\\quad C_{n+1}={\\frac {2(2n+1)}{n+2}}C_{n}. $ Asymptotically, the Catalan numbers grow as $ C_{n}\\sim {\\frac {4 {n}}{n {3/2}{\\sqrt {\\pi }}}} $ in the sense that the quotient of the n*th Catalan number and the expression on the right tends towards 1 as *n approaches infinity. This can be proved by using Stirling's approximation for n ! or via generating functions; see the Asymptotic growth of the Catalan numbers section of the Generating function article. The only Catalan numbers C_n C_n that are odd are those for which n = 2^k \u2212 1 n = 2^k \u2212 1 ; all others are even. The only prime Catalan numbers are C_2 = 2 C_2 = 2 and C_3 = 5 C_3 = 5 .[ 2] The Catalan numbers have an integral representation $ C_{n}=\\int _{0} {4}x {n}\\rho (x)\\,dx, $ where $ \\rho (x)={\\tfrac {1}{2\\pi }}{\\sqrt {\\tfrac {4-x}{x}}}. $ This means that the Catalan numbers are a solution of the Hausdorff moment problem on the interval [0, 4] instead of [0, 1]. The orthogonal polynomials having the weight function $ \\rho (x) $ on $ [0,4] $ are $ H_{n}(x)=\\sum _{k=0}^{n}{n+k \\choose n-k}(-x)^{k}. $ Applications in combinatorics # There are many counting problems in combinatorics whose solution is given by the Catalan numbers . The book Enumerative Combinatorics: Volume 2 by combinatorialist Richard P. Stanley contains a set of exercises which describe 66 different interpretations\uff08\u89e3\u91ca\uff09 of the Catalan numbers . Following are some examples, with illustrations of the cases C_3 = 5 C_3 = 5 and C_4 = 14 C_4 = 14 . C_n C_n is the number of Dyck words [ 3] of length 2n 2n . A Dyck word is a string consisting of n X's and n Y's such that no initial segment of the string has more Y's than X's. For example, the following are the Dyck words of length 6: XXXYYY XYXXYY XYXYXY XXYYXY XXYXYY. Re-interpreting the symbol X as an open parenthesis and Y as a close parenthesis, C_n C_n counts the number of expressions containing n pairs of parentheses which are correctly matched: ((())) ()(()) ()()() (())() (()()) C_n C_n is the number of different ways n + 1 factors can be completely parenthesized (or the number of ways of associating n applications of a binary operator ). For n = 3, for example, we have the following five different parenthesizations of four factors: ((ab)c)d (a(bc))d (ab)(cd) a((bc)d) a(b(cd)) Successive applications of a binary operator can be represented in terms of a full binary tree . (A rooted binary tree is full if every vertex has either two children or no children.) It follows that C_n C_n is the number of full binary trees with n + 1 leaves: SUMMARY : \u5982\u679c\u5c06 ((ab)c)d (a(bc))d (ab)(cd) a((bc)d) a(b(cd)) \u4e2d\u7684\u5b57\u7b26\u770b\u505a\u4e0a\u9762\u6811\u4e2d\u7684leaf node\u7684\u8bdd\uff0c\u5219\u5b83\u4eec\u662f\u4e00\u4e00\u5bf9\u5e94\u7684\uff0c\u8fd9\u8bf4\u660e\u5b83\u4eec\u672c\u8d28\u4e0a\u662f\u540c\u4e00\u7c7b\u95ee\u9898\uff1b\u8fd9\u8bf4\u660ecatalan number\u548c\u4e8c\u53c9\u6811\u4e4b\u95f4\u4e5f\u662f\u5b58\u5728\u7740\u4e00\u5b9a\u7684\u5173\u8054\u7684\uff1b C_n C_n is the number of non-isomorphic ordered trees with n + 1 vertices. (An ordered tree is a rooted tree in which the children of each vertex are given a fixed left-to-right order.)[ 4] C_n C_n is the number of monotonic lattice paths along the edges of a grid with n \u00d7 n square cells, which do not pass above the diagonal. A monotonic path is one which starts in the lower left corner, finishes in the upper right corner, and consists entirely of edges pointing rightwards or upwards. Counting such paths is equivalent to counting Dyck words: X stands for \"move right\" and Y stands for \"move up\". Proof of the formula # There are several ways of explaining why the formula $ C_{n}={\\frac {1}{n+1}}{2n \\choose n} $ Generalizations # The two-parameter sequence of non-negative integers $ {\\frac {(2m)!(2n)!}{(m+n)!m!n!}} $ is a generalization of the Catalan numbers. These are named super-Catalan numbers , by Ira Gessel . These number should not confused with the Schr\u00f6der\u2013Hipparchus numbers , which sometimes are also called super-Catalan numbers. For $ m=1 $, this is just two times the ordinary Catalan numbers, and for $ m=n $, the numbers have an easy combinatorial description. However, other combinatorial descriptions are only known[ 15] for $ m=2 $ and $ m=3 $, and it is an open problem to find a general combinatorial interpretation. Sergey Fomin and Nathan Reading have given a generalized Catalan number associated to any finite crystalographic Coxeter group , namely the number of fully commutative elements of the group; in terms of the associated root system , it is the number of anti-chains (or order ideals) in the poset of positive roots. The classical Catalan number $ C_{n} $ corresponds to the root system of type $ A_{n} $. The classical recurrence relation generalizes: the Catalan number of a Coxeter diagram is equal to the sum of the Catalan numbers of all its maximal proper sub-diagrams.[ 16]","title":"Catalan-number"},{"location":"Guide/Combinatorics/Enumerative-combinatorics/Catalan-number/Catalan-number/#catalan-number","text":"In combinatorial mathematics , the Catalan numbers form a sequence of natural numbers that occur in various counting problems , often involving recursively -defined objects. They are named after the Belgian mathematician Eug\u00e8ne Charles Catalan (1814\u20131894). The *n*th Catalan number is given directly in terms of binomial coefficients by $ C_{n}={\\frac {1}{n+1}}{2n \\choose n}={\\frac {(2n)!}{(n+1)!\\,n!}}=\\prod \\limits _{k=2}^{n}{\\frac {n+k}{k}}\\qquad {\\text{for }}n\\geq 0. $ SUMMARY : \u6ce8\u610f\u662f\u8fde\u4e58\uff0c\u4e0a\u5f0f\u7ed9\u51fa\u7684\u662fCatalan number\u7684\u8ba1\u7b97\u65b9\u5f0f\uff0c\u4f46\u662f\u5728\u5b9e\u9645\u5730\u89e3\u51b3\u95ee\u9898\u8fc7\u7a0b\u4e2d\uff0c\u6211\u4eec\u66f4\u591a\u7684\u662f\u4f7f\u7528Catalan number\u7684\u9012\u5f52\u8868\u8fbe\u5f0f\uff1b The first Catalan numbers for n = 0, 1, 2, 3, ... are 1 , 1, 2 , 5 , 14 , 42 , 132 , 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, ... (sequence A000108 in the OEIS ). The C_5 = 42 C_5 = 42 noncrossing partitions of a 5-element set (below, the other 10 of the 52 partitions )","title":"Catalan number"},{"location":"Guide/Combinatorics/Enumerative-combinatorics/Catalan-number/Catalan-number/#properties","text":"An alternative expression for C_n C_n is $ C_{n}={2n \\choose n}-{2n \\choose n+1}={1 \\over n+1}{2n \\choose n}\\quad {\\text{ for }}n\\geq 0, $ which is equivalent to the expression given above because $ {\\tbinom {2n}{n+1}}={\\tfrac {n}{n+1}}{\\tbinom {2n}{n}} $. This shows that C_n C_n is an integer , which is not immediately obvious from the first formula given. This expression forms the basis for a proof of the correctness of the formula . The Catalan numbers satisfy the recurrence relations [ 1] $ C_{0}=1\\quad {\\text{and}}\\quad C_{n+1}=\\sum {i=0}^{n}C {i}\\,C_{n-i}\\quad {\\text{for }}n\\geq 0, $ SUMMARY : \u4e3a\u4ec0\u4e48\u662f C_{i} C_{i} \u4e58\u4ee5 C_{n-i} C_{n-i} \uff0c\u800c\u4e0d\u662f\u76f8\u52a0\u5462\uff1f\u5982\u4f55\u6765\u7ed3\u548c\u5177\u4f53\u6848\u4f8b\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u5206\u6790\uff1f $ \\sum {i {1}+\\cdots +i_{m}=n,i_{1},\\ldots ,i_{m}\\geq 0}C_{i_{1}}\\cdots C_{i_{m}}={\\begin{cases}{\\dfrac {m(n+1)(n+2)\\cdots (n+m/2-1)}{2(n+m/2+2)(n+m/2+3)\\cdots (n+m)}}C_{n+m/2},&m{\\text{ even}}\\[5pt]{\\dfrac {m(n+1)(n+2)\\cdots (n+(m-1)/2)}{(n+(m+3)/2)(n+(m+3)/2+1)\\cdots (n+m)}}C_{n+(m-1)/2},&m{\\text{ odd,}}\\end{cases}} $ and $ C_{0}=1\\quad {\\text{and}}\\quad C_{n+1}={\\frac {2(2n+1)}{n+2}}C_{n}. $ Asymptotically, the Catalan numbers grow as $ C_{n}\\sim {\\frac {4 {n}}{n {3/2}{\\sqrt {\\pi }}}} $ in the sense that the quotient of the n*th Catalan number and the expression on the right tends towards 1 as *n approaches infinity. This can be proved by using Stirling's approximation for n ! or via generating functions; see the Asymptotic growth of the Catalan numbers section of the Generating function article. The only Catalan numbers C_n C_n that are odd are those for which n = 2^k \u2212 1 n = 2^k \u2212 1 ; all others are even. The only prime Catalan numbers are C_2 = 2 C_2 = 2 and C_3 = 5 C_3 = 5 .[ 2] The Catalan numbers have an integral representation $ C_{n}=\\int _{0} {4}x {n}\\rho (x)\\,dx, $ where $ \\rho (x)={\\tfrac {1}{2\\pi }}{\\sqrt {\\tfrac {4-x}{x}}}. $ This means that the Catalan numbers are a solution of the Hausdorff moment problem on the interval [0, 4] instead of [0, 1]. The orthogonal polynomials having the weight function $ \\rho (x) $ on $ [0,4] $ are $ H_{n}(x)=\\sum _{k=0}^{n}{n+k \\choose n-k}(-x)^{k}. $","title":"Properties"},{"location":"Guide/Combinatorics/Enumerative-combinatorics/Catalan-number/Catalan-number/#applications-in-combinatorics","text":"There are many counting problems in combinatorics whose solution is given by the Catalan numbers . The book Enumerative Combinatorics: Volume 2 by combinatorialist Richard P. Stanley contains a set of exercises which describe 66 different interpretations\uff08\u89e3\u91ca\uff09 of the Catalan numbers . Following are some examples, with illustrations of the cases C_3 = 5 C_3 = 5 and C_4 = 14 C_4 = 14 . C_n C_n is the number of Dyck words [ 3] of length 2n 2n . A Dyck word is a string consisting of n X's and n Y's such that no initial segment of the string has more Y's than X's. For example, the following are the Dyck words of length 6: XXXYYY XYXXYY XYXYXY XXYYXY XXYXYY. Re-interpreting the symbol X as an open parenthesis and Y as a close parenthesis, C_n C_n counts the number of expressions containing n pairs of parentheses which are correctly matched: ((())) ()(()) ()()() (())() (()()) C_n C_n is the number of different ways n + 1 factors can be completely parenthesized (or the number of ways of associating n applications of a binary operator ). For n = 3, for example, we have the following five different parenthesizations of four factors: ((ab)c)d (a(bc))d (ab)(cd) a((bc)d) a(b(cd)) Successive applications of a binary operator can be represented in terms of a full binary tree . (A rooted binary tree is full if every vertex has either two children or no children.) It follows that C_n C_n is the number of full binary trees with n + 1 leaves: SUMMARY : \u5982\u679c\u5c06 ((ab)c)d (a(bc))d (ab)(cd) a((bc)d) a(b(cd)) \u4e2d\u7684\u5b57\u7b26\u770b\u505a\u4e0a\u9762\u6811\u4e2d\u7684leaf node\u7684\u8bdd\uff0c\u5219\u5b83\u4eec\u662f\u4e00\u4e00\u5bf9\u5e94\u7684\uff0c\u8fd9\u8bf4\u660e\u5b83\u4eec\u672c\u8d28\u4e0a\u662f\u540c\u4e00\u7c7b\u95ee\u9898\uff1b\u8fd9\u8bf4\u660ecatalan number\u548c\u4e8c\u53c9\u6811\u4e4b\u95f4\u4e5f\u662f\u5b58\u5728\u7740\u4e00\u5b9a\u7684\u5173\u8054\u7684\uff1b C_n C_n is the number of non-isomorphic ordered trees with n + 1 vertices. (An ordered tree is a rooted tree in which the children of each vertex are given a fixed left-to-right order.)[ 4] C_n C_n is the number of monotonic lattice paths along the edges of a grid with n \u00d7 n square cells, which do not pass above the diagonal. A monotonic path is one which starts in the lower left corner, finishes in the upper right corner, and consists entirely of edges pointing rightwards or upwards. Counting such paths is equivalent to counting Dyck words: X stands for \"move right\" and Y stands for \"move up\".","title":"Applications in combinatorics"},{"location":"Guide/Combinatorics/Enumerative-combinatorics/Catalan-number/Catalan-number/#proof-of-the-formula","text":"There are several ways of explaining why the formula $ C_{n}={\\frac {1}{n+1}}{2n \\choose n} $","title":"Proof of the formula"},{"location":"Guide/Combinatorics/Enumerative-combinatorics/Catalan-number/Catalan-number/#generalizations","text":"The two-parameter sequence of non-negative integers $ {\\frac {(2m)!(2n)!}{(m+n)!m!n!}} $ is a generalization of the Catalan numbers. These are named super-Catalan numbers , by Ira Gessel . These number should not confused with the Schr\u00f6der\u2013Hipparchus numbers , which sometimes are also called super-Catalan numbers. For $ m=1 $, this is just two times the ordinary Catalan numbers, and for $ m=n $, the numbers have an easy combinatorial description. However, other combinatorial descriptions are only known[ 15] for $ m=2 $ and $ m=3 $, and it is an open problem to find a general combinatorial interpretation. Sergey Fomin and Nathan Reading have given a generalized Catalan number associated to any finite crystalographic Coxeter group , namely the number of fully commutative elements of the group; in terms of the associated root system , it is the number of anti-chains (or order ideals) in the poset of positive roots. The classical Catalan number $ C_{n} $ corresponds to the root system of type $ A_{n} $. The classical recurrence relation generalizes: the Catalan number of a Coxeter diagram is equal to the sum of the Catalan numbers of all its maximal proper sub-diagrams.[ 16]","title":"Generalizations"},{"location":"Guide/Induction-and-Recursion/","text":"\u5173\u4e8e\u672c\u7ae0 # \u672c\u7ae0\u63cf\u8ff0induction\u3001deduction\u3001recursion\u76f8\u5173\u7684\u5185\u5bb9\uff0c\u672c\u7ae0\u7684\u5185\u5bb9\u4e3b\u8981\u6765\u81ea\u4e8e\u7ef4\u57fa\u767e\u79d1\u3002\u5728 Discrete Mathematics and Its Applications \u7684 chapter 5 \u4e2d\u5bf9\u4e0e\u6b64\u76f8\u5173\u7684\u5185\u5bb9\u8fdb\u884c\u4e86\u63cf\u8ff0\u3002","title":"Introduction"},{"location":"Guide/Induction-and-Recursion/#_1","text":"\u672c\u7ae0\u63cf\u8ff0induction\u3001deduction\u3001recursion\u76f8\u5173\u7684\u5185\u5bb9\uff0c\u672c\u7ae0\u7684\u5185\u5bb9\u4e3b\u8981\u6765\u81ea\u4e8e\u7ef4\u57fa\u767e\u79d1\u3002\u5728 Discrete Mathematics and Its Applications \u7684 chapter 5 \u4e2d\u5bf9\u4e0e\u6b64\u76f8\u5173\u7684\u5185\u5bb9\u8fdb\u884c\u4e86\u63cf\u8ff0\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Guide/Induction-and-Recursion/Summary/","text":"Summary # \u524d\u8a00 # \u5728\u524d\u9762\uff0c\u6211\u4eec\u8ba8\u8bba\u4e86\u4e00\u7cfb\u5217\u6982\u5ff5\uff0c\u5b83\u4eec\u4e4b\u95f4\u662f\u6709\u7740\u4e00\u5b9a\u7684\u5173\u8054\u7684\uff0c\u672c\u6587\u5c31\u5bf9\u5b83\u4eec\u8fdb\u884c\u5bf9\u6bd4\uff0c\u8fdb\u884c\u603b\u7ed3\uff0c\u4e0b\u9762\u662f\u4e2d\u6587\u90e8\u5206\u3002 \u6b63\u6587 # \u65e0\u8bba\u662fMathematical induction\uff0c\u8fd8\u662fStructural induction\uff0c\u5b83\u4eec\u672c\u8d28\u4e0a\u90fd\u662f proof method \uff08\u8bc1\u660e\u65b9\u6cd5\uff09\uff0c\u5b83\u63cf\u8ff0\u7684\u662f\u4e00\u79cd\u63a8\u5e7f\u3002 Recursive definition \uff08\u4e5f\u53eb\u505a**inductive definition**\uff09\u6b63\u5982\u5176\u540d\uff0c\u5b83\u662fdefinition\uff0c\u662fspecification\uff0c\u6240\u4ee5\u9700\u8981\u975e\u5e38\u4e25\u683c\uff0c\u5b83\u4e0d\u6d89\u53ca\u5b9e\u73b0\u3002 \u9012\u5f52 \u5f52\u7eb3 Recursion Induction Corecursion Coinduction Structural recursion Structural induction \u5173\u4e8eStructural recursion\u548cStructural induction\uff0c\u53c2\u89c1 Structural induction \u3002 Corecursion \u3001 Induction \u3001iteration\u7684\u65b9\u5411\u76f8\u540c\uff0c\u90fd\u662f\u81ea\u5e95\u5411\u4e0a\uff1b Recursion \u3001 Structural recursion \u7684\u65b9\u5411\u76f8\u540c\uff0c\u90fd\u662f\u81ea\u9876\u5411\u4e0b\uff1b Recursion VS corecursion # recursion \u548c corecursion \u7684\u8ba1\u7b97\u65b9\u5411\u662f\u76f8\u53cd\uff1a\u5bf9\u4e8e\u4e00\u4e2a recurrence relations \uff0c\u5982*n! := n \u00d7 (n - 1)!*.\uff0crecursion\u662f\u4ece\u5de6\u81f3\u53f3\uff0c\u4f46\u662fcorecursion\u662f\u4ece\u53f3\u81f3\u5de6\uff0c\u4f46\u662f\u80fd\u591f\u6b8a\u9014\u540c\u5f52 recursion works analytically VS corecursion works synthetically recursion top-down VS corecursion bottom-up recursion reduce VS corecursion produce \u5728 Tree traversal \u4e2d\u6709\u5982\u4e0b\u63cf\u8ff0\uff1a Depth-first search is easily implemented via a stack , including recursively (via the call stack ), while breadth-first search is easily implemented via a queue , including corecursively . Recursion VS induction # \u65e0\u8bba\u662finduction\u8fd8\u662frecursion\uff0c\u90fd\u9700\u8981base case\u3002 Induction\u672c\u8d28\u4e0a\u90fd\u662f proof method \u3002 \u5728\u7ef4\u57fa\u767e\u79d1 Structural induction \u4e2d\u6709\u8fd9\u6837\u7684\u63cf\u8ff0\uff1a A structurally recursive function uses the same idea to define a recursive function: \"base cases\" handle each minimal structure and a rule for recursion. Structural recursion is usually proved correct by structural induction; \u53e6\u5916\u53c2\u89c1\uff1a https://www.cs.cmu.edu/~rwh/introsml/techniques/indrec.htm \uff0c\u975e\u5e38\u597d\u7684\u4e00\u7bc7\u6587\u7ae0\u3002 Structural recursion versus generative recursion # \u5728 Recursion (computer science) \u4e2d\u6709\u4e13\u95e8\u7684\u7ae0\u8282\u6765\u63cf\u8ff0Structural versus generative recursion\u3002 How does structural recursion differ from generative recursion? # The description of generative recursion in Wikipedia is clear to me, but I'm confused about the concept of structural recursion. Can someone explain if a function calculating nth Fibonacci number and a function calculating factorial from 1 to N will be structural or generative? COMMENTS My two pennies: Fib is generative recursive using that definition because the data is \"generated\" as it goes along. Whereas, according to the article, structural recursion is about traversing an [existing] graph. The article goes on to state that an crucial distinction is that structural recursion can be proven to terminate through structural induction .. \u2013 user166390 A # The key difference between structural and generative recursion is where a recursive procedure gets the data that it works on and how it processes that data\uff08 recursive procedure gets the data that it works on\u5176\u5b9e\u5c31\u662frecursion function\u7684**\u5165\u53c2**\uff09. Specifically, for structural recursion , a recursive call is made on a subset of the original input data. Whereas for generative recursion , a recursive call is made on data that was constructed/calculated from the original input data. SUMMARY : \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u603b\u7ed3\u5730\u662f\u975e\u5e38\u597d\u7684\uff1b For example, if you wanted to count the number of elements in a linked list, you could do the following: int NumberOfNodes ( ListNode * node ) { if ( node == nullptr ) return 0 ; return 1 + NumberOfNodes ( node -> next ); } Here, the recursive call to NumberOfNodes is being made on node->next , which is a piece of the original input which already existed. In this case, the recursion works by breaking down the input into smaller pieces, then recursing on the smaller pieces. Similarly, this code to search a BST for a value would be structural recursion, because the recursive calls are to subparts of the original input: TreeNode * Find ( TreeNode * root , DataType value ) { if ( root == nullptr ) return nullptr ; if ( value < root -> value ) return Find ( root -> left , value ); else return Find ( root -> right , value ); The term \"structural recursion\" comes from the fact that these structures (lists, BSTs, etc.) can be defined recursively: A list is either nothing, or a cell followed by a list. A binary tree is either nothing, or a node with two binary trees as children. When doing structural recursion, you are \"undoing\" the operation from which these structures are built out of one another. For example, the NumberOfNodes function \"undoes\" the construction of taking a node and prepending it to an existing list. The Find operator \"undoes\" the operation of gluing a node to two other trees. Therefore, it's easy to see why these functions have to terminate - eventually, you \"undo\" all of the operations that went in to building up the object in the first place, and the recursion stops. On the other hand, consider Quicksort , which does the following: Pick a pivot. Create three new lists: one of all elements less than the pivot, one of all elements greater than the pivot, and one of all elements equal to the pivot. Recursively sort the first and second of these lists. Concatenate the list of smaller, equal, and larger values. Here, the recursive calls are being made on smaller arrays that weren't part of the original input - the lists had to be created from the data. (Typically, an implementation would reuse space for these lists, but those sublists weren't guaranteed to exist directly within the input). This distinction is blurry\uff08\u6a21\u7cca\u7684\uff09 when it comes to natural numbers . Usually, natural numbers are recursively defined as follows: 0 is a natural number. If n is a natural number, n + 1 is a natural number. Nothing else is a natural number. Under this definition, the number n is a \"part\" of n + 1. Therefore, this recursive code to compute n! is structural recursion: int Factorial ( int n ) { if ( n == 0 ) return 1 ; return n * Factorial ( n - 1 ); } This is structural recursion, because the argument n - 1 was a \"part\" of the original input n. Similarly, by this definition, computing the nth Fibonacci number recursively counts as structural recursion: int Fibonacci ( int n ) { if ( n <= 1 ) return n ; return Fibonacci ( n - 1 ) + Fibonacci ( n - 2 ); } This is considered structural recursion because n - 1 is a part of n (formed by \"undoing\" the +1) and n - 2 is a part of n - 1 (again formed by \"undoing\" the +1). On the other hand, this code to compute gcd would be considered generative recursion, rather than structural recursion: int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ); } The reasoning is that since a % b is \"computed\" from a and b , rather than formed by \"undoing\" some number of +1 operations, the data is generated. The reason that generative recursion is different from structural recursion is that there's no guarantee that it terminates. For example, think about this function: int BadTimes ( int a , int b ) { if ( a == 0 && b == 0 ) return 0 ; return BadTimes ( a * 2 , b - 1 ); } This generative recursive function never terminates: a keeps getting bigger even though b keeps getting smaller. Honestly, I've never heard of this distinction before and I teach courses in discrete math and programming. I wouldn't worry too much about it unless someone is requiring you to know the difference. Hope this helps!","title":"Summary"},{"location":"Guide/Induction-and-Recursion/Summary/#summary","text":"","title":"Summary"},{"location":"Guide/Induction-and-Recursion/Summary/#_1","text":"\u5728\u524d\u9762\uff0c\u6211\u4eec\u8ba8\u8bba\u4e86\u4e00\u7cfb\u5217\u6982\u5ff5\uff0c\u5b83\u4eec\u4e4b\u95f4\u662f\u6709\u7740\u4e00\u5b9a\u7684\u5173\u8054\u7684\uff0c\u672c\u6587\u5c31\u5bf9\u5b83\u4eec\u8fdb\u884c\u5bf9\u6bd4\uff0c\u8fdb\u884c\u603b\u7ed3\uff0c\u4e0b\u9762\u662f\u4e2d\u6587\u90e8\u5206\u3002","title":"\u524d\u8a00"},{"location":"Guide/Induction-and-Recursion/Summary/#_2","text":"\u65e0\u8bba\u662fMathematical induction\uff0c\u8fd8\u662fStructural induction\uff0c\u5b83\u4eec\u672c\u8d28\u4e0a\u90fd\u662f proof method \uff08\u8bc1\u660e\u65b9\u6cd5\uff09\uff0c\u5b83\u63cf\u8ff0\u7684\u662f\u4e00\u79cd\u63a8\u5e7f\u3002 Recursive definition \uff08\u4e5f\u53eb\u505a**inductive definition**\uff09\u6b63\u5982\u5176\u540d\uff0c\u5b83\u662fdefinition\uff0c\u662fspecification\uff0c\u6240\u4ee5\u9700\u8981\u975e\u5e38\u4e25\u683c\uff0c\u5b83\u4e0d\u6d89\u53ca\u5b9e\u73b0\u3002 \u9012\u5f52 \u5f52\u7eb3 Recursion Induction Corecursion Coinduction Structural recursion Structural induction \u5173\u4e8eStructural recursion\u548cStructural induction\uff0c\u53c2\u89c1 Structural induction \u3002 Corecursion \u3001 Induction \u3001iteration\u7684\u65b9\u5411\u76f8\u540c\uff0c\u90fd\u662f\u81ea\u5e95\u5411\u4e0a\uff1b Recursion \u3001 Structural recursion \u7684\u65b9\u5411\u76f8\u540c\uff0c\u90fd\u662f\u81ea\u9876\u5411\u4e0b\uff1b","title":"\u6b63\u6587"},{"location":"Guide/Induction-and-Recursion/Summary/#recursion-vs-corecursion","text":"recursion \u548c corecursion \u7684\u8ba1\u7b97\u65b9\u5411\u662f\u76f8\u53cd\uff1a\u5bf9\u4e8e\u4e00\u4e2a recurrence relations \uff0c\u5982*n! := n \u00d7 (n - 1)!*.\uff0crecursion\u662f\u4ece\u5de6\u81f3\u53f3\uff0c\u4f46\u662fcorecursion\u662f\u4ece\u53f3\u81f3\u5de6\uff0c\u4f46\u662f\u80fd\u591f\u6b8a\u9014\u540c\u5f52 recursion works analytically VS corecursion works synthetically recursion top-down VS corecursion bottom-up recursion reduce VS corecursion produce \u5728 Tree traversal \u4e2d\u6709\u5982\u4e0b\u63cf\u8ff0\uff1a Depth-first search is easily implemented via a stack , including recursively (via the call stack ), while breadth-first search is easily implemented via a queue , including corecursively .","title":"Recursion VS corecursion"},{"location":"Guide/Induction-and-Recursion/Summary/#recursion-vs-induction","text":"\u65e0\u8bba\u662finduction\u8fd8\u662frecursion\uff0c\u90fd\u9700\u8981base case\u3002 Induction\u672c\u8d28\u4e0a\u90fd\u662f proof method \u3002 \u5728\u7ef4\u57fa\u767e\u79d1 Structural induction \u4e2d\u6709\u8fd9\u6837\u7684\u63cf\u8ff0\uff1a A structurally recursive function uses the same idea to define a recursive function: \"base cases\" handle each minimal structure and a rule for recursion. Structural recursion is usually proved correct by structural induction; \u53e6\u5916\u53c2\u89c1\uff1a https://www.cs.cmu.edu/~rwh/introsml/techniques/indrec.htm \uff0c\u975e\u5e38\u597d\u7684\u4e00\u7bc7\u6587\u7ae0\u3002","title":"Recursion VS induction"},{"location":"Guide/Induction-and-Recursion/Summary/#structural-recursion-versus-generative-recursion","text":"\u5728 Recursion (computer science) \u4e2d\u6709\u4e13\u95e8\u7684\u7ae0\u8282\u6765\u63cf\u8ff0Structural versus generative recursion\u3002","title":"Structural recursion versus generative recursion"},{"location":"Guide/Induction-and-Recursion/Summary/#how-does-structural-recursion-differ-from-generative-recursion","text":"The description of generative recursion in Wikipedia is clear to me, but I'm confused about the concept of structural recursion. Can someone explain if a function calculating nth Fibonacci number and a function calculating factorial from 1 to N will be structural or generative? COMMENTS My two pennies: Fib is generative recursive using that definition because the data is \"generated\" as it goes along. Whereas, according to the article, structural recursion is about traversing an [existing] graph. The article goes on to state that an crucial distinction is that structural recursion can be proven to terminate through structural induction .. \u2013 user166390","title":"How does structural recursion differ from generative recursion?"},{"location":"Guide/Induction-and-Recursion/Summary/#a","text":"The key difference between structural and generative recursion is where a recursive procedure gets the data that it works on and how it processes that data\uff08 recursive procedure gets the data that it works on\u5176\u5b9e\u5c31\u662frecursion function\u7684**\u5165\u53c2**\uff09. Specifically, for structural recursion , a recursive call is made on a subset of the original input data. Whereas for generative recursion , a recursive call is made on data that was constructed/calculated from the original input data. SUMMARY : \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u603b\u7ed3\u5730\u662f\u975e\u5e38\u597d\u7684\uff1b For example, if you wanted to count the number of elements in a linked list, you could do the following: int NumberOfNodes ( ListNode * node ) { if ( node == nullptr ) return 0 ; return 1 + NumberOfNodes ( node -> next ); } Here, the recursive call to NumberOfNodes is being made on node->next , which is a piece of the original input which already existed. In this case, the recursion works by breaking down the input into smaller pieces, then recursing on the smaller pieces. Similarly, this code to search a BST for a value would be structural recursion, because the recursive calls are to subparts of the original input: TreeNode * Find ( TreeNode * root , DataType value ) { if ( root == nullptr ) return nullptr ; if ( value < root -> value ) return Find ( root -> left , value ); else return Find ( root -> right , value ); The term \"structural recursion\" comes from the fact that these structures (lists, BSTs, etc.) can be defined recursively: A list is either nothing, or a cell followed by a list. A binary tree is either nothing, or a node with two binary trees as children. When doing structural recursion, you are \"undoing\" the operation from which these structures are built out of one another. For example, the NumberOfNodes function \"undoes\" the construction of taking a node and prepending it to an existing list. The Find operator \"undoes\" the operation of gluing a node to two other trees. Therefore, it's easy to see why these functions have to terminate - eventually, you \"undo\" all of the operations that went in to building up the object in the first place, and the recursion stops. On the other hand, consider Quicksort , which does the following: Pick a pivot. Create three new lists: one of all elements less than the pivot, one of all elements greater than the pivot, and one of all elements equal to the pivot. Recursively sort the first and second of these lists. Concatenate the list of smaller, equal, and larger values. Here, the recursive calls are being made on smaller arrays that weren't part of the original input - the lists had to be created from the data. (Typically, an implementation would reuse space for these lists, but those sublists weren't guaranteed to exist directly within the input). This distinction is blurry\uff08\u6a21\u7cca\u7684\uff09 when it comes to natural numbers . Usually, natural numbers are recursively defined as follows: 0 is a natural number. If n is a natural number, n + 1 is a natural number. Nothing else is a natural number. Under this definition, the number n is a \"part\" of n + 1. Therefore, this recursive code to compute n! is structural recursion: int Factorial ( int n ) { if ( n == 0 ) return 1 ; return n * Factorial ( n - 1 ); } This is structural recursion, because the argument n - 1 was a \"part\" of the original input n. Similarly, by this definition, computing the nth Fibonacci number recursively counts as structural recursion: int Fibonacci ( int n ) { if ( n <= 1 ) return n ; return Fibonacci ( n - 1 ) + Fibonacci ( n - 2 ); } This is considered structural recursion because n - 1 is a part of n (formed by \"undoing\" the +1) and n - 2 is a part of n - 1 (again formed by \"undoing\" the +1). On the other hand, this code to compute gcd would be considered generative recursion, rather than structural recursion: int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ); } The reasoning is that since a % b is \"computed\" from a and b , rather than formed by \"undoing\" some number of +1 operations, the data is generated. The reason that generative recursion is different from structural recursion is that there's no guarantee that it terminates. For example, think about this function: int BadTimes ( int a , int b ) { if ( a == 0 && b == 0 ) return 0 ; return BadTimes ( a * 2 , b - 1 ); } This generative recursive function never terminates: a keeps getting bigger even though b keeps getting smaller. Honestly, I've never heard of this distinction before and I teach courses in discrete math and programming. I wouldn't worry too much about it unless someone is requiring you to know the difference. Hope this helps!","title":"A"},{"location":"Guide/Induction-and-Recursion/Induction-and-deduction/","text":"\u5173\u4e8e\u672c\u7ae0 # \u672c\u7ae0\u63cf\u8ff0induction\uff08\u5f52\u7eb3\uff09\u548cdeduction\uff08\u6f14\u7ece\uff09\u7684\u5185\u5bb9\u3002","title":"Introduction"},{"location":"Guide/Induction-and-Recursion/Induction-and-deduction/#_1","text":"\u672c\u7ae0\u63cf\u8ff0induction\uff08\u5f52\u7eb3\uff09\u548cdeduction\uff08\u6f14\u7ece\uff09\u7684\u5185\u5bb9\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Guide/Induction-and-Recursion/Induction-and-deduction/Coinduction/","text":"Coinduction # \u201ccoinduction\u201d\u5373\u201c\u5171\u5f52\u7eb3\u201d\u3002\u5728\u9605\u8bfb Stream (computing) \u65f6\u78b0\u5230\u7684\u8fd9\u4e2a\u6982\u5ff5\u3002 \u7ef4\u57fa\u767e\u79d1 Coinduction # \u672c\u6587\u6ca1\u6709\u7406\u89e3\u3002","title":"Coinduction"},{"location":"Guide/Induction-and-Recursion/Induction-and-deduction/Coinduction/#coinduction","text":"\u201ccoinduction\u201d\u5373\u201c\u5171\u5f52\u7eb3\u201d\u3002\u5728\u9605\u8bfb Stream (computing) \u65f6\u78b0\u5230\u7684\u8fd9\u4e2a\u6982\u5ff5\u3002","title":"Coinduction"},{"location":"Guide/Induction-and-Recursion/Induction-and-deduction/Coinduction/#coinduction_1","text":"\u672c\u6587\u6ca1\u6709\u7406\u89e3\u3002","title":"\u7ef4\u57fa\u767e\u79d1Coinduction"},{"location":"Guide/Induction-and-Recursion/Induction-and-deduction/Induction-and-deduction/","text":"Induction & Deduction # \u5728\u9605\u8bfb\u4e2d\u7ecf\u5e38\u78b0\u5230\u8fd9\u4e24\u4e2a\u8bcd\u8bed\uff0c\u201cinduction\u201d\u5373\u201c\u5f52\u7eb3\u201d\uff0c\u201cdeduction\u201d\u5373\u201c\u6f14\u7ece\u201d\uff0c\u6709\u5fc5\u8981\u5bf9\u5b83\u4eec\u8fdb\u884c\u603b\u7ed3\u3002 Deduction & Induction # In logic, we often refer to the two broad methods of reasoning as the deductive and inductive approaches. \u4e24\u8005\u90fd\u662f\u201c\u63a8\u7406\u201d\u7684\u65b9\u6cd5\u3002 Deductive reasoning works from the more general to the more specific. Sometimes this is informally called a \u201ctop-down\u201d approach. Inductive reasoning works the other way, moving from specific observations to broader generalizations and theories. Informally, we sometimes call this a \u201cbottom up\u201d approach (please note that it\u2019s \u201cbottom up\u201d and not \u201cbottom**s** up\u201d which is the kind of thing the bartender says to customers when he\u2019s trying to close for the night!). #","title":"Induction-and-deduction"},{"location":"Guide/Induction-and-Recursion/Induction-and-deduction/Induction-and-deduction/#induction-deduction","text":"\u5728\u9605\u8bfb\u4e2d\u7ecf\u5e38\u78b0\u5230\u8fd9\u4e24\u4e2a\u8bcd\u8bed\uff0c\u201cinduction\u201d\u5373\u201c\u5f52\u7eb3\u201d\uff0c\u201cdeduction\u201d\u5373\u201c\u6f14\u7ece\u201d\uff0c\u6709\u5fc5\u8981\u5bf9\u5b83\u4eec\u8fdb\u884c\u603b\u7ed3\u3002","title":"Induction &amp; Deduction"},{"location":"Guide/Induction-and-Recursion/Induction-and-deduction/Induction-and-deduction/#deduction-induction","text":"In logic, we often refer to the two broad methods of reasoning as the deductive and inductive approaches. \u4e24\u8005\u90fd\u662f\u201c\u63a8\u7406\u201d\u7684\u65b9\u6cd5\u3002 Deductive reasoning works from the more general to the more specific. Sometimes this is informally called a \u201ctop-down\u201d approach. Inductive reasoning works the other way, moving from specific observations to broader generalizations and theories. Informally, we sometimes call this a \u201cbottom up\u201d approach (please note that it\u2019s \u201cbottom up\u201d and not \u201cbottom**s** up\u201d which is the kind of thing the bartender says to customers when he\u2019s trying to close for the night!).","title":"Deduction &amp; Induction"},{"location":"Guide/Induction-and-Recursion/Induction-and-deduction/Induction/","text":"Induction # \"induction\"\u5373\u5f52\u7eb3\uff0c\u6211\u89c9\u5f97\u5b83\u6240\u63cf\u8ff0\u7684\u662f\u4e00\u79cd\u63a8\u5e7f\u3002\u672c\u6587\u5bf9\u5b83\u8fdb\u884c\u5206\u6790\u3002 \u7ef4\u57fa\u767e\u79d1 Mathematical induction # \u6570\u5b66\u5f52\u7eb3\u6cd5 Mathematical induction is a mathematical proof technique. It is essentially used to prove that a property P ( n ) holds for every natural number n , i.e. for n = 0, 1, 2, 3, and so on. Metaphors can be informally used to understand the concept of mathematical induction, such as the metaphor of falling dominoes\uff08\u591a\u7c73\u8bfa\u9aa8\u724c\uff09 or climbing a ladder\uff08\u68af\u5b50\uff09. The method of induction requires two cases to be proved. The first case, called the base case (or, sometimes, the basis ), proves that the property holds for the number 0. The second case, called the induction step , proves that if the property holds for one natural number n , then it holds for the next natural number n+1 . These two steps establish the property P(n) for every natural number n=0,1,2,3... The method can be extended to prove statements about more general well-founded structures, such as trees ; this generalization, known as structural induction , is used in mathematical logic and computer science . Mathematical induction in this extended sense is closely related to recursion . Mathematical induction, in some form, is the foundation of all correctness proofs for computer programs . \u5bf9\u4e8e\u8f6f\u4ef6\u5de5\u7a0b\u5e08\u800c\u8a00\uff0c\u78b0\u5230\u7684\u66f4\u591a\u7684\u662f structural induction \u3002 \u7ef4\u57fa\u767e\u79d1 Structural induction # NOTE: \u7ef4\u57fa\u767e\u79d1\u7684\u8fd9\u7bc7\u6587\u7ae0\u603b\u7ed3\u7684\u975e\u5e38\u597d Structural induction is a proof method that is used in mathematical logic (e.g., in the proof of \u0141o\u015b' theorem ), computer science , graph theory , and some other mathematical fields. It is a generalization of mathematical induction over natural numbers and can be further generalized to arbitrary Noetherian induction . Structural recursion is a recursion method bearing the same relationship to structural induction as ordinary recursion bears to ordinary mathematical induction . NOTE: \u6700\u540e\u4e00\u6bb5\u8bdd\u975e\u5e38\u91cd\u8981\uff0c\u5b83\u5c06\u8868\u8fbe\u7684\u542b\u4e49\u662f\uff1astructural recursion \u548c structural induction \u7684\u5173\u7cfb\u4e0erecursion \u548c mathematical induction \u7684\u5173\u7cfb \u76f8\u540c\u3002 Structural induction is used to prove that some proposition P ( x ) holds for all x of some sort of recursively defined structure, such as formulas , lists , or trees . A well-founded partial order is defined on the structures (\"subformula\" for formulas, \"sublist\" for lists, and \"subtree\" for trees). The structural induction proof is a proof that the proposition holds for all the minimal structures and that if it holds for the immediate substructures of a certain structure S , then it must hold for S also. (Formally speaking, this then satisfies the premises of an axiom of well-founded induction , which asserts that these two conditions are sufficient for the proposition to hold for all x .) A structurally recursive function uses the same idea to define a recursive function: \"base cases\" handle each minimal structure and a rule for recursion. Structural recursion is usually proved correct by structural induction ; in particularly easy cases, the inductive step is often left out. The length and ++ functions in the example below are structurally recursive. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u63cf\u8ff0\u4e86structurally recursive function\u7684\u5b9e\u73b0\u601d\u8def\u3002 NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e5f\u8bf4\u660e\u4e86recursion\u548cinduction\u4e4b\u95f4\u7684\u5173\u7cfb\uff1arecursion\u7528\u4e8e\u8ba1\u7b97\u673a\u5b9e\u73b0\uff0cinduction\u7528\u4e8e\u6570\u5b66\u8bc1\u660e\u3002 \u7ef4\u57fa\u767e\u79d1 Transfinite induction # \u201ctransfinite induction\u201d\u5373\u201c\u65e0\u9650\u5f52\u7eb3\u201d\u3002","title":"Induction"},{"location":"Guide/Induction-and-Recursion/Induction-and-deduction/Induction/#induction","text":"\"induction\"\u5373\u5f52\u7eb3\uff0c\u6211\u89c9\u5f97\u5b83\u6240\u63cf\u8ff0\u7684\u662f\u4e00\u79cd\u63a8\u5e7f\u3002\u672c\u6587\u5bf9\u5b83\u8fdb\u884c\u5206\u6790\u3002","title":"Induction"},{"location":"Guide/Induction-and-Recursion/Induction-and-deduction/Induction/#mathematical-induction","text":"\u6570\u5b66\u5f52\u7eb3\u6cd5 Mathematical induction is a mathematical proof technique. It is essentially used to prove that a property P ( n ) holds for every natural number n , i.e. for n = 0, 1, 2, 3, and so on. Metaphors can be informally used to understand the concept of mathematical induction, such as the metaphor of falling dominoes\uff08\u591a\u7c73\u8bfa\u9aa8\u724c\uff09 or climbing a ladder\uff08\u68af\u5b50\uff09. The method of induction requires two cases to be proved. The first case, called the base case (or, sometimes, the basis ), proves that the property holds for the number 0. The second case, called the induction step , proves that if the property holds for one natural number n , then it holds for the next natural number n+1 . These two steps establish the property P(n) for every natural number n=0,1,2,3... The method can be extended to prove statements about more general well-founded structures, such as trees ; this generalization, known as structural induction , is used in mathematical logic and computer science . Mathematical induction in this extended sense is closely related to recursion . Mathematical induction, in some form, is the foundation of all correctness proofs for computer programs . \u5bf9\u4e8e\u8f6f\u4ef6\u5de5\u7a0b\u5e08\u800c\u8a00\uff0c\u78b0\u5230\u7684\u66f4\u591a\u7684\u662f structural induction \u3002","title":"\u7ef4\u57fa\u767e\u79d1Mathematical induction"},{"location":"Guide/Induction-and-Recursion/Induction-and-deduction/Induction/#structural-induction","text":"NOTE: \u7ef4\u57fa\u767e\u79d1\u7684\u8fd9\u7bc7\u6587\u7ae0\u603b\u7ed3\u7684\u975e\u5e38\u597d Structural induction is a proof method that is used in mathematical logic (e.g., in the proof of \u0141o\u015b' theorem ), computer science , graph theory , and some other mathematical fields. It is a generalization of mathematical induction over natural numbers and can be further generalized to arbitrary Noetherian induction . Structural recursion is a recursion method bearing the same relationship to structural induction as ordinary recursion bears to ordinary mathematical induction . NOTE: \u6700\u540e\u4e00\u6bb5\u8bdd\u975e\u5e38\u91cd\u8981\uff0c\u5b83\u5c06\u8868\u8fbe\u7684\u542b\u4e49\u662f\uff1astructural recursion \u548c structural induction \u7684\u5173\u7cfb\u4e0erecursion \u548c mathematical induction \u7684\u5173\u7cfb \u76f8\u540c\u3002 Structural induction is used to prove that some proposition P ( x ) holds for all x of some sort of recursively defined structure, such as formulas , lists , or trees . A well-founded partial order is defined on the structures (\"subformula\" for formulas, \"sublist\" for lists, and \"subtree\" for trees). The structural induction proof is a proof that the proposition holds for all the minimal structures and that if it holds for the immediate substructures of a certain structure S , then it must hold for S also. (Formally speaking, this then satisfies the premises of an axiom of well-founded induction , which asserts that these two conditions are sufficient for the proposition to hold for all x .) A structurally recursive function uses the same idea to define a recursive function: \"base cases\" handle each minimal structure and a rule for recursion. Structural recursion is usually proved correct by structural induction ; in particularly easy cases, the inductive step is often left out. The length and ++ functions in the example below are structurally recursive. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u63cf\u8ff0\u4e86structurally recursive function\u7684\u5b9e\u73b0\u601d\u8def\u3002 NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e5f\u8bf4\u660e\u4e86recursion\u548cinduction\u4e4b\u95f4\u7684\u5173\u7cfb\uff1arecursion\u7528\u4e8e\u8ba1\u7b97\u673a\u5b9e\u73b0\uff0cinduction\u7528\u4e8e\u6570\u5b66\u8bc1\u660e\u3002","title":"\u7ef4\u57fa\u767e\u79d1Structural induction"},{"location":"Guide/Induction-and-Recursion/Induction-and-deduction/Induction/#transfinite-induction","text":"\u201ctransfinite induction\u201d\u5373\u201c\u65e0\u9650\u5f52\u7eb3\u201d\u3002","title":"\u7ef4\u57fa\u767e\u79d1Transfinite induction"},{"location":"Guide/Induction-and-Recursion/Recursion/","text":"\u5173\u4e8e\u672c\u7ae0 # \u9012\u5f52\u662f\u4e00\u79cd\u4f18\u826f\u7684\u7279\u6027\uff0c\u5728\u5404\u4e2a\u5b66\u79d1\u4e2d\u90fd\u6709\u7740\u5e7f\u6cdb\u7684\u5e94\u7528\uff0c\u662f\u4e00\u4e2a\u91cd\u8981\u7684\u6982\u5ff5\u3002\u5728\u591a\u4e2a\u5de5\u7a0b\u4e2d\u90fd\u4f1a\u6d89\u53ca\u5230\u9012\u5f52\uff0c\u6240\u4ee5\u672c\u7ae0\u5bf9\u9012\u5f52\u5b9a\u4e49\u53ca\u9012\u5f52\u8fdb\u884c\u8bba\u8ff0\u3002\u672c\u7ae0\u5148\u8bba\u8ff0\u201drecursive definition\u201c\uff0c\u7136\u540e\u8bba\u8ff0\u66f4\u52a0\u62bd\u8c61\u7684\u201drecursion\u201c\uff0c\u56e0\u4e3a\u524d\u8005\u76f8\u5bf9\u800c\u6765\u8bf4\u66f4\u52a0\u6613\u4e8e\u7406\u89e3\u3002","title":"Introduction"},{"location":"Guide/Induction-and-Recursion/Recursion/#_1","text":"\u9012\u5f52\u662f\u4e00\u79cd\u4f18\u826f\u7684\u7279\u6027\uff0c\u5728\u5404\u4e2a\u5b66\u79d1\u4e2d\u90fd\u6709\u7740\u5e7f\u6cdb\u7684\u5e94\u7528\uff0c\u662f\u4e00\u4e2a\u91cd\u8981\u7684\u6982\u5ff5\u3002\u5728\u591a\u4e2a\u5de5\u7a0b\u4e2d\u90fd\u4f1a\u6d89\u53ca\u5230\u9012\u5f52\uff0c\u6240\u4ee5\u672c\u7ae0\u5bf9\u9012\u5f52\u5b9a\u4e49\u53ca\u9012\u5f52\u8fdb\u884c\u8bba\u8ff0\u3002\u672c\u7ae0\u5148\u8bba\u8ff0\u201drecursive definition\u201c\uff0c\u7136\u540e\u8bba\u8ff0\u66f4\u52a0\u62bd\u8c61\u7684\u201drecursion\u201c\uff0c\u56e0\u4e3a\u524d\u8005\u76f8\u5bf9\u800c\u6765\u8bf4\u66f4\u52a0\u6613\u4e8e\u7406\u89e3\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Guide/Induction-and-Recursion/Recursion/Corecursion/","text":"Corecursion # \u5171\u9012\u5f52 In computer science , corecursion is a type of operation that is dual to recursion . Whereas recursion works analytically , starting on data further from a base case and breaking it down into smaller data and repeating until one reaches a base case, corecursion works synthetically , starting from a base case and building it up, iteratively producing data further removed from a base case. Put simply, corecursive algorithms use the data that they themselves produce, bit by bit, as they become available, and needed, to produce further bits of data. A similar but distinct concept is generative recursion which may lack a definite\uff08\u786e\u5207\u7684\uff09 \"direction\" inherent in corecursion and recursion. NOTE: recursion \u548c corecursion \u7684\u8ba1\u7b97\u65b9\u5411\u662f\u76f8\u53cd\uff1a\u5bf9\u4e8e\u4e00\u4e2a recurrence relations \uff0c\u5982*n! := n \u00d7 (n - 1)! .\uff0crecursion\u662f\u4ece\u5de6\u81f3\u53f3\uff0c\u4f46\u662fcorecursion\u662f\u4ece\u53f3\u81f3\u5de6\uff0c\u4f46\u662f\u80fd\u591f\u6b8a\u9014\u540c\u5f52 - recursion works **analytically* VS corecursion works synthetically - recursion top-down VS corecursion bottom-up - recursion reduce VS corecursion produce Where recursion allows programs to operate on arbitrarily complex data, so long as they can be reduced to simple data (base cases), corecursion allows programs to produce arbitrarily complex and potentially infinite data structures, such as streams , so long as it can be produced from simple data ( base cases ) in a sequence of finite steps. Where recursion may not terminate, never reaching a base state , corecursion starts from a base state , and thus produces subsequent steps deterministically, though it may proceed indefinitely (and thus not terminate under strict evaluation), or it may consume more than it produces and thus become non- productive . Many functions that are traditionally analyzed as recursive can alternatively, and arguably more naturally, be interpreted as corecursive functions that are terminated at a given stage, for example recurrence relations such as the factorial\uff08\u9636\u4e58\uff09. Corecursion can produce both finite and infinite data structures as results, and may employ self-referential data structures. Corecursion is often used in conjunction with lazy evaluation , to produce only a finite subset of a potentially infinite structure (rather than trying to produce an entire infinite structure at once). Corecursion is a particularly important concept in functional programming , where corecursion and codata allow total languages to work with infinite data structures. NOTE : python\u7684generator\u5c31\u662fCorecursion\u7684\u6700\u597d\u7684\u4f8b\u5b50\u3002 Examples # Corecursion can be understood by contrast with recursion, which is more familiar. While corecursion is primarily of interest in functional programming, it can be illustrated using imperative programming, which is done below using the generator facility in Python. In these examples local variables are used, and assigned values imperatively (destructively), though these are not necessary in corecursion in pure functional programming. In pure functional programming, rather than assigning to local variables , these computed values form an invariable sequence, and prior values are accessed by self-reference (later values in the sequence reference earlier values in the sequence to be computed). The assignments simply express this in the imperative paradigm and explicitly specify where the computations happen, which serves to clarify the exposition. Factorial # A classic example of recursion is computing the factorial \uff08\u9636\u4e58\uff09, which is defined recursively by 0! := 1 and n! := n \u00d7 (n - 1)! . To recursively compute its result on a given input, a recursive function calls (a copy of) itself with a different (\"smaller\" in some way) input and uses the result of this call to construct its result. The recursive call does the same, unless the base case has been reached. Thus a call stack develops in the process. For example, to compute fac(3) , this recursively calls in turn fac(2) , fac(1) , fac(0) (\"winding up\" the stack), at which point recursion terminates with fac(0) = 1 , and then the stack unwinds in reverse order and the results are calculated on the way back along the call stack to the initial call frame fac(3) that uses the result of fac(2) = 2 to calculate the final result as 3 \u00d7 2 = 3 \u00d7 fac(2) =: fac(3) and finally return fac(3) = 6 . In this example a function returns a single value. This stack unwinding can be explicated, defining the factorial corecursively , as an iterator , where one starts with the case of $ 1=:0! $, then from this starting value constructs factorial values for increasing numbers 1, 2, 3... as in the above recursive definition with \"time arrow\" reversed, as it were, by reading it backwards as $ n!\\times (n+1)=:(n+1)! $. The corecursive algorithm thus defined produces a stream of all factorials. This may be concretely implemented as a generator . Symbolically, noting that computing next factorial value requires keeping track of both n and f (a previous factorial value), this can be represented as: $ n,f=(0,1):(n+1,f\\times (n+1)) $ In Python, a recursive factorial function can be defined as: def factorial ( n ): if n == 0 : return 1 else : return n * factorial ( n - 1 ) This could then be called for example as factorial(5) to compute 5! . A corresponding corecursive generator can be defined as: def factorials (): n , f = 0 , 1 while True : yield f n , f = n + 1 , f * ( n + 1 ) This generates an infinite stream of factorials in order; a finite portion of it can be produced by: def n_factorials ( k ): n , f = 0 , 1 while n <= k : yield f n , f = n + 1 , f * ( n + 1 ) This could then be called to produce the factorials up to 5! via: for f in n_factorials ( 5 ): print ( f ) If we're only interested in a certain factorial, just the last value can be taken, or we can fuse the production and the access into one function, def nth_factorial ( k ): n , f = 0 , 1 while n < k : n , f = n + 1 , f * ( n + 1 ) yield f As can be readily seen here, this is practically equivalent (just by substituting return for the only yield there) to the accumulator argument technique for tail recursion , unwound into an explicit loop. Thus it can be said that the concept of corecursion is an explication of the embodiment of iterative computation processes by recursive definitions, where applicable. \u56e0\u6b64\uff0c\u53ef\u4ee5\u8fd9\u6837\u8bf4\uff0c\u534f\u9012\u5f52\u7684\u6982\u5ff5\u662f\u901a\u8fc7\u9012\u5f52\u5b9a\u4e49\u6765\u89e3\u91ca\u8fed\u4ee3\u8ba1\u7b97\u8fc7\u7a0b\u7684\u4f53\u73b0\u3002 Fibonacci sequence # In the same way, the Fibonacci sequence can be represented as: $ a,b=(0,1):(b,a+b) $ Note that because the Fibonacci sequence is a recurrence relation of order 2, the corecursive relation must track two successive terms, with the $ (b,-) $ corresponding to shift forward by one step, and the $ (-,a+b) $ corresponding to computing the next term. This can then be implemented as follows (using parallel assignment ): def fibonacci_sequence (): a , b = 0 , 1 while True : yield a a , b = b , a + b In Haskell, map fst ( ( \\ ( a , b ) -> ( b , a + b )) ` iterate ` ( 0 , 1 ) ) Tree traversal # Tree traversal via a depth-first approach is a classic example of recursion . Dually, breadth-first traversal can very naturally be implemented via corecursion . Without using recursion or corecursion specifically, one may traverse a tree by starting at the root node , placing its child nodes in a data structure , then iterating by removing node after node from the data structure while placing each removed node's children back into that data structure.[ b] If the data structure is a stack (LIFO), this yields depth-first traversal , and if the data structure is a queue (FIFO), this yields breadth-first traversal . NOTE: \u5728\u4e0d\u4f7f\u7528recursion\u6216\u8005corecursion\u7684\u65f6\u5019\uff0c\u6211\u4eec\u5982\u679c\u60f3\u8981\u904d\u5386\u4e00\u68f5\u6811\uff0c\u5219\u9700\u8981\u501f\u52a9\u4e8e\u4e00\u4e2adata structure\u6765\u5b9e\u73b0\uff1b Using recursion , a (post-order)[ c] depth-first traversal can be implemented by starting at the root node and recursively traversing each child subtree in turn (the subtree based at each child node) \u2013 the second child subtree does not start processing until the first child subtree is finished. Once a leaf node is reached or the children of a branch node have been exhausted, the node itself is visited (e.g., the value of the node itself is outputted). In this case, the call stack (of the recursive functions ) acts as the stack that is iterated over. Using corecursion , a breadth-first traversal can be implemented by starting at the root node, outputting its value,[ d] then breadth-first traversing the subtrees \u2013 i.e., passing on the whole list of subtrees to the next step (not a single subtree, as in the recursive approach) \u2013 at the next step outputting the value of all of their root nodes, then passing on their child subtrees, etc.[ e] In this case the generator function , indeed the output sequence itself, acts as the queue . As in the factorial example (above), where the auxiliary information of the index (which step one was at, n ) was pushed forward, in addition to the actual output of n !, in this case the auxiliary information of the remaining subtrees is pushed forward, in addition to the actual output. Symbolically: $ v,t=([],[FullTree]):(RootValues(t),ChildTrees(t)) $","title":"Corecursion"},{"location":"Guide/Induction-and-Recursion/Recursion/Corecursion/#corecursion","text":"\u5171\u9012\u5f52 In computer science , corecursion is a type of operation that is dual to recursion . Whereas recursion works analytically , starting on data further from a base case and breaking it down into smaller data and repeating until one reaches a base case, corecursion works synthetically , starting from a base case and building it up, iteratively producing data further removed from a base case. Put simply, corecursive algorithms use the data that they themselves produce, bit by bit, as they become available, and needed, to produce further bits of data. A similar but distinct concept is generative recursion which may lack a definite\uff08\u786e\u5207\u7684\uff09 \"direction\" inherent in corecursion and recursion. NOTE: recursion \u548c corecursion \u7684\u8ba1\u7b97\u65b9\u5411\u662f\u76f8\u53cd\uff1a\u5bf9\u4e8e\u4e00\u4e2a recurrence relations \uff0c\u5982*n! := n \u00d7 (n - 1)! .\uff0crecursion\u662f\u4ece\u5de6\u81f3\u53f3\uff0c\u4f46\u662fcorecursion\u662f\u4ece\u53f3\u81f3\u5de6\uff0c\u4f46\u662f\u80fd\u591f\u6b8a\u9014\u540c\u5f52 - recursion works **analytically* VS corecursion works synthetically - recursion top-down VS corecursion bottom-up - recursion reduce VS corecursion produce Where recursion allows programs to operate on arbitrarily complex data, so long as they can be reduced to simple data (base cases), corecursion allows programs to produce arbitrarily complex and potentially infinite data structures, such as streams , so long as it can be produced from simple data ( base cases ) in a sequence of finite steps. Where recursion may not terminate, never reaching a base state , corecursion starts from a base state , and thus produces subsequent steps deterministically, though it may proceed indefinitely (and thus not terminate under strict evaluation), or it may consume more than it produces and thus become non- productive . Many functions that are traditionally analyzed as recursive can alternatively, and arguably more naturally, be interpreted as corecursive functions that are terminated at a given stage, for example recurrence relations such as the factorial\uff08\u9636\u4e58\uff09. Corecursion can produce both finite and infinite data structures as results, and may employ self-referential data structures. Corecursion is often used in conjunction with lazy evaluation , to produce only a finite subset of a potentially infinite structure (rather than trying to produce an entire infinite structure at once). Corecursion is a particularly important concept in functional programming , where corecursion and codata allow total languages to work with infinite data structures. NOTE : python\u7684generator\u5c31\u662fCorecursion\u7684\u6700\u597d\u7684\u4f8b\u5b50\u3002","title":"Corecursion"},{"location":"Guide/Induction-and-Recursion/Recursion/Corecursion/#examples","text":"Corecursion can be understood by contrast with recursion, which is more familiar. While corecursion is primarily of interest in functional programming, it can be illustrated using imperative programming, which is done below using the generator facility in Python. In these examples local variables are used, and assigned values imperatively (destructively), though these are not necessary in corecursion in pure functional programming. In pure functional programming, rather than assigning to local variables , these computed values form an invariable sequence, and prior values are accessed by self-reference (later values in the sequence reference earlier values in the sequence to be computed). The assignments simply express this in the imperative paradigm and explicitly specify where the computations happen, which serves to clarify the exposition.","title":"Examples"},{"location":"Guide/Induction-and-Recursion/Recursion/Corecursion/#factorial","text":"A classic example of recursion is computing the factorial \uff08\u9636\u4e58\uff09, which is defined recursively by 0! := 1 and n! := n \u00d7 (n - 1)! . To recursively compute its result on a given input, a recursive function calls (a copy of) itself with a different (\"smaller\" in some way) input and uses the result of this call to construct its result. The recursive call does the same, unless the base case has been reached. Thus a call stack develops in the process. For example, to compute fac(3) , this recursively calls in turn fac(2) , fac(1) , fac(0) (\"winding up\" the stack), at which point recursion terminates with fac(0) = 1 , and then the stack unwinds in reverse order and the results are calculated on the way back along the call stack to the initial call frame fac(3) that uses the result of fac(2) = 2 to calculate the final result as 3 \u00d7 2 = 3 \u00d7 fac(2) =: fac(3) and finally return fac(3) = 6 . In this example a function returns a single value. This stack unwinding can be explicated, defining the factorial corecursively , as an iterator , where one starts with the case of $ 1=:0! $, then from this starting value constructs factorial values for increasing numbers 1, 2, 3... as in the above recursive definition with \"time arrow\" reversed, as it were, by reading it backwards as $ n!\\times (n+1)=:(n+1)! $. The corecursive algorithm thus defined produces a stream of all factorials. This may be concretely implemented as a generator . Symbolically, noting that computing next factorial value requires keeping track of both n and f (a previous factorial value), this can be represented as: $ n,f=(0,1):(n+1,f\\times (n+1)) $ In Python, a recursive factorial function can be defined as: def factorial ( n ): if n == 0 : return 1 else : return n * factorial ( n - 1 ) This could then be called for example as factorial(5) to compute 5! . A corresponding corecursive generator can be defined as: def factorials (): n , f = 0 , 1 while True : yield f n , f = n + 1 , f * ( n + 1 ) This generates an infinite stream of factorials in order; a finite portion of it can be produced by: def n_factorials ( k ): n , f = 0 , 1 while n <= k : yield f n , f = n + 1 , f * ( n + 1 ) This could then be called to produce the factorials up to 5! via: for f in n_factorials ( 5 ): print ( f ) If we're only interested in a certain factorial, just the last value can be taken, or we can fuse the production and the access into one function, def nth_factorial ( k ): n , f = 0 , 1 while n < k : n , f = n + 1 , f * ( n + 1 ) yield f As can be readily seen here, this is practically equivalent (just by substituting return for the only yield there) to the accumulator argument technique for tail recursion , unwound into an explicit loop. Thus it can be said that the concept of corecursion is an explication of the embodiment of iterative computation processes by recursive definitions, where applicable. \u56e0\u6b64\uff0c\u53ef\u4ee5\u8fd9\u6837\u8bf4\uff0c\u534f\u9012\u5f52\u7684\u6982\u5ff5\u662f\u901a\u8fc7\u9012\u5f52\u5b9a\u4e49\u6765\u89e3\u91ca\u8fed\u4ee3\u8ba1\u7b97\u8fc7\u7a0b\u7684\u4f53\u73b0\u3002","title":"Factorial"},{"location":"Guide/Induction-and-Recursion/Recursion/Corecursion/#fibonacci-sequence","text":"In the same way, the Fibonacci sequence can be represented as: $ a,b=(0,1):(b,a+b) $ Note that because the Fibonacci sequence is a recurrence relation of order 2, the corecursive relation must track two successive terms, with the $ (b,-) $ corresponding to shift forward by one step, and the $ (-,a+b) $ corresponding to computing the next term. This can then be implemented as follows (using parallel assignment ): def fibonacci_sequence (): a , b = 0 , 1 while True : yield a a , b = b , a + b In Haskell, map fst ( ( \\ ( a , b ) -> ( b , a + b )) ` iterate ` ( 0 , 1 ) )","title":"Fibonacci sequence"},{"location":"Guide/Induction-and-Recursion/Recursion/Corecursion/#tree-traversal","text":"Tree traversal via a depth-first approach is a classic example of recursion . Dually, breadth-first traversal can very naturally be implemented via corecursion . Without using recursion or corecursion specifically, one may traverse a tree by starting at the root node , placing its child nodes in a data structure , then iterating by removing node after node from the data structure while placing each removed node's children back into that data structure.[ b] If the data structure is a stack (LIFO), this yields depth-first traversal , and if the data structure is a queue (FIFO), this yields breadth-first traversal . NOTE: \u5728\u4e0d\u4f7f\u7528recursion\u6216\u8005corecursion\u7684\u65f6\u5019\uff0c\u6211\u4eec\u5982\u679c\u60f3\u8981\u904d\u5386\u4e00\u68f5\u6811\uff0c\u5219\u9700\u8981\u501f\u52a9\u4e8e\u4e00\u4e2adata structure\u6765\u5b9e\u73b0\uff1b Using recursion , a (post-order)[ c] depth-first traversal can be implemented by starting at the root node and recursively traversing each child subtree in turn (the subtree based at each child node) \u2013 the second child subtree does not start processing until the first child subtree is finished. Once a leaf node is reached or the children of a branch node have been exhausted, the node itself is visited (e.g., the value of the node itself is outputted). In this case, the call stack (of the recursive functions ) acts as the stack that is iterated over. Using corecursion , a breadth-first traversal can be implemented by starting at the root node, outputting its value,[ d] then breadth-first traversing the subtrees \u2013 i.e., passing on the whole list of subtrees to the next step (not a single subtree, as in the recursive approach) \u2013 at the next step outputting the value of all of their root nodes, then passing on their child subtrees, etc.[ e] In this case the generator function , indeed the output sequence itself, acts as the queue . As in the factorial example (above), where the auxiliary information of the index (which step one was at, n ) was pushed forward, in addition to the actual output of n !, in this case the auxiliary information of the remaining subtrees is pushed forward, in addition to the actual output. Symbolically: $ v,t=([],[FullTree]):(RootValues(t),ChildTrees(t)) $","title":"Tree traversal"},{"location":"Guide/Induction-and-Recursion/Recursion/Recurrence-relation/","text":"Recurrence relation # \u201crecurrence relation\u201d\u5373\u201c\u9012\u5f52\u5173\u7cfb\u201d\uff0c\u201c\u9012\u5f52\u65b9\u7a0b\u201d\uff0c\u5b83\u662f\u4e00\u4e2a\u6570\u5b66\u6982\u5ff5\u3002\u5728 Discrete Mathematics and Its Applications \u7684chapter 4 advanced counting techniques\u4e2d\u5bf9\u5b83\u8fdb\u884c\u4e86\u4ecb\u7ecd\u3002 \u201crecurrence relation\u201d\u6240\u63cf\u8ff0\u7684relation\u662f \u79bb\u6563 \u7684\u3002 \u7ef4\u57fa\u767e\u79d1 Recurrence relation # In mathematics , a recurrence relation is an equation that recursively defines a sequence or multidimensional array of values, once one or more initial terms are given; each further term of the sequence or array is defined as a function of the preceding terms. NOTE: \u663e\u7136\uff0crecurrence relation\u662f\u4e00\u4e2a\u7684 recursive definition \u3002 The term difference equation sometimes (and for the purposes of this article) refers to a specific type of recurrence relation . However, \"difference equation\" is frequently used to refer to any recurrence relation. Definition # NOTE: \u539f\u6587\u7684\u8fd9\u4e00\u6bb5\u975e\u5e38\u96be\u61c2 Examples # Factorial # The factorial is defined by the recurrence relation $ n!=n(n-1)!\\quad {\\text{for}}\\quad n>0, $ and the initial condition $ 0!=1. $ Logistic map # Fibonacci numbers # Solving # NOTE: \u7ed9\u5b9a\u4e00\u4e2arecurrence relation\uff0c\u5982\u4f55\u6c42\u89e3\u51fa\u5b83\u7684\u901a\u7528\u8868\u8fbe\u5f0f\uff0c\u8fd9\u662f\u672c\u8282\u6240\u8ba8\u8bba\u7684\u95ee\u9898\u3002 Applications # Computer science # Recurrence relations are also of fundamental importance in analysis of algorithms . TODO: \u6dfb\u52a0\u94fe\u63a5\u5230\u5de5\u7a0b algorithm \u7684analysis of algorithm\u7ae0\u8282\u3002","title":"Recurrence-relation"},{"location":"Guide/Induction-and-Recursion/Recursion/Recurrence-relation/#recurrence-relation","text":"\u201crecurrence relation\u201d\u5373\u201c\u9012\u5f52\u5173\u7cfb\u201d\uff0c\u201c\u9012\u5f52\u65b9\u7a0b\u201d\uff0c\u5b83\u662f\u4e00\u4e2a\u6570\u5b66\u6982\u5ff5\u3002\u5728 Discrete Mathematics and Its Applications \u7684chapter 4 advanced counting techniques\u4e2d\u5bf9\u5b83\u8fdb\u884c\u4e86\u4ecb\u7ecd\u3002 \u201crecurrence relation\u201d\u6240\u63cf\u8ff0\u7684relation\u662f \u79bb\u6563 \u7684\u3002","title":"Recurrence relation"},{"location":"Guide/Induction-and-Recursion/Recursion/Recurrence-relation/#recurrence-relation_1","text":"In mathematics , a recurrence relation is an equation that recursively defines a sequence or multidimensional array of values, once one or more initial terms are given; each further term of the sequence or array is defined as a function of the preceding terms. NOTE: \u663e\u7136\uff0crecurrence relation\u662f\u4e00\u4e2a\u7684 recursive definition \u3002 The term difference equation sometimes (and for the purposes of this article) refers to a specific type of recurrence relation . However, \"difference equation\" is frequently used to refer to any recurrence relation.","title":"\u7ef4\u57fa\u767e\u79d1Recurrence relation"},{"location":"Guide/Induction-and-Recursion/Recursion/Recurrence-relation/#definition","text":"NOTE: \u539f\u6587\u7684\u8fd9\u4e00\u6bb5\u975e\u5e38\u96be\u61c2","title":"Definition"},{"location":"Guide/Induction-and-Recursion/Recursion/Recurrence-relation/#examples","text":"","title":"Examples"},{"location":"Guide/Induction-and-Recursion/Recursion/Recurrence-relation/#factorial","text":"The factorial is defined by the recurrence relation $ n!=n(n-1)!\\quad {\\text{for}}\\quad n>0, $ and the initial condition $ 0!=1. $","title":"Factorial"},{"location":"Guide/Induction-and-Recursion/Recursion/Recurrence-relation/#logistic-map","text":"","title":"Logistic map"},{"location":"Guide/Induction-and-Recursion/Recursion/Recurrence-relation/#fibonacci-numbers","text":"","title":"Fibonacci numbers"},{"location":"Guide/Induction-and-Recursion/Recursion/Recurrence-relation/#solving","text":"NOTE: \u7ed9\u5b9a\u4e00\u4e2arecurrence relation\uff0c\u5982\u4f55\u6c42\u89e3\u51fa\u5b83\u7684\u901a\u7528\u8868\u8fbe\u5f0f\uff0c\u8fd9\u662f\u672c\u8282\u6240\u8ba8\u8bba\u7684\u95ee\u9898\u3002","title":"Solving"},{"location":"Guide/Induction-and-Recursion/Recursion/Recurrence-relation/#applications","text":"","title":"Applications"},{"location":"Guide/Induction-and-Recursion/Recursion/Recurrence-relation/#computer-science","text":"Recurrence relations are also of fundamental importance in analysis of algorithms . TODO: \u6dfb\u52a0\u94fe\u63a5\u5230\u5de5\u7a0b algorithm \u7684analysis of algorithm\u7ae0\u8282\u3002","title":"Computer science"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/","text":"Recursion (computer science) # \u5728 Recursion \u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u63a5\u89e6\u4e86recursion \u7684\u6982\u5ff5\uff0c\u672c\u6587\u5c06\u5206\u6790computer science\u4e2d\u7684recursion\u3002 \u7ef4\u57fa\u767e\u79d1 Recursion (computer science) # Recursion in computer science is a method of solving a problem where the solution depends on solutions to smaller instances of the same problem (as opposed to iteration ). The approach can be applied to many types of problems, and recursion is one of the central ideas of computer science. The power of recursion evidently lies in the possibility of defining an infinite\uff08\u65e0\u9650\u7684\uff09 set of objects by a finite\uff08\u6709\u9650\u7684\uff09 statement. In the same manner, an infinite number of computations can be described by a finite recursive program, even if this program contains no explicit repetitions. \u2014\u2009 Niklaus Wirth , Algorithms + Data Structures = Programs , 1976 NOTE: \u7ef4\u57fa\u767e\u79d1 Recursion \u662f\u4ece\u5b9a\u4e49\uff08\u5982\u4f55\u8fdb\u884c\u9012\u5f52\u5b9a\u4e49\uff0c\u53c2\u89c1\u7ef4\u57fa\u767e\u79d1 Recursive definition \uff09\u7684\u89d2\u5ea6\u6765\u63cf\u8ff0\u9012\u5f52\uff0c\u7ef4\u57fa\u767e\u79d1 Recursion (computer science) \u4e2d\uff0c\u662f\u4ece\u89e3\u51b3\u95ee\u9898\u7684\u89d2\u5ea6\uff08\u5982\u4f55\u7f16\u7801\u5b9e\u73b0\uff09\u6765\u63cf\u8ff0\u9012\u5f52\uff0c\u6b63\u5982\u5b83\u7684\u5f00\u5934\u6240\u8ff0\uff1a This article is about recursive approaches to solving problems. NOTE: \u4ecefinite\uff08\u6709\u9650\u7684\uff09 statement\u5230 infinite\uff08\u65e0\u9650\u7684\uff09\uff0c\u8fd9\u6b63\u662frecursion\u7684\u5f3a\u5927\u6240\u5728\uff1b Most computer programming languages support recursion by allowing a function to call itself from within its own code. Some functional programming languages do not define any looping constructs but rely solely on recursion to repeatedly call code. Computability theory proves that these recursive-only languages are Turing complete ; they are as computationally powerful as Turing complete imperative languages, meaning they can solve the same kinds of problems as imperative languages even without iterative control structures such as while and for . Recursive functions and algorithms # A common computer programming tactic is to divide a problem into sub-problems of the same type as the original, solve those sub-problems, and combine the results. This is often referred to as the divide-and-conquer method ; when combined with a lookup table that stores the results of solving sub-problems (to avoid solving them repeatedly and incurring extra computation time), it can be referred to as dynamic programming or memoization . NOTE: TODO \u9700\u8981\u6dfb\u52a0\u5de5\u7a0b algorithm \u4e2d\uff0c\u5173\u4e8erecursion\u548cdynamic programming\u7684\u6bd4\u8f83\u3002 A recursive function definition has one or more base cases , meaning input(s) for which the function produces a result trivially (without recurring), and one or more recursive cases , meaning input(s) for which the program recurs\uff08\u9012\u5f52\uff0c\u91cd\u73b0\uff0c\u91cd\u590d\uff09 (calls itself). For example, the factorial function can be defined recursively by the equations 0! = 1 and, for all n > 0, n ! = n ( n \u2212 1)!. Neither equation by itself constitutes a complete definition; the first is the base case, and the second is the recursive case. Because the base case breaks the chain of recursion, it is sometimes also called the \"terminating case\". The job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a properly designed recursive function, with each recursive call, the input problem must be simplified in such a way that eventually the base case must be reached. (Functions that are not intended to terminate under normal circumstances\u2014for example, some system and server processes \u2014are an exception to this.) Neglecting to write a base case, or testing for it incorrectly, can cause an infinite loop . For some functions (such as one that computes the series for e = 1/0! + 1/1! + \u00bd! + \u2153! + ...) there is not an obvious base case implied by the input data; for these one may add a parameter (such as the number of terms to be added, in our series example) to provide a 'stopping criterion' that establishes the base case . Such an example is more naturally treated by co-recursion , where successive terms in the output are the partial sums; this can be converted to a recursion by using the indexing parameter to say \"compute the *n*th term (*n*th partial sum)\". NOTE: \u5728\u9012\u5f52\u51fd\u6570\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u5165\u53c2\uff0c\u8fd9\u4e2a\u5165\u53c2\u5c31\u8868\u793a\u505c\u6b62\u6761\u4ef6\uff1b\u5173\u4e8eco-recursion\uff0c\u53c2\u89c1 Corecursion \u3002 Recursive data types # Many computer programs must process or generate an arbitrarily large quantity of data . Recursion is one technique for representing data whose exact size the programmer does not know: the programmer can specify this data with a self-referential definition. There are two types of self-referential definitions : inductive and coinductive definitions. Further information: Algebraic data type Inductively defined data # Main article: Recursive data type Similarly recursive definitions are often used to model the structure of expressions and statements in programming languages. Language designers often express grammars in a syntax such as Backus\u2013Naur form ; here is such a grammar, for a simple language of arithmetic expressions with multiplication and addition: <expr> ::= <number> | (<expr> * <expr>) | (<expr> + <expr>) This says that an expression is either a number, a product of two expressions, or a sum of two expressions. By recursively referring to expressions in the second and third lines, the grammar permits arbitrarily complex arithmetic expressions such as (5 * ((3 * 6) + 8)) , with more than one product or sum operation in a single expression. Coinductively defined data and corecursion # Main articles: Coinduction and Corecursion Types of recursion # Single recursion and multiple recursion # Recursion that only contains a single self-reference is known as single recursion , while recursion that contains multiple self-references is known as multiple recursion . Standard examples of single recursion include list traversal, such as in a linear search, or computing the factorial function, while standard examples of multiple recursion include tree traversal , such as in a depth-first search . Single recursion is often much more efficient than multiple recursion , and can generally be replaced by an iterative computation , running in linear time and requiring constant space. Multiple recursion , by contrast, may require exponential time and space, and is more fundamentally recursive, not being able to be replaced by iteration without an explicit stack . NOTE: \u901a\u8fc7Fibonacci\u548ctree traversal \u7684\u4f8b\u5b50\u5c31\u53ef\u4ee5\u9a8c\u8bc1\u4e0a\u9762\u8fd9\u6bb5\u8bdd NOTE: Multiple recursion\u7684\u590d\u6742\u6027 Multiple recursion can sometimes be converted to single recursion (and, if desired, thence to iteration). For example, while computing the Fibonacci sequence naively is multiple iteration, as each value requires two previous values , it can be computed by single recursion by passing two successive values as parameters. This is more naturally framed as corecursion , building up from the initial values , tracking at each step two successive values \u2013 see corecursion: examples . A more sophisticated example is using a threaded binary tree , which allows iterative tree traversal, rather than multiple recursion. NOTE : Fibonacci \u51fd\u6570\u7684\u8868\u8fbe\u5f0f\u4e2d\u5305\u542b\u4e86\u4e24\u4e2a\u9012\u5f52\u8c03\u7528\uff0c\u4f46\u662f\u6b63\u5982\u4e0a\u9762\u6240\u8bf4\u7684\uff1a it can be computed by single recursion by passing two successive values as parameters\uff1b\u8fd9\u6837\u5c31\u53ef\u4ee5\u5c06\u5b83\u8f6c\u6362\u4e3a\u4e00\u4e2atail recursion\u4e86\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u6d88\u9664\u6389tail recursion\uff0c\u4f7f\u7528iterative\u65b9\u6cd5\u6765\u5b9e\u73b0\u4e86\uff1b Indirect recursion # Main article: Mutual recursion Most basic examples of recursion , and most of the examples presented here, demonstrate direct recursion , in which a function calls itself. Indirect recursion occurs when a function is called not by itself but by another function that it called (either directly or indirectly). For example, if f calls f, that is direct recursion, but if f calls g which calls f, then that is indirect recursion of f. Chains of three or more functions are possible; for example, function 1 calls function 2, function 2 calls function 3, and function 3 calls function 1 again. Indirect recursion is also called mutual recursion , which is a more symmetric term, though this is simply a difference of emphasis, not a different notion. That is, if f calls g and then g calls f, which in turn calls g again, from the point of view of f alone, f is indirectly recursing, while from the point of view of g alone, it is indirectly recursing, while from the point of view of both, f and g are mutually recursing on each other. Similarly a set of three or more functions that call each other can be called a set of mutually recursive functions. Anonymous recursion # Main article: Anonymous recursion Recursion is usually done by explicitly calling a function by name. However, recursion can also be done via implicitly calling a function based on the current context, which is particularly useful for anonymous functions , and is known as anonymous recursion . Structural versus generative recursion # See also: Structural recursion Some authors classify recursion as either \" structural \" or \" generative \". The distinction is related to where a recursive procedure gets the data that it works on, and how it processes that data: [Functions that consume structured data ] typically decompose their arguments into their immediate structural components and then process those components. If one of the immediate components belongs to the same class of data as the input, the function is recursive. For that reason, we refer to these functions as (STRUCTURALLY) RECURSIVE FUNCTIONS. \u2014\u2009Felleisen, Findler, Flatt, and Krishnaurthi, How to Design Programs , 2001[ 4] Thus, the defining characteristic of a structurally recursive function is that the argument to each recursive call is the content of a field of the original input. Structural recursion includes nearly all tree traversals , including XML processing , binary tree creation and search , etc. By considering the algebraic structure of the natural numbers (that is, a natural number is either zero or the successor of a natural number), functions such as factorial may also be regarded as structural recursion . Generative recursion is the alternative: Many well-known recursive algorithms generate an entirely new piece of data from the given data and recur on it. HtDP ( How to Design Programs ) refers to this kind as generative recursion . Examples of generative recursion include: gcd , quicksort , binary search , mergesort , Newton's method , fractals , and adaptive integration . \u2014\u2009Matthias Felleisen, Advanced Functional Programming , 2002[ 5] This distinction is important in proving termination of a function. All structurally recursive functions on finite ( inductively defined ) data structures can easily be shown to terminate, via structural induction : intuitively, each recursive call receives a smaller piece of input data, until a base case is reached. Generatively recursive functions , in contrast, do not necessarily feed smaller input to their recursive calls, so proof of their termination is not necessarily as simple, and avoiding infinite loops requires greater care. These generatively recursive functions can often be interpreted as corecursive functions \u2013 each step generates the new data, such as successive approximation in Newton's method \u2013 and terminating this corecursion requires that the data eventually satisfy some condition, which is not necessarily guaranteed. In terms of loop variants , structural recursion is when there is an obvious loop variant, namely size or complexity, which starts off finite and decreases at each recursive step. By contrast, generative recursion is when there is not such an obvious loop variant , and termination depends on a function, such as \"error of approximation\" that does not necessarily decrease to zero, and thus termination is not guaranteed without further analysis. Recursive programs # Recursive procedures # Factorial # Greatest common divisor # The Euclidean algorithm , which computes the greatest common divisor of two integers, can be written recursively. Function definition*:* $ \\gcd(x,y)={\\begin{cases}x&{\\mbox{if }}y=0\\\\gcd(y,\\operatorname {remainder} (x,y))&{\\mbox{if }}y>0\\\\end{cases}} $ Pseudocode (recursive): function gcd is: input: integer x, integer y such that x > 0 and y >= 0 1. if y is 0, return x 2. otherwise, return [ gcd( y, (remainder of x/y) ) ] end gcd Recurrence relation for greatest common divisor, where $ x\\%y $ expresses the remainder of $ x/y $: $ \\gcd(x,y)=\\gcd(y,x\\%y) $ if $ y\\neq 0 $ $ \\gcd(x,0)=x $ Computing the recurrence relation for x = 27 and y = 9: gcd(27, 9) = gcd(9, 27% 9) = gcd(9, 0) = 9 The recursive program above is tail-recursive ; it is equivalent to an iterative algorithm , and the computation shown above shows the steps of evaluation that would be performed by a language that eliminates tail calls . Below is a version of the same algorithm using explicit iteration, suitable for a language that does not eliminate tail calls. By maintaining its state entirely in the variables x and y and using a looping construct, the program avoids making recursive calls and growing the call stack. Pseudocode (iterative): function gcd is: input: integer x, integer y such that x >= y and y >= 0 1. create new variable called remainder 2. begin loop 1. if y is zero, exit loop 2. set remainder to the remainder of x/y 3. set x to y 4. set y to remainder 5. repeat loop 3. return x end gcd The iterative algorithm requires a temporary variable, and even given knowledge of the Euclidean algorithm it is more difficult to understand the process by simple inspection, although the two algorithms are very similar in their steps. Towers of Hanoi # Main article: Towers of Hanoi The Towers of Hanoi is a mathematical puzzle whose solution illustrates recursion.[ 6] [ 7] There are three pegs which can hold stacks of disks of different diameters. A larger disk may never be stacked on top of a smaller. Starting with n disks on one peg, they must be moved to another peg one at a time. What is the smallest number of steps to move the stack? Function definition : $ \\operatorname {hanoi} (n)={\\begin{cases}1&{\\mbox{if }}n=1\\2\\cdot \\operatorname {hanoi} (n-1)+1&{\\mbox{if }}n>1\\\\end{cases}} $ Recurrence relation for hanoi : $ h_{n}=2h_{n-1}+1 $ $ h_{1}=1 $ Computing the recurrence relation for n = 4: hanoi(4) = 2*hanoi(3) + 1 = 2*(2*hanoi(2) + 1) + 1 = 2*(2*(2*hanoi(1) + 1) + 1) + 1 = 2*(2*(2*1 + 1) + 1) + 1 = 2*(2*(3) + 1) + 1 = 2*(7) + 1 = 15 Example implementations: Binary search # The binary search algorithm is a method of searching a sorted array for a single element by cutting the array in half with each recursive pass. The trick is to pick a midpoint near the center of the array, compare the data at that point with the data being searched and then responding to one of three possible conditions: the data is found at the midpoint, the data at the midpoint is greater than the data being searched for, or the data at the midpoint is less than the data being searched for. Recursion is used in this algorithm because with each pass a new array is created by cutting the old one in half. The binary search procedure is then called recursively, this time on the new (and smaller) array. Typically the array's size is adjusted by manipulating a beginning and ending index. The algorithm exhibits a logarithmic order of growth because it essentially divides the problem domain in half with each pass. Example implementation of binary search in C: /* Call binary_search with proper initial conditions. INPUT: data is an array of integers SORTED in ASCENDING order, toFind is the integer to search for, count is the total number of elements in the array OUTPUT: result of binary_search */ int search ( int * data , int toFind , int count ) { // Start = 0 (beginning index) // End = count - 1 (top index) return binary_search ( data , toFind , 0 , count - 1 ); } /* Binary Search Algorithm. INPUT: data is a array of integers SORTED in ASCENDING order, toFind is the integer to search for, start is the minimum array index, end is the maximum array index OUTPUT: position of the integer toFind within array data, -1 if not found */ int binary_search ( int * data , int toFind , int start , int end ) { //Get the midpoint. int mid = start + ( end - start ) / 2 ; //Integer division //Stop condition. if ( start > end ) return - 1 ; else if ( data [ mid ] == toFind ) //Found? return mid ; else if ( data [ mid ] > toFind ) //Data is greater than toFind, search lower half return binary_search ( data , toFind , start , mid - 1 ); else //Data is less than toFind, search upper half return binary_search ( data , toFind , mid + 1 , end ); } Recursive data structures (structural recursion) # Main article: Recursive data type An important application of recursion in computer science is in defining dynamic data structures such as lists and trees . Recursive data structures can dynamically grow to a theoretically infinite size in response to runtime requirements; in contrast, the size of a static array must be set at compile time. \" Recursive algorithms are particularly appropriate when the underlying problem or the data to be treated are defined in recursive terms.\"[ 9] The examples in this section illustrate what is known as \" structural recursion \". This term refers to the fact that the recursive procedures are acting on data that is defined recursively. As long as a programmer derives the template from a data definition, functions employ structural recursion. That is, the recursions in a function's body consume some immediate piece of a given compound value.[ 5] Linked lists # Main article: Linked list Below is a C definition of a linked list node structure. Notice especially how the node is defined in terms of itself. The \"next\" element of struct node is a pointer to another struct node , effectively creating a list type. struct node { int data ; // some integer data struct node * next ; // pointer to another struct node }; Because the struct node data structure is defined recursively , procedures that operate on it can be implemented naturally as recursive procedures . The list_print procedure defined below walks down the list until the list is empty (i.e., the list pointer has a value of NULL). For each node it prints the data element (an integer). In the C implementation, the list remains unchanged by the list_print procedure. void list_print ( struct node * list ) { if ( list != NULL ) // base case { printf ( \"%d \" , list -> data ); // print integer data followed by a space list_print ( list -> next ); // recursive call on the next node } } Binary trees # Main article: Binary tree Below is a simple definition for a binary tree node. Like the node for linked lists, it is defined in terms of itself, recursively. There are two self-referential pointers: left (pointing to the left sub-tree) and right (pointing to the right sub-tree). struct node { int data ; // some integer data struct node * left ; // pointer to the left subtree struct node * right ; // point to the right subtree }; Operations on the tree can be implemented using recursion. Note that because there are two self-referencing pointers (left and right), tree operations may require two recursive calls: // Test if tree_node contains i; return 1 if so, 0 if not. int tree_contains ( struct node * tree_node , int i ) { if ( tree_node == NULL ) return 0 ; // base case else if ( tree_node -> data == i ) return 1 ; else return tree_contains ( tree_node -> left , i ) || tree_contains ( tree_node -> right , i ); } At most two recursive calls will be made for any given call to tree_contains as defined above. // Inorder traversal: void tree_print ( struct node * tree_node ) { if ( tree_node != NULL ) { // base case tree_print ( tree_node -> left ); // go left printf ( \"%d \" , tree_node -> data ); // print the integer followed by a space tree_print ( tree_node -> right ); // go right } } 5 3 7 2 4 6 8 P(5) P(3) P(2) P(NULL) return printf(2) P(NULL) return printf(3) p(4) P(NULL) return printf(4) P(NULL) return \u5199\u9012\u5f52\u51fd\u6570\u7684\u6838\u5fc3\u5728\u4e8e\u628a\u6211\u9012\u5f52\u7684\u672c\u8d28\uff1a\u81ea\u9876\u5411\u4e0b\uff0c\u53ea\u6709\u5b50\u95ee\u9898\u90fd\u89e3\u4e86\uff0c\u624d\u80fd\u591f\u89e3\u4e0a\u4e00\u5c42\u7684\u95ee\u9898\u3002\u4f7f\u7528\u7cfb\u7edf\u5806\u6808\u6765\u5b9e\u73b0\u8be5\u8fc7\u7a0b\uff0c\u56e0\u4e3a\u7cfb\u7edf\u5806\u6808\u80fd\u591f\u4e0d\u65ad\u5730\u6309\u7167\u9012\u5f52\u7684\u987a\u5e8f\u8fdb\u884c\u5165\u6808\uff0c\u76f4\u5230\u8fbe\u5230\u6700\u5c0f\u7684\u5b50\u95ee\u9898\uff0c\u4ece\u800c\u5c06\u5b50\u95ee\u9898\u89e3\u51b3\uff0c\u7136\u540e\u51fa\u6808\uff0c\u7136\u540e\u89e3\u51b3\u4e0a\u4e00\u5c42\u5b50\u95ee\u9898\uff0c\u76f4\u81f3\u6700\u9876\u5c42\u7684\u95ee\u9898\u89e3\u51b3\u4e86\uff1b \u6bcf\u4e2a\u9012\u5f52\u8c03\u7528\u90fd\u662f\u4e00\u6761\u76f4\u7ebf\uff0c\u5982\u679c\u9012\u5f52\u51fd\u6570\u4e2d\uff0c\u51fa\u73b0\u4e86\u4e24\u6b21\u9012\u5f52\u8c03\u7528\uff0c\u5219\u5c31\u662f\u4e24\u6761\u7ebf\u4e86\uff1b \u5bf9\u4e8e\u6709\u9012\u5f52\u6027\u8d28\u7684\u95ee\u9898\u6216\u8005\u7ed3\u6784\uff0c\u6211\u4eec\u53ef\u4ee5\u6309\u7167\u4e0a\u8ff0\u9012\u5f52\u7684\u601d\u60f3\u53bb\u7f16\u5199\u7a0b\u5e8f\u3002\u5f53\u8c08\u53ca\u9700\u8981\u9a8c\u8bc1\u6216\u8005\u6a21\u62df\u9012\u5f52\u51fd\u6570\u7684\u6267\u884c\u8fc7\u7a0b\u7684\u65f6\u5019\uff0c\u5c31\u9700\u8981\u4ece\u76f8\u53cd\u7684\u65b9\u5411\u6765\u89e3\u51b3\u95ee\u9898\u4e86\uff0c\u6211\u4eec\u9700\u8981\u4ece\u5e95\u5411\u4e0a\u6765\u6267\u884c\u3002 Implementation issues # In actual implementation, rather than a pure recursive function (single check for base case, otherwise recursive step), a number of modifications may be made, for purposes of clarity or efficiency. These include: Wrapper function (at top) Short-circuiting\uff08\u7b80\u5316\uff09 the base case , aka \"Arm's-length recursion\" (at bottom) Hybrid algorithm (at bottom) \u2013 switching to a different algorithm once data is small enough On the basis of elegance, wrapper functions are generally approved, while short-circuiting the base case is frowned upon, particularly in academia. Hybrid algorithms are often used for efficiency, to reduce the overhead of recursion in small cases, and arm's-length recursion is a special case of this. Recursion versus iteration # Recursion and iteration are equally expressive: recursion can be replaced by iteration with an explicit call stack , while iteration can be replaced with tail recursion . Which approach is preferable depends on the problem under consideration and the language used. In imperative programming , iteration is preferred, particularly for simple recursion, as it avoids the overhead of function calls and call stack management, but recursion is generally used for multiple recursion . By contrast, in functional languages recursion is preferred, with tail recursion optimization leading to little overhead. Implementing an algorithm using iteration may not be easily achievable. For example, a factorial function may be implemented iteratively in C by assigning to an loop index variable and accumulator variable, rather than by passing arguments and returning values by recursion: unsigned int factorial ( unsigned int n ) { unsigned int product = 1 ; // empty product is 1 while ( n ) { product *= n ; -- n ; } return product ; } Multiply recursive problems # Multiply recursive problems are inherently recursive, because of prior state they need to track. One example is tree traversal as in depth-first search ; though both recursive and iterative methods are used,[ 19] they contrast with list traversal and linear search in a list, which is a singly recursive and thus naturally iterative method. Other examples include divide-and-conquer algorithms such as Quicksort , and functions such as the Ackermann function . All of these algorithms can be implemented iteratively with the help of an explicit stack , but the programmer effort involved in managing the stack, and the complexity of the resulting program, arguably outweigh any advantages of the iterative solution. Refactoring recursion # Recursive algorithms can be replaced with non-recursive counterparts.[ 20] . One method for replacing recursive algorithms is to simulate them using heap memory in place of stack memory .[ 21] An alternative is to develop a replacement algorithm entirely based on non-recursive methods, which can be challenging.[ 22] For example, recursive algorithms for matching wildcards , such as Rich Salz ' wildmat algorithm,[ 23] were once typical. Non-recursive algorithms for the same purpose, such as the Krauss matching wildcards algorithm , have been developed to avoid the drawbacks of recursion[ 24] and have improved only gradually based on techniques such as collecting tests and profiling performance.[ 25] Tail-recursive functions # Tail-recursive functions are functions in which all recursive calls are tail calls and hence do not build up any deferred operations. For example, the gcd function (shown again below) is tail-recursive. In contrast, the factorial function (also below) is not tail-recursive; because its recursive call is not in tail position, it builds up deferred multiplication operations that must be performed after the final recursive call completes. With a compiler or interpreter that treats tail-recursive calls as jumps rather than function calls , a tail-recursive function such as gcd will execute using constant space . Thus the program is essentially iterative, equivalent to using imperative language control structures like the \"for\" and \"while\" loops. Tail recursion : //INPUT: Integers x, y such that x >= y and y >= 0 int gcd ( int x , int y ) { if ( y == 0 ) return x ; else return gcd ( y , x % y ); } Augmenting recursion: //INPUT: n is an Integer such that n >= 0 int fact ( int n ) { if ( n == 0 ) return 1 ; else return n * fact ( n - 1 ); } The significance of tail recursion is that when making a tail-recursive call (or any tail call), the caller's return position need not be saved on the call stack ; when the recursive call returns, it will branch directly on the previously saved return position. Therefore, in languages that recognize this property of tail calls, tail recursion saves both space and time. Time-efficiency of recursive algorithms # The time efficiency of recursive algorithms can be expressed in a recurrence relation of Big O notation . They can (usually) then be simplified into a single Big-O term. Shortcut rule (master theorem) # Main article: Master theorem (analysis of algorithms) If the time-complexity of the function is in the form $ T(n)=a\\cdot T(n/b)+f(n) $ Then the Big O of the time-complexity is thus: If $ f(n)=O(n^{\\log _{b}a-\\epsilon }) $ for some constant $ \\epsilon >0 $, then $ T(n)=\\Theta (n^{\\log _{b}a}) $ If $ f(n)=\\Theta (n^{\\log _{b}a}) $, then $ T(n)=\\Theta (n^{\\log _{b}a}\\log n) $ If $ f(n)=\\Omega (n^{\\log _{b}a+\\epsilon }) $ for some constant $ \\epsilon >0 $, and if $ a\\cdot f(n/b)\\leq c\\cdot f(n) $ for some constant c < 1 and all sufficiently large n , then $ T(n)=\\Theta (f(n)) $ where a represents the number of recursive calls at each level of recursion, b represents by what factor smaller the input is for the next level of recursion (i.e. the number of pieces you divide the problem into), and f \u2009( n ) represents the work the function does independent of any recursion (e.g. partitioning, recombining) at each level of recursion.","title":"Recursion(computer-science)"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#recursion-computer-science","text":"\u5728 Recursion \u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u63a5\u89e6\u4e86recursion \u7684\u6982\u5ff5\uff0c\u672c\u6587\u5c06\u5206\u6790computer science\u4e2d\u7684recursion\u3002","title":"Recursion (computer science)"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#recursion-computer-science_1","text":"Recursion in computer science is a method of solving a problem where the solution depends on solutions to smaller instances of the same problem (as opposed to iteration ). The approach can be applied to many types of problems, and recursion is one of the central ideas of computer science. The power of recursion evidently lies in the possibility of defining an infinite\uff08\u65e0\u9650\u7684\uff09 set of objects by a finite\uff08\u6709\u9650\u7684\uff09 statement. In the same manner, an infinite number of computations can be described by a finite recursive program, even if this program contains no explicit repetitions. \u2014\u2009 Niklaus Wirth , Algorithms + Data Structures = Programs , 1976 NOTE: \u7ef4\u57fa\u767e\u79d1 Recursion \u662f\u4ece\u5b9a\u4e49\uff08\u5982\u4f55\u8fdb\u884c\u9012\u5f52\u5b9a\u4e49\uff0c\u53c2\u89c1\u7ef4\u57fa\u767e\u79d1 Recursive definition \uff09\u7684\u89d2\u5ea6\u6765\u63cf\u8ff0\u9012\u5f52\uff0c\u7ef4\u57fa\u767e\u79d1 Recursion (computer science) \u4e2d\uff0c\u662f\u4ece\u89e3\u51b3\u95ee\u9898\u7684\u89d2\u5ea6\uff08\u5982\u4f55\u7f16\u7801\u5b9e\u73b0\uff09\u6765\u63cf\u8ff0\u9012\u5f52\uff0c\u6b63\u5982\u5b83\u7684\u5f00\u5934\u6240\u8ff0\uff1a This article is about recursive approaches to solving problems. NOTE: \u4ecefinite\uff08\u6709\u9650\u7684\uff09 statement\u5230 infinite\uff08\u65e0\u9650\u7684\uff09\uff0c\u8fd9\u6b63\u662frecursion\u7684\u5f3a\u5927\u6240\u5728\uff1b Most computer programming languages support recursion by allowing a function to call itself from within its own code. Some functional programming languages do not define any looping constructs but rely solely on recursion to repeatedly call code. Computability theory proves that these recursive-only languages are Turing complete ; they are as computationally powerful as Turing complete imperative languages, meaning they can solve the same kinds of problems as imperative languages even without iterative control structures such as while and for .","title":"\u7ef4\u57fa\u767e\u79d1Recursion (computer science)"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#recursive-functions-and-algorithms","text":"A common computer programming tactic is to divide a problem into sub-problems of the same type as the original, solve those sub-problems, and combine the results. This is often referred to as the divide-and-conquer method ; when combined with a lookup table that stores the results of solving sub-problems (to avoid solving them repeatedly and incurring extra computation time), it can be referred to as dynamic programming or memoization . NOTE: TODO \u9700\u8981\u6dfb\u52a0\u5de5\u7a0b algorithm \u4e2d\uff0c\u5173\u4e8erecursion\u548cdynamic programming\u7684\u6bd4\u8f83\u3002 A recursive function definition has one or more base cases , meaning input(s) for which the function produces a result trivially (without recurring), and one or more recursive cases , meaning input(s) for which the program recurs\uff08\u9012\u5f52\uff0c\u91cd\u73b0\uff0c\u91cd\u590d\uff09 (calls itself). For example, the factorial function can be defined recursively by the equations 0! = 1 and, for all n > 0, n ! = n ( n \u2212 1)!. Neither equation by itself constitutes a complete definition; the first is the base case, and the second is the recursive case. Because the base case breaks the chain of recursion, it is sometimes also called the \"terminating case\". The job of the recursive cases can be seen as breaking down complex inputs into simpler ones. In a properly designed recursive function, with each recursive call, the input problem must be simplified in such a way that eventually the base case must be reached. (Functions that are not intended to terminate under normal circumstances\u2014for example, some system and server processes \u2014are an exception to this.) Neglecting to write a base case, or testing for it incorrectly, can cause an infinite loop . For some functions (such as one that computes the series for e = 1/0! + 1/1! + \u00bd! + \u2153! + ...) there is not an obvious base case implied by the input data; for these one may add a parameter (such as the number of terms to be added, in our series example) to provide a 'stopping criterion' that establishes the base case . Such an example is more naturally treated by co-recursion , where successive terms in the output are the partial sums; this can be converted to a recursion by using the indexing parameter to say \"compute the *n*th term (*n*th partial sum)\". NOTE: \u5728\u9012\u5f52\u51fd\u6570\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u5165\u53c2\uff0c\u8fd9\u4e2a\u5165\u53c2\u5c31\u8868\u793a\u505c\u6b62\u6761\u4ef6\uff1b\u5173\u4e8eco-recursion\uff0c\u53c2\u89c1 Corecursion \u3002","title":"Recursive functions and algorithms"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#recursive-data-types","text":"Many computer programs must process or generate an arbitrarily large quantity of data . Recursion is one technique for representing data whose exact size the programmer does not know: the programmer can specify this data with a self-referential definition. There are two types of self-referential definitions : inductive and coinductive definitions. Further information: Algebraic data type","title":"Recursive data types"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#inductively-defined-data","text":"Main article: Recursive data type Similarly recursive definitions are often used to model the structure of expressions and statements in programming languages. Language designers often express grammars in a syntax such as Backus\u2013Naur form ; here is such a grammar, for a simple language of arithmetic expressions with multiplication and addition: <expr> ::= <number> | (<expr> * <expr>) | (<expr> + <expr>) This says that an expression is either a number, a product of two expressions, or a sum of two expressions. By recursively referring to expressions in the second and third lines, the grammar permits arbitrarily complex arithmetic expressions such as (5 * ((3 * 6) + 8)) , with more than one product or sum operation in a single expression.","title":"Inductively defined data"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#coinductively-defined-data-and-corecursion","text":"Main articles: Coinduction and Corecursion","title":"Coinductively defined data and corecursion"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#types-of-recursion","text":"","title":"Types of recursion"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#single-recursion-and-multiple-recursion","text":"Recursion that only contains a single self-reference is known as single recursion , while recursion that contains multiple self-references is known as multiple recursion . Standard examples of single recursion include list traversal, such as in a linear search, or computing the factorial function, while standard examples of multiple recursion include tree traversal , such as in a depth-first search . Single recursion is often much more efficient than multiple recursion , and can generally be replaced by an iterative computation , running in linear time and requiring constant space. Multiple recursion , by contrast, may require exponential time and space, and is more fundamentally recursive, not being able to be replaced by iteration without an explicit stack . NOTE: \u901a\u8fc7Fibonacci\u548ctree traversal \u7684\u4f8b\u5b50\u5c31\u53ef\u4ee5\u9a8c\u8bc1\u4e0a\u9762\u8fd9\u6bb5\u8bdd NOTE: Multiple recursion\u7684\u590d\u6742\u6027 Multiple recursion can sometimes be converted to single recursion (and, if desired, thence to iteration). For example, while computing the Fibonacci sequence naively is multiple iteration, as each value requires two previous values , it can be computed by single recursion by passing two successive values as parameters. This is more naturally framed as corecursion , building up from the initial values , tracking at each step two successive values \u2013 see corecursion: examples . A more sophisticated example is using a threaded binary tree , which allows iterative tree traversal, rather than multiple recursion. NOTE : Fibonacci \u51fd\u6570\u7684\u8868\u8fbe\u5f0f\u4e2d\u5305\u542b\u4e86\u4e24\u4e2a\u9012\u5f52\u8c03\u7528\uff0c\u4f46\u662f\u6b63\u5982\u4e0a\u9762\u6240\u8bf4\u7684\uff1a it can be computed by single recursion by passing two successive values as parameters\uff1b\u8fd9\u6837\u5c31\u53ef\u4ee5\u5c06\u5b83\u8f6c\u6362\u4e3a\u4e00\u4e2atail recursion\u4e86\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u6d88\u9664\u6389tail recursion\uff0c\u4f7f\u7528iterative\u65b9\u6cd5\u6765\u5b9e\u73b0\u4e86\uff1b","title":"Single recursion and multiple recursion"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#indirect-recursion","text":"Main article: Mutual recursion Most basic examples of recursion , and most of the examples presented here, demonstrate direct recursion , in which a function calls itself. Indirect recursion occurs when a function is called not by itself but by another function that it called (either directly or indirectly). For example, if f calls f, that is direct recursion, but if f calls g which calls f, then that is indirect recursion of f. Chains of three or more functions are possible; for example, function 1 calls function 2, function 2 calls function 3, and function 3 calls function 1 again. Indirect recursion is also called mutual recursion , which is a more symmetric term, though this is simply a difference of emphasis, not a different notion. That is, if f calls g and then g calls f, which in turn calls g again, from the point of view of f alone, f is indirectly recursing, while from the point of view of g alone, it is indirectly recursing, while from the point of view of both, f and g are mutually recursing on each other. Similarly a set of three or more functions that call each other can be called a set of mutually recursive functions.","title":"Indirect recursion"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#anonymous-recursion","text":"Main article: Anonymous recursion Recursion is usually done by explicitly calling a function by name. However, recursion can also be done via implicitly calling a function based on the current context, which is particularly useful for anonymous functions , and is known as anonymous recursion .","title":"Anonymous recursion"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#structural-versus-generative-recursion","text":"See also: Structural recursion Some authors classify recursion as either \" structural \" or \" generative \". The distinction is related to where a recursive procedure gets the data that it works on, and how it processes that data: [Functions that consume structured data ] typically decompose their arguments into their immediate structural components and then process those components. If one of the immediate components belongs to the same class of data as the input, the function is recursive. For that reason, we refer to these functions as (STRUCTURALLY) RECURSIVE FUNCTIONS. \u2014\u2009Felleisen, Findler, Flatt, and Krishnaurthi, How to Design Programs , 2001[ 4] Thus, the defining characteristic of a structurally recursive function is that the argument to each recursive call is the content of a field of the original input. Structural recursion includes nearly all tree traversals , including XML processing , binary tree creation and search , etc. By considering the algebraic structure of the natural numbers (that is, a natural number is either zero or the successor of a natural number), functions such as factorial may also be regarded as structural recursion . Generative recursion is the alternative: Many well-known recursive algorithms generate an entirely new piece of data from the given data and recur on it. HtDP ( How to Design Programs ) refers to this kind as generative recursion . Examples of generative recursion include: gcd , quicksort , binary search , mergesort , Newton's method , fractals , and adaptive integration . \u2014\u2009Matthias Felleisen, Advanced Functional Programming , 2002[ 5] This distinction is important in proving termination of a function. All structurally recursive functions on finite ( inductively defined ) data structures can easily be shown to terminate, via structural induction : intuitively, each recursive call receives a smaller piece of input data, until a base case is reached. Generatively recursive functions , in contrast, do not necessarily feed smaller input to their recursive calls, so proof of their termination is not necessarily as simple, and avoiding infinite loops requires greater care. These generatively recursive functions can often be interpreted as corecursive functions \u2013 each step generates the new data, such as successive approximation in Newton's method \u2013 and terminating this corecursion requires that the data eventually satisfy some condition, which is not necessarily guaranteed. In terms of loop variants , structural recursion is when there is an obvious loop variant, namely size or complexity, which starts off finite and decreases at each recursive step. By contrast, generative recursion is when there is not such an obvious loop variant , and termination depends on a function, such as \"error of approximation\" that does not necessarily decrease to zero, and thus termination is not guaranteed without further analysis.","title":"Structural versus generative recursion"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#recursive-programs","text":"","title":"Recursive programs"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#recursive-procedures","text":"","title":"Recursive procedures"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#factorial","text":"","title":"Factorial"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#greatest-common-divisor","text":"The Euclidean algorithm , which computes the greatest common divisor of two integers, can be written recursively. Function definition*:* $ \\gcd(x,y)={\\begin{cases}x&{\\mbox{if }}y=0\\\\gcd(y,\\operatorname {remainder} (x,y))&{\\mbox{if }}y>0\\\\end{cases}} $ Pseudocode (recursive): function gcd is: input: integer x, integer y such that x > 0 and y >= 0 1. if y is 0, return x 2. otherwise, return [ gcd( y, (remainder of x/y) ) ] end gcd Recurrence relation for greatest common divisor, where $ x\\%y $ expresses the remainder of $ x/y $: $ \\gcd(x,y)=\\gcd(y,x\\%y) $ if $ y\\neq 0 $ $ \\gcd(x,0)=x $ Computing the recurrence relation for x = 27 and y = 9: gcd(27, 9) = gcd(9, 27% 9) = gcd(9, 0) = 9 The recursive program above is tail-recursive ; it is equivalent to an iterative algorithm , and the computation shown above shows the steps of evaluation that would be performed by a language that eliminates tail calls . Below is a version of the same algorithm using explicit iteration, suitable for a language that does not eliminate tail calls. By maintaining its state entirely in the variables x and y and using a looping construct, the program avoids making recursive calls and growing the call stack. Pseudocode (iterative): function gcd is: input: integer x, integer y such that x >= y and y >= 0 1. create new variable called remainder 2. begin loop 1. if y is zero, exit loop 2. set remainder to the remainder of x/y 3. set x to y 4. set y to remainder 5. repeat loop 3. return x end gcd The iterative algorithm requires a temporary variable, and even given knowledge of the Euclidean algorithm it is more difficult to understand the process by simple inspection, although the two algorithms are very similar in their steps.","title":"Greatest common divisor"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#towers-of-hanoi","text":"Main article: Towers of Hanoi The Towers of Hanoi is a mathematical puzzle whose solution illustrates recursion.[ 6] [ 7] There are three pegs which can hold stacks of disks of different diameters. A larger disk may never be stacked on top of a smaller. Starting with n disks on one peg, they must be moved to another peg one at a time. What is the smallest number of steps to move the stack? Function definition : $ \\operatorname {hanoi} (n)={\\begin{cases}1&{\\mbox{if }}n=1\\2\\cdot \\operatorname {hanoi} (n-1)+1&{\\mbox{if }}n>1\\\\end{cases}} $ Recurrence relation for hanoi : $ h_{n}=2h_{n-1}+1 $ $ h_{1}=1 $ Computing the recurrence relation for n = 4: hanoi(4) = 2*hanoi(3) + 1 = 2*(2*hanoi(2) + 1) + 1 = 2*(2*(2*hanoi(1) + 1) + 1) + 1 = 2*(2*(2*1 + 1) + 1) + 1 = 2*(2*(3) + 1) + 1 = 2*(7) + 1 = 15 Example implementations:","title":"Towers of Hanoi"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#binary-search","text":"The binary search algorithm is a method of searching a sorted array for a single element by cutting the array in half with each recursive pass. The trick is to pick a midpoint near the center of the array, compare the data at that point with the data being searched and then responding to one of three possible conditions: the data is found at the midpoint, the data at the midpoint is greater than the data being searched for, or the data at the midpoint is less than the data being searched for. Recursion is used in this algorithm because with each pass a new array is created by cutting the old one in half. The binary search procedure is then called recursively, this time on the new (and smaller) array. Typically the array's size is adjusted by manipulating a beginning and ending index. The algorithm exhibits a logarithmic order of growth because it essentially divides the problem domain in half with each pass. Example implementation of binary search in C: /* Call binary_search with proper initial conditions. INPUT: data is an array of integers SORTED in ASCENDING order, toFind is the integer to search for, count is the total number of elements in the array OUTPUT: result of binary_search */ int search ( int * data , int toFind , int count ) { // Start = 0 (beginning index) // End = count - 1 (top index) return binary_search ( data , toFind , 0 , count - 1 ); } /* Binary Search Algorithm. INPUT: data is a array of integers SORTED in ASCENDING order, toFind is the integer to search for, start is the minimum array index, end is the maximum array index OUTPUT: position of the integer toFind within array data, -1 if not found */ int binary_search ( int * data , int toFind , int start , int end ) { //Get the midpoint. int mid = start + ( end - start ) / 2 ; //Integer division //Stop condition. if ( start > end ) return - 1 ; else if ( data [ mid ] == toFind ) //Found? return mid ; else if ( data [ mid ] > toFind ) //Data is greater than toFind, search lower half return binary_search ( data , toFind , start , mid - 1 ); else //Data is less than toFind, search upper half return binary_search ( data , toFind , mid + 1 , end ); }","title":"Binary search"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#recursive-data-structures-structural-recursion","text":"Main article: Recursive data type An important application of recursion in computer science is in defining dynamic data structures such as lists and trees . Recursive data structures can dynamically grow to a theoretically infinite size in response to runtime requirements; in contrast, the size of a static array must be set at compile time. \" Recursive algorithms are particularly appropriate when the underlying problem or the data to be treated are defined in recursive terms.\"[ 9] The examples in this section illustrate what is known as \" structural recursion \". This term refers to the fact that the recursive procedures are acting on data that is defined recursively. As long as a programmer derives the template from a data definition, functions employ structural recursion. That is, the recursions in a function's body consume some immediate piece of a given compound value.[ 5]","title":"Recursive data structures (structural recursion)"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#linked-lists","text":"Main article: Linked list Below is a C definition of a linked list node structure. Notice especially how the node is defined in terms of itself. The \"next\" element of struct node is a pointer to another struct node , effectively creating a list type. struct node { int data ; // some integer data struct node * next ; // pointer to another struct node }; Because the struct node data structure is defined recursively , procedures that operate on it can be implemented naturally as recursive procedures . The list_print procedure defined below walks down the list until the list is empty (i.e., the list pointer has a value of NULL). For each node it prints the data element (an integer). In the C implementation, the list remains unchanged by the list_print procedure. void list_print ( struct node * list ) { if ( list != NULL ) // base case { printf ( \"%d \" , list -> data ); // print integer data followed by a space list_print ( list -> next ); // recursive call on the next node } }","title":"Linked lists"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#binary-trees","text":"Main article: Binary tree Below is a simple definition for a binary tree node. Like the node for linked lists, it is defined in terms of itself, recursively. There are two self-referential pointers: left (pointing to the left sub-tree) and right (pointing to the right sub-tree). struct node { int data ; // some integer data struct node * left ; // pointer to the left subtree struct node * right ; // point to the right subtree }; Operations on the tree can be implemented using recursion. Note that because there are two self-referencing pointers (left and right), tree operations may require two recursive calls: // Test if tree_node contains i; return 1 if so, 0 if not. int tree_contains ( struct node * tree_node , int i ) { if ( tree_node == NULL ) return 0 ; // base case else if ( tree_node -> data == i ) return 1 ; else return tree_contains ( tree_node -> left , i ) || tree_contains ( tree_node -> right , i ); } At most two recursive calls will be made for any given call to tree_contains as defined above. // Inorder traversal: void tree_print ( struct node * tree_node ) { if ( tree_node != NULL ) { // base case tree_print ( tree_node -> left ); // go left printf ( \"%d \" , tree_node -> data ); // print the integer followed by a space tree_print ( tree_node -> right ); // go right } } 5 3 7 2 4 6 8 P(5) P(3) P(2) P(NULL) return printf(2) P(NULL) return printf(3) p(4) P(NULL) return printf(4) P(NULL) return \u5199\u9012\u5f52\u51fd\u6570\u7684\u6838\u5fc3\u5728\u4e8e\u628a\u6211\u9012\u5f52\u7684\u672c\u8d28\uff1a\u81ea\u9876\u5411\u4e0b\uff0c\u53ea\u6709\u5b50\u95ee\u9898\u90fd\u89e3\u4e86\uff0c\u624d\u80fd\u591f\u89e3\u4e0a\u4e00\u5c42\u7684\u95ee\u9898\u3002\u4f7f\u7528\u7cfb\u7edf\u5806\u6808\u6765\u5b9e\u73b0\u8be5\u8fc7\u7a0b\uff0c\u56e0\u4e3a\u7cfb\u7edf\u5806\u6808\u80fd\u591f\u4e0d\u65ad\u5730\u6309\u7167\u9012\u5f52\u7684\u987a\u5e8f\u8fdb\u884c\u5165\u6808\uff0c\u76f4\u5230\u8fbe\u5230\u6700\u5c0f\u7684\u5b50\u95ee\u9898\uff0c\u4ece\u800c\u5c06\u5b50\u95ee\u9898\u89e3\u51b3\uff0c\u7136\u540e\u51fa\u6808\uff0c\u7136\u540e\u89e3\u51b3\u4e0a\u4e00\u5c42\u5b50\u95ee\u9898\uff0c\u76f4\u81f3\u6700\u9876\u5c42\u7684\u95ee\u9898\u89e3\u51b3\u4e86\uff1b \u6bcf\u4e2a\u9012\u5f52\u8c03\u7528\u90fd\u662f\u4e00\u6761\u76f4\u7ebf\uff0c\u5982\u679c\u9012\u5f52\u51fd\u6570\u4e2d\uff0c\u51fa\u73b0\u4e86\u4e24\u6b21\u9012\u5f52\u8c03\u7528\uff0c\u5219\u5c31\u662f\u4e24\u6761\u7ebf\u4e86\uff1b \u5bf9\u4e8e\u6709\u9012\u5f52\u6027\u8d28\u7684\u95ee\u9898\u6216\u8005\u7ed3\u6784\uff0c\u6211\u4eec\u53ef\u4ee5\u6309\u7167\u4e0a\u8ff0\u9012\u5f52\u7684\u601d\u60f3\u53bb\u7f16\u5199\u7a0b\u5e8f\u3002\u5f53\u8c08\u53ca\u9700\u8981\u9a8c\u8bc1\u6216\u8005\u6a21\u62df\u9012\u5f52\u51fd\u6570\u7684\u6267\u884c\u8fc7\u7a0b\u7684\u65f6\u5019\uff0c\u5c31\u9700\u8981\u4ece\u76f8\u53cd\u7684\u65b9\u5411\u6765\u89e3\u51b3\u95ee\u9898\u4e86\uff0c\u6211\u4eec\u9700\u8981\u4ece\u5e95\u5411\u4e0a\u6765\u6267\u884c\u3002","title":"Binary trees"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#implementation-issues","text":"In actual implementation, rather than a pure recursive function (single check for base case, otherwise recursive step), a number of modifications may be made, for purposes of clarity or efficiency. These include: Wrapper function (at top) Short-circuiting\uff08\u7b80\u5316\uff09 the base case , aka \"Arm's-length recursion\" (at bottom) Hybrid algorithm (at bottom) \u2013 switching to a different algorithm once data is small enough On the basis of elegance, wrapper functions are generally approved, while short-circuiting the base case is frowned upon, particularly in academia. Hybrid algorithms are often used for efficiency, to reduce the overhead of recursion in small cases, and arm's-length recursion is a special case of this.","title":"Implementation issues"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#recursion-versus-iteration","text":"Recursion and iteration are equally expressive: recursion can be replaced by iteration with an explicit call stack , while iteration can be replaced with tail recursion . Which approach is preferable depends on the problem under consideration and the language used. In imperative programming , iteration is preferred, particularly for simple recursion, as it avoids the overhead of function calls and call stack management, but recursion is generally used for multiple recursion . By contrast, in functional languages recursion is preferred, with tail recursion optimization leading to little overhead. Implementing an algorithm using iteration may not be easily achievable. For example, a factorial function may be implemented iteratively in C by assigning to an loop index variable and accumulator variable, rather than by passing arguments and returning values by recursion: unsigned int factorial ( unsigned int n ) { unsigned int product = 1 ; // empty product is 1 while ( n ) { product *= n ; -- n ; } return product ; }","title":"Recursion versus iteration"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#multiply-recursive-problems","text":"Multiply recursive problems are inherently recursive, because of prior state they need to track. One example is tree traversal as in depth-first search ; though both recursive and iterative methods are used,[ 19] they contrast with list traversal and linear search in a list, which is a singly recursive and thus naturally iterative method. Other examples include divide-and-conquer algorithms such as Quicksort , and functions such as the Ackermann function . All of these algorithms can be implemented iteratively with the help of an explicit stack , but the programmer effort involved in managing the stack, and the complexity of the resulting program, arguably outweigh any advantages of the iterative solution.","title":"Multiply recursive problems"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#refactoring-recursion","text":"Recursive algorithms can be replaced with non-recursive counterparts.[ 20] . One method for replacing recursive algorithms is to simulate them using heap memory in place of stack memory .[ 21] An alternative is to develop a replacement algorithm entirely based on non-recursive methods, which can be challenging.[ 22] For example, recursive algorithms for matching wildcards , such as Rich Salz ' wildmat algorithm,[ 23] were once typical. Non-recursive algorithms for the same purpose, such as the Krauss matching wildcards algorithm , have been developed to avoid the drawbacks of recursion[ 24] and have improved only gradually based on techniques such as collecting tests and profiling performance.[ 25]","title":"Refactoring recursion"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#tail-recursive-functions","text":"Tail-recursive functions are functions in which all recursive calls are tail calls and hence do not build up any deferred operations. For example, the gcd function (shown again below) is tail-recursive. In contrast, the factorial function (also below) is not tail-recursive; because its recursive call is not in tail position, it builds up deferred multiplication operations that must be performed after the final recursive call completes. With a compiler or interpreter that treats tail-recursive calls as jumps rather than function calls , a tail-recursive function such as gcd will execute using constant space . Thus the program is essentially iterative, equivalent to using imperative language control structures like the \"for\" and \"while\" loops. Tail recursion : //INPUT: Integers x, y such that x >= y and y >= 0 int gcd ( int x , int y ) { if ( y == 0 ) return x ; else return gcd ( y , x % y ); } Augmenting recursion: //INPUT: n is an Integer such that n >= 0 int fact ( int n ) { if ( n == 0 ) return 1 ; else return n * fact ( n - 1 ); } The significance of tail recursion is that when making a tail-recursive call (or any tail call), the caller's return position need not be saved on the call stack ; when the recursive call returns, it will branch directly on the previously saved return position. Therefore, in languages that recognize this property of tail calls, tail recursion saves both space and time.","title":"Tail-recursive functions"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#time-efficiency-of-recursive-algorithms","text":"The time efficiency of recursive algorithms can be expressed in a recurrence relation of Big O notation . They can (usually) then be simplified into a single Big-O term.","title":"Time-efficiency of recursive algorithms"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion(computer-science)/#shortcut-rule-master-theorem","text":"Main article: Master theorem (analysis of algorithms) If the time-complexity of the function is in the form $ T(n)=a\\cdot T(n/b)+f(n) $ Then the Big O of the time-complexity is thus: If $ f(n)=O(n^{\\log _{b}a-\\epsilon }) $ for some constant $ \\epsilon >0 $, then $ T(n)=\\Theta (n^{\\log _{b}a}) $ If $ f(n)=\\Theta (n^{\\log _{b}a}) $, then $ T(n)=\\Theta (n^{\\log _{b}a}\\log n) $ If $ f(n)=\\Omega (n^{\\log _{b}a+\\epsilon }) $ for some constant $ \\epsilon >0 $, and if $ a\\cdot f(n/b)\\leq c\\cdot f(n) $ for some constant c < 1 and all sufficiently large n , then $ T(n)=\\Theta (f(n)) $ where a represents the number of recursive calls at each level of recursion, b represents by what factor smaller the input is for the next level of recursion (i.e. the number of pieces you divide the problem into), and f \u2009( n ) represents the work the function does independent of any recursion (e.g. partitioning, recombining) at each level of recursion.","title":"Shortcut rule (master theorem)"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion-analysis-and-representation/","text":"\u9012\u5f52\u51fd\u6570\u7684\u8868\u793a\u4e0e\u5206\u6790 # \u9012\u5f52\u51fd\u6570\u8c03\u7528\u8fc7\u7a0b\u7684\u8868\u793a # \u5bf9\u9012\u5f52\u51fd\u6570\u8fdb\u884c\u590d\u6742\u5ea6\u5206\u6790\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0c\u56e0\u4e3a\u6240\u6709\u4f7f\u7528\u9012\u5f52\u7684\u51fd\u6570\u90fd\u6d89\u53ca\u8fd9\u4e2a\u95ee\u9898\uff1b\u5176\u5b9e\u590d\u6742\u5ea6\u5206\u6790\u672c\u8d28\u4e0a\u6765\u8bf4\u662f\u7edf\u8ba1\u9012\u5f52\u51fd\u6570\u7684\u6267\u884c\u6b21\u6570\u3001\u6267\u884c\u6df1\u5ea6\u7b49\u95ee\u9898\uff0c\u6240\u4ee5\u5982\u679c\u5bf9\u9012\u5f52\u51fd\u6570\u7684\u8c03\u7528\u8fc7\u7a0b\u6709\u4e00\u4e2a\u76f4\u89c2\uff0c\u51c6\u786e\u5730\u63cf\u8ff0\u7684\u8bdd\uff0c\u90a3\u4e48\u5206\u6790\u5176\u9012\u5f52\u51fd\u6570\u7684\u590d\u6742\u5ea6\u4e5f\u4f1a\u975e\u5e38\u5bb9\u6613\uff0c\u76ee\u524d\u6d41\u884c\u7684\u8868\u793a\u65b9\u6cd5\u662f\uff1a\u9012\u5f52\u8c03\u7528\u6811\uff0c\u5982\u4e0b\u662f\u4e00\u4e9b\u4f7f\u7528\u9012\u5f52\u8c03\u7528\u6811\u6765\u8868\u793a\uff1a Write a program to print all permutations of a given string # \u6590\u6ce2\u90a3\u5951\u6570 # \u90a3\u5982\u4f55\u6765\u7406\u89e3**\u9012\u5f52\u8c03\u7528\u6811**\u5462\uff1f\u5b9e\u9645\u4e0a\uff0c \u9012\u5f52\u51fd\u6570**\u7684\u6267\u884c\u8fc7\u7a0b\u5e76\u4e0d\u4f1a\u663e\u793a\u7684\u6784\u9020\u51fa\u4e00\u4e2a**\u9012\u5f52\u8c03\u7528\u6811 \uff0c\u5b83\u53ea\u662f\u903b\u8f91\u4e0a\u5f62\u6210\u4e86\u4e00\u4e2a\u6811\uff0c\u4e0b\u9762\u5bf9\u6b64\u8fdb\u884c\u8be6\u7ec6\u7684\u5206\u6790\uff1a \u6211\u4eec\u77e5\u9053\uff0c\u51fd\u6570\u7684\u8c03\u7528\u8fc7\u7a0b\u6240\u4f7f\u7528\u7684\u662f Call stack \uff0c\u6bcf\u4e00\u6b21\u7684\u51fd\u6570\u8c03\u7528\u90fd\u4f1a\u5728 Call stack \u4e0apush\u4e00\u4e2a stack frame \uff08\u53c2\u89c1 Call stack \uff09\uff1b\u9012\u5f52\u51fd\u6570\u4e00\u76f4\u6267\u884c\u7684\u662f\u540c\u4e00\u4e2a\u51fd\u6570\uff0c\u6240\u4ee5\u5b83\u7684 Call stack \u4e2d\u7684**stack frame**\u7684\u6267\u884c\u903b\u8f91\u662f\u76f8\u540c\u7684\uff08\u5165\u53c2\u53ef\u80fd\u4e0d\u540c\uff09\uff1b\u5728\u9012\u5f52\u51fd\u6570\u6267\u884c\u7684\u8fc7\u7a0b\u4e2d\uff0c\u6bcf\u6267\u884c\u4e00\u6b21\u9012\u5f52\u8c03\u7528\u5c31\u5f80 Call stack \u4e0apush\uff08\u5165\u6808\uff09\u4e00\u4e2a stack frame \uff0c\u76f4\u5230\u67d0\u4e2a\u9012\u5f52\u51fd\u6570\u6267\u884c\u5230\u4e86base case\uff0c\u5219\u5b83\u4f1areturn\uff0c\u8fd9\u5c31\u610f\u5473\u4e2d\u5b83\u7684 **stack frame**\u4f1apop\uff08\u51fa\u6808\uff09\uff0c\u5219\u63a7\u5236\u4f1a\u8fd4\u56de\u5230\u8c03\u7528\u5b83\u7684\u51fd\u6570\uff1b\u663e\u7136\uff0c\u524d\u9762\u6240\u63cf\u8ff0\u7684\u8fc7\u7a0b\u5bf9\u5e94\u8fd9 \u6811\u7684\u6df1\u5ea6\u4f18\u5148\u904d\u5386 \uff0c\u6240\u4ee5\u6211\u4eec\u8bf4\uff1a\u9012\u5f52\u51fd\u6570\u7684\u6267\u884c\u8fc7\u7a0b\u662f\u5bf9\u9012\u5f52\u8c03\u7528\u6811\u8fdb\u884c\u6df1\u5ea6\u4f18\u5148\u904d\u5386\u3002 SUMMARY : \u4e0a\u9762\u6240\u63cf\u8ff0\u7684\uff1a\u51fd\u6570\u8c03\u7528-\u5165\u6808\uff0c\u51fd\u6570\u8fd4\u56de-\u51fa\u6808\uff0c\u975e\u5e38\u7c7b\u4f3c\u4e8e\u62ec\u53f7\u5339\u914d\u7b97\u6cd5\u4e2d\u7684\u6b63\u62ec\u53f7\u5165\u6808\uff0c\u53cd\u62ec\u53f7\u51fa\u6808\uff1b \u603b\u7684\u6765\u8bf4\uff0c\u9012\u5f52\u8c03\u7528\u6570\u662f\u5bf9\u9012\u5f52\u51fd\u6570\u7684 Call stack \u7684\u53ef\u89c6\u5316\u5206\u6790\uff1b \u5176\u5b9e\u6211\u4eec\u662f\u5b8c\u5168\u53ef\u4ee5\u6839\u636e**\u9012\u5f52\u51fd\u6570**\u753b\u51fa\u5bf9\u5e94\u7684**\u9012\u5f52\u8c03\u7528\u6811**\u7684\u3002\u6bd4\u5982 perm \u51fd\u6570\u5c31\u662f\u5178\u578b\u7684**\u6392\u5217\u6811**\uff0c\u4e8c\u5206\u641c\u7d22\u3001quike sort\u7b49\u5c31\u662f\u5178\u578b\u7684**\u4e8c\u53c9\u6811**\u3002 Matrix Chain Multiplication | DP-8 # \u9012\u5f52\u51fd\u6570\u7684\u590d\u6742\u6027\u5206\u6790 # Analysis of Algorithm | Set 4 (Solving Recurrences) # Lecture 20: Recursion Trees and the Master Method #","title":"Recursion-analysis-and-representation"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion-analysis-and-representation/#_1","text":"","title":"\u9012\u5f52\u51fd\u6570\u7684\u8868\u793a\u4e0e\u5206\u6790"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion-analysis-and-representation/#_2","text":"\u5bf9\u9012\u5f52\u51fd\u6570\u8fdb\u884c\u590d\u6742\u5ea6\u5206\u6790\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0c\u56e0\u4e3a\u6240\u6709\u4f7f\u7528\u9012\u5f52\u7684\u51fd\u6570\u90fd\u6d89\u53ca\u8fd9\u4e2a\u95ee\u9898\uff1b\u5176\u5b9e\u590d\u6742\u5ea6\u5206\u6790\u672c\u8d28\u4e0a\u6765\u8bf4\u662f\u7edf\u8ba1\u9012\u5f52\u51fd\u6570\u7684\u6267\u884c\u6b21\u6570\u3001\u6267\u884c\u6df1\u5ea6\u7b49\u95ee\u9898\uff0c\u6240\u4ee5\u5982\u679c\u5bf9\u9012\u5f52\u51fd\u6570\u7684\u8c03\u7528\u8fc7\u7a0b\u6709\u4e00\u4e2a\u76f4\u89c2\uff0c\u51c6\u786e\u5730\u63cf\u8ff0\u7684\u8bdd\uff0c\u90a3\u4e48\u5206\u6790\u5176\u9012\u5f52\u51fd\u6570\u7684\u590d\u6742\u5ea6\u4e5f\u4f1a\u975e\u5e38\u5bb9\u6613\uff0c\u76ee\u524d\u6d41\u884c\u7684\u8868\u793a\u65b9\u6cd5\u662f\uff1a\u9012\u5f52\u8c03\u7528\u6811\uff0c\u5982\u4e0b\u662f\u4e00\u4e9b\u4f7f\u7528\u9012\u5f52\u8c03\u7528\u6811\u6765\u8868\u793a\uff1a","title":"\u9012\u5f52\u51fd\u6570\u8c03\u7528\u8fc7\u7a0b\u7684\u8868\u793a"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion-analysis-and-representation/#write-a-program-to-print-all-permutations-of-a-given-string","text":"","title":"Write a program to print all permutations of a given string"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion-analysis-and-representation/#_3","text":"\u90a3\u5982\u4f55\u6765\u7406\u89e3**\u9012\u5f52\u8c03\u7528\u6811**\u5462\uff1f\u5b9e\u9645\u4e0a\uff0c \u9012\u5f52\u51fd\u6570**\u7684\u6267\u884c\u8fc7\u7a0b\u5e76\u4e0d\u4f1a\u663e\u793a\u7684\u6784\u9020\u51fa\u4e00\u4e2a**\u9012\u5f52\u8c03\u7528\u6811 \uff0c\u5b83\u53ea\u662f\u903b\u8f91\u4e0a\u5f62\u6210\u4e86\u4e00\u4e2a\u6811\uff0c\u4e0b\u9762\u5bf9\u6b64\u8fdb\u884c\u8be6\u7ec6\u7684\u5206\u6790\uff1a \u6211\u4eec\u77e5\u9053\uff0c\u51fd\u6570\u7684\u8c03\u7528\u8fc7\u7a0b\u6240\u4f7f\u7528\u7684\u662f Call stack \uff0c\u6bcf\u4e00\u6b21\u7684\u51fd\u6570\u8c03\u7528\u90fd\u4f1a\u5728 Call stack \u4e0apush\u4e00\u4e2a stack frame \uff08\u53c2\u89c1 Call stack \uff09\uff1b\u9012\u5f52\u51fd\u6570\u4e00\u76f4\u6267\u884c\u7684\u662f\u540c\u4e00\u4e2a\u51fd\u6570\uff0c\u6240\u4ee5\u5b83\u7684 Call stack \u4e2d\u7684**stack frame**\u7684\u6267\u884c\u903b\u8f91\u662f\u76f8\u540c\u7684\uff08\u5165\u53c2\u53ef\u80fd\u4e0d\u540c\uff09\uff1b\u5728\u9012\u5f52\u51fd\u6570\u6267\u884c\u7684\u8fc7\u7a0b\u4e2d\uff0c\u6bcf\u6267\u884c\u4e00\u6b21\u9012\u5f52\u8c03\u7528\u5c31\u5f80 Call stack \u4e0apush\uff08\u5165\u6808\uff09\u4e00\u4e2a stack frame \uff0c\u76f4\u5230\u67d0\u4e2a\u9012\u5f52\u51fd\u6570\u6267\u884c\u5230\u4e86base case\uff0c\u5219\u5b83\u4f1areturn\uff0c\u8fd9\u5c31\u610f\u5473\u4e2d\u5b83\u7684 **stack frame**\u4f1apop\uff08\u51fa\u6808\uff09\uff0c\u5219\u63a7\u5236\u4f1a\u8fd4\u56de\u5230\u8c03\u7528\u5b83\u7684\u51fd\u6570\uff1b\u663e\u7136\uff0c\u524d\u9762\u6240\u63cf\u8ff0\u7684\u8fc7\u7a0b\u5bf9\u5e94\u8fd9 \u6811\u7684\u6df1\u5ea6\u4f18\u5148\u904d\u5386 \uff0c\u6240\u4ee5\u6211\u4eec\u8bf4\uff1a\u9012\u5f52\u51fd\u6570\u7684\u6267\u884c\u8fc7\u7a0b\u662f\u5bf9\u9012\u5f52\u8c03\u7528\u6811\u8fdb\u884c\u6df1\u5ea6\u4f18\u5148\u904d\u5386\u3002 SUMMARY : \u4e0a\u9762\u6240\u63cf\u8ff0\u7684\uff1a\u51fd\u6570\u8c03\u7528-\u5165\u6808\uff0c\u51fd\u6570\u8fd4\u56de-\u51fa\u6808\uff0c\u975e\u5e38\u7c7b\u4f3c\u4e8e\u62ec\u53f7\u5339\u914d\u7b97\u6cd5\u4e2d\u7684\u6b63\u62ec\u53f7\u5165\u6808\uff0c\u53cd\u62ec\u53f7\u51fa\u6808\uff1b \u603b\u7684\u6765\u8bf4\uff0c\u9012\u5f52\u8c03\u7528\u6570\u662f\u5bf9\u9012\u5f52\u51fd\u6570\u7684 Call stack \u7684\u53ef\u89c6\u5316\u5206\u6790\uff1b \u5176\u5b9e\u6211\u4eec\u662f\u5b8c\u5168\u53ef\u4ee5\u6839\u636e**\u9012\u5f52\u51fd\u6570**\u753b\u51fa\u5bf9\u5e94\u7684**\u9012\u5f52\u8c03\u7528\u6811**\u7684\u3002\u6bd4\u5982 perm \u51fd\u6570\u5c31\u662f\u5178\u578b\u7684**\u6392\u5217\u6811**\uff0c\u4e8c\u5206\u641c\u7d22\u3001quike sort\u7b49\u5c31\u662f\u5178\u578b\u7684**\u4e8c\u53c9\u6811**\u3002","title":"\u6590\u6ce2\u90a3\u5951\u6570"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion-analysis-and-representation/#matrix-chain-multiplication-dp-8","text":"","title":"Matrix Chain Multiplication | DP-8"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion-analysis-and-representation/#_4","text":"","title":"\u9012\u5f52\u51fd\u6570\u7684\u590d\u6742\u6027\u5206\u6790"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion-analysis-and-representation/#analysis-of-algorithm-set-4-solving-recurrences","text":"","title":"Analysis of Algorithm | Set 4 (Solving Recurrences)"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion-analysis-and-representation/#lecture-20-recursion-trees-and-the-master-method","text":"","title":"Lecture 20: Recursion Trees and the Master Method"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion-and-iteration/","text":"Recursion and iteration # Recursion \u548c iteration \u662f\u4e24\u79cd**\u5b9e\u73b0**\u65b9\u5f0f\uff0crecursion\u672c\u8d28\u4e0a\u6765\u8bf4\u662f\u81ea\u9876\u5411\u4e0b\u7684\u4f7f\u7528 \u9012\u5f52\u5173\u7cfb \uff0citeration\u672c\u8d28\u4e0a\u6765\u8bf4\u662f\u81ea\u5e95\u5411\u4e0a\u5730\u4f7f\u7528 \u9012\u5f52\u5173\u7cfb \uff08dynamic programming\u3001greedy algorithm\u90fd\u662f\u57fa\u4e8eiteration\u7684\uff09\u3002\u672c\u6587\u5c31\u5bf9\u4e24\u8005\u8fdb\u884c\u63a2\u8ba8\u3002 Recursion VS iteration # \u4ece\u8fd0\u884c\u6210\u672c\u6bd4\u8f83\uff1a\u53c2\u89c1\u7ef4\u57fa\u767e\u79d1 Recursion (computer science) \u7b2c\u4e09\u6bb5\u3002 \u4e24\u8005\u7684\u76f8\u540c\u70b9\uff1a\u53c2\u89c1\uff1a \u7ef4\u57fa\u767e\u79d1 Recursion (computer science) \u7b2c\u4e8c\u6bb5\uff1a\u90fd\u80fd\u591f\u5b9e\u73b0\u201crepeatedly call code\u201d\u3002 \u7ef4\u57fa\u767e\u79d1 Iteration \uff0c\u5176\u4e2d\u7684 Relationship with recursion \u603b\u7ed3\u5730\u975e\u5e38\u597d\u3002 Recursin to iteration # \u5c3e\u9012\u5f52\u6d88\u9664 # \u5c3e\u9012\u5f52\u51fd\u6570\u53ef\u4ee5\u65e0\u9700\u501f\u52a9data structure\u5c31\u53ef\u4ee5\u6d88\u9664\uff0c\u5982fibnacci\u3002 \u53c2\u89c1\u7ef4\u57fa\u767e\u79d1 Tail call \u3002 using user stack to replace the call stack of recursion function # \u5176\u4ed6\u7684\u9012\u5f52\u51fd\u6570\u5982tree\u904d\u5386\u51fd\u6570\uff0c\u4e0d\u662f\u5c3e\u9012\u5f52\uff0c\u9700\u8981\u501f\u52a9\u4e8edata structure\u624d\u80fd\u591f\u6d88\u9664\u3002 \u5173\u4e8e\u6b64\u7684\u4e00\u4e2a\u5178\u578b\u7684\u4f8b\u5b50\u5c31\u662f Tree traversal \uff0c\u4ee5\u4e0b\u662f\u4ece\u8fd9\u6458\u6284\u7684code\uff1a recursion\u7684\u5b9e\u73b0 # preorder(node) if (node == null) return visit(node) preorder(node.left) preorder(node.right) iteration\u7684\u5b9e\u73b0 # iterativePreorder ( node ) if ( node == null ) return s \u2190 empty stack s . push ( node ) while ( not s . isEmpty ()) node \u2190 s . pop () visit ( node ) //right child is pushed first so that left is processed first if ( node . right \u2260 null ) s . push ( node . right ) if ( node . left \u2260 null ) s . push ( node . left ) recursion\u7684\u5b9e\u73b0 VS iteration\u7684\u5b9e\u73b0 # \u6b63\u5982\u5728\u300a recursion-analysis-and-representation.md \u300b\u4e2d\u6240\u63cf\u8ff0\u7684\uff1a \u51fd\u6570\u7684\u8c03\u7528\u8fc7\u7a0b\u6240\u4f7f\u7528\u7684\u662f Call stack \uff0c\u6bcf\u4e00\u6b21\u7684\u51fd\u6570\u8c03\u7528\u90fd\u4f1a\u5728 Call stack \u4e0apush\u4e00\u4e2a stack frame \uff08\u53c2\u89c1 Call stack \uff09\uff1b\u9012\u5f52\u51fd\u6570\u4e00\u76f4\u6267\u884c\u7684\u662f\u540c\u4e00\u4e2a\u51fd\u6570\uff0c\u6240\u4ee5\u5b83\u7684 Call stack \u4e2d\u7684**stack frame**\u7684\u6267\u884c\u903b\u8f91\u662f\u76f8\u540c\u7684\uff08\u5165\u53c2\u53ef\u80fd\u4e0d\u540c\uff09\uff1b\u5728\u9012\u5f52\u51fd\u6570\u6267\u884c\u7684\u8fc7\u7a0b\u4e2d\uff0c\u6bcf\u6267\u884c\u4e00\u6b21\u9012\u5f52\u8c03\u7528\u5c31\u5f80 Call stack \u4e0apush\uff08\u5165\u6808\uff09\u4e00\u4e2a stack frame \uff0c\u76f4\u5230\u67d0\u4e2a\u9012\u5f52\u51fd\u6570\u6267\u884c\u5230\u4e86base case\uff0c\u5219\u5b83\u4f1areturn\uff0c\u8fd9\u5c31\u610f\u5473\u4e2d\u5b83\u7684 **stack frame**\u4f1apop\uff08\u51fa\u6808\uff09\uff0c\u5219\u63a7\u5236\u4f1a\u8fd4\u56de\u5230\u8c03\u7528\u5b83\u7684\u51fd\u6570\uff1b\u663e\u7136\uff0c\u524d\u9762\u6240\u63cf\u8ff0\u7684\u8fc7\u7a0b\u5bf9\u5e94\u7740 \u6811\u7684\u6df1\u5ea6\u4f18\u5148\u904d\u5386 \uff0c\u6240\u4ee5\u6211\u4eec\u8bf4\uff1a\u9012\u5f52\u51fd\u6570\u7684\u6267\u884c\u8fc7\u7a0b\u662f\u5bf9\u9012\u5f52\u8c03\u7528\u6811\u8fdb\u884c\u6df1\u5ea6\u4f18\u5148\u904d\u5386\u3002 \u5728\u9012\u5f52\u7684\u5b9e\u73b0\u4e2d\uff0c\u51fd\u6570 preorder \u7684\u6267\u884c\u8fc7\u7a0b\u4e2d\uff0c\u4f1a\u4e0d\u65ad\u5730\u5f80 Call stack \u4e2dpush stack frame\uff0c\u8fd9\u4e9bstack frame\u4e2d\u5c31\u5305\u542b\u4e86\u4e00\u4e2a\u4e00\u4e2a\u7684**\u8282\u70b9**\u4fe1\u606f\uff0c\u76f4\u81f3\u9047\u5230base case\uff0c Call stack \u4e2d\u7684stack frame\u624d\u4f1a\u51fa\u6808\uff1b\u73b0\u5728\u53ea\u5206\u6790 preorder \u4e2d\u5173\u4e8e preorder \u7684\u8c03\u7528\uff0c\u5728\u6bcf\u4e00\u6b21\u8c03\u7528\u4e2d\u4f1a\u5148\u6267\u884c preorder(node.left) \uff0c\u8fd9\u8bf4\u660e preorder \u4f1a\u4f18\u5148\u5904\u7406 node.left \uff0c\u800c\u5c06 node.right \u7559\u5728stack frame\u4e2d\uff08\u51fd\u6570\u6682\u65f6\u6ca1\u6709\u6267\u884c\u5230\u8fd9\u91cc\uff0c\u5f85 preorder(node.left) \u8fd4\u56de\u540e\uff0c\u624d\u4f1a\u6267\u884c\u5230\u5b83\uff09\uff0c\u800c\u5f85\u63a7\u5236\u8fd4\u56de\u65f6\u624d\u8fdb\u884c\u5904\u7406\uff1b\u8fd9\u5c31\u662f\u4f7f\u7528call stack\u6765\u4fdd\u5b58deferred node\uff0c\u6b63\u5982 Tree traversal \u4e2d\u6240\u8ff0\uff1a Traversing a tree involves iterating over all nodes in some manner. Because from a given node there is more than one possible next node (it is not a linear data structure), then, assuming sequential computation (not parallel), some nodes must be deferred\u2014stored in some way for later visiting. This is often done via a stack (LIFO) or queue (FIFO). As a tree is a self-referential (recursively defined) data structure, traversal can be defined by recursion or, more subtly, corecursion , in a very natural and clear fashion; in these cases the deferred nodes are stored implicitly in the call stack . \u663e\u7136\uff0c\u5728\u4f7f\u7528iteration\u7684\u65f6\u5019\uff0c\u5c31\u9700\u8981\u7528\u6237\u5b9a\u4e49\u4e00\u4e2astack\u6765\u5145\u5f53calling stack\u5728recursion\u4e2d\u7684\u89d2\u8272\u4e86\uff1a\u5728recursion\u4e2d\uff0c preorder(node.left) \u7684\u6267\u884c\u5728 preorder(node.right) \u4e4b\u524d\uff0c\u8fd9\u5c31\u610f\u5473\u4e2d\uff0c\u4f18\u5148\u5904\u7406 node.left \uff0c\u6240\u4ee5\u5728iteration\u7684\u5b9e\u73b0\u4e2d\uff0c\u8981\u5148\u5165\u6808 node.right \uff0c\u518d\u5165\u6808 node.left \uff08\u56e0\u4e3astack\u662f\u540e\u8fdb\u5148\u51fa\uff09\uff0c\u4ece\u800c\u6a21\u62df\u4e86\u4e0a\u8ff0\u7cfb\u7edf\u8c03\u7528\u4e2d\u5c06 node.right \u4fdd\u5b58\u5728call stack\u4e2d\u3002 \u518d\u6765\u770b\u770b**\u4e2d\u5e8f\u904d\u5386** inorder(node) if (node == null) return inorder(node.left) visit(node) inorder(node.right) \u4e0d\u65ad\u5730\u5c06\u5de6\u8282\u70b9\u538b\u5165call stack\u4e2d\uff0c\u77e5\u9053\u5de6\u8282\u70b9\u4e3aNULL\uff0c\u624d\u8fd4\u56de\uff08\u51fa\u6808\uff09\uff0c\u624dvisit\u8282\u70b9\uff1b iterativeInorder(node) s \u2190 empty stack while (not s.isEmpty() or node \u2260 null) if (node \u2260 null) s.push(node) node \u2190 node.left else node \u2190 s.pop() visit(node) node \u2190 node.right \u4e2d\u5e8f\u904d\u5386\u7684recursion\u7248\u672c\u8981\u6bd4\u5148\u5e8f\u904d\u5386\u7684\u590d\u6742\u5730\u591a\u3002\u5176\u5b9e\u5bf9\u4ed6\u7684\u5206\u6790\u8fd8\u662f\u8981\u4ece\u4ececall stack\u5230user stack\u3002\u4e2d\u5e8f\u904d\u5386\u4e2d\uff0c\u5f53\u9012\u5f52\u51fd\u6570\u8fd4\u56de\u5230\u5b83\u7684\u4e3b\u8c03\u51fd\u6570\u7684\u65f6\u5019\uff0c\u8fd8\u9700\u8981\u8bbf\u95ee\u8282\u70b9 node \uff08\u5728call stack\u4e2d\u4fdd\u5b58\u4e86\u8fd9\u4e9b\u4fe1\u606f\uff09\uff0c\u4f46\u662f\u5728\u5148\u5e8f\u904d\u5386\u4e2d\uff0c\u5f53\u9012\u5f52\u51fd\u6570\u8fd4\u56de\u5230\u5b83\u7684\u4e3b\u8c03\u51fd\u6570\u7684\u65f6\u5019\uff0c\u65e0\u9700\u5728\u8bbf\u95ee\u8282\u70b9 node \u4e86\uff1b\u6240\u4ee5\u5728\u5148\u5e8f\u904d\u5386\u7684iteration\u7248\u672c\u4e2d\uff0c node \u8282\u70b9\u5728\u672c\u8f6e\u4f7f\u7528\u4e86\u4e4b\u540e\uff0c\u5c31\u65e0\u9700\u7ee7\u7eed\u7559\u5728user stack\u4e2d\u4e86\uff0c\u6240\u4ee5\u5728\u6bcf\u8f6e\u7684\u5faa\u73af\u5f00\u59cb\u7684\u65f6\u5019\uff0c\u5c31\u5c06\u5b83\u4eceuser stack\u4e2d\u53d6\u51fa\uff1b\u4f46\u662f\u4e2d\u5e8f\u904d\u5386\u7684iteration\u7248\u672c\u4e2d\uff0c\u5c31\u4e0d\u80fd\u591f\u8fd9\u6837\u4e86\uff0c\u53ea\u6709\u5f53node\u6ca1\u6709\u4e86left node\u540e\uff0c\u624d\u80fd\u591f\u5c06\u5b83\u4eceuser stack\u4e2d\u53d6\u51fa\uff1b user stack\u7684\u51fa\u6808\u5bf9\u5e94\u7740call stack\u4e2d\u7684\u4ece\u9012\u5f52\u51fd\u6570\u4e2d\u8fd4\u56de\uff0cuser stack\u4e2d\u8fdb\u6808\u5219\u5bf9\u5e94\u4e2d\u8c03\u7528\u9012\u5f52\u51fd\u6570\uff1b \u5bf9\u6bd4\u4e0a\u8ff0\u4ee3\u7801\uff0c\u53ef\u4ee5\u53d1\u73b0\uff0c\u5982\u4e0b\u4e24\u4e2a\u8bed\u53e5\u662f\u5728\u4e00\u8d77\u7684\uff1a node \u2190 s.pop() visit(node) \u5176\u5b9e\u8fd9\u662f\u4e00\u4e2a\u7406\u89e3\u95ee\u9898\u672c\u8d28\u7684\u6240\u5728\uff0c\u65e0\u8bba\u54ea\u79cd\u65b9\u5f0f\uff0c\u4ece\u6808\u4e2d\u53d6\u51fa\u5143\u7d20\uff0c\u7136\u540e\u8fdb\u884cvisit\uff0c\u4e0d\u540c\u7684\u662f\u6df1\u5ea6\u4f18\u5148\u5148\u5e8f\u904d\u5386\u662f\u5728\u6bcf\u6b21\u5148\u4ece\u6808\u4e2d\u53d6\u51fa\u5143\u7d20\u8fdb\u884cvisit\u3002\u6df1\u5ea6\u4f18\u5148\u7684\u4e2d\u5e8f\u904d\u5386\u5219\u662f\u5728\u5de6\u5b50\u6811\u90fd\u8bbf\u95ee\u5b8c\u4e86\u540e\u624d\u4ece\u6808\u4e2d\u53d6\u51fa\u5143\u7d20\u8fdb\u884cvisit\u3002","title":"Recursion-and-iteration"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion-and-iteration/#recursion-and-iteration","text":"Recursion \u548c iteration \u662f\u4e24\u79cd**\u5b9e\u73b0**\u65b9\u5f0f\uff0crecursion\u672c\u8d28\u4e0a\u6765\u8bf4\u662f\u81ea\u9876\u5411\u4e0b\u7684\u4f7f\u7528 \u9012\u5f52\u5173\u7cfb \uff0citeration\u672c\u8d28\u4e0a\u6765\u8bf4\u662f\u81ea\u5e95\u5411\u4e0a\u5730\u4f7f\u7528 \u9012\u5f52\u5173\u7cfb \uff08dynamic programming\u3001greedy algorithm\u90fd\u662f\u57fa\u4e8eiteration\u7684\uff09\u3002\u672c\u6587\u5c31\u5bf9\u4e24\u8005\u8fdb\u884c\u63a2\u8ba8\u3002","title":"Recursion and iteration"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion-and-iteration/#recursion-vs-iteration","text":"\u4ece\u8fd0\u884c\u6210\u672c\u6bd4\u8f83\uff1a\u53c2\u89c1\u7ef4\u57fa\u767e\u79d1 Recursion (computer science) \u7b2c\u4e09\u6bb5\u3002 \u4e24\u8005\u7684\u76f8\u540c\u70b9\uff1a\u53c2\u89c1\uff1a \u7ef4\u57fa\u767e\u79d1 Recursion (computer science) \u7b2c\u4e8c\u6bb5\uff1a\u90fd\u80fd\u591f\u5b9e\u73b0\u201crepeatedly call code\u201d\u3002 \u7ef4\u57fa\u767e\u79d1 Iteration \uff0c\u5176\u4e2d\u7684 Relationship with recursion \u603b\u7ed3\u5730\u975e\u5e38\u597d\u3002","title":"Recursion VS iteration"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion-and-iteration/#recursin-to-iteration","text":"","title":"Recursin to iteration"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion-and-iteration/#_1","text":"\u5c3e\u9012\u5f52\u51fd\u6570\u53ef\u4ee5\u65e0\u9700\u501f\u52a9data structure\u5c31\u53ef\u4ee5\u6d88\u9664\uff0c\u5982fibnacci\u3002 \u53c2\u89c1\u7ef4\u57fa\u767e\u79d1 Tail call \u3002","title":"\u5c3e\u9012\u5f52\u6d88\u9664"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion-and-iteration/#using-user-stack-to-replace-the-call-stack-of-recursion-function","text":"\u5176\u4ed6\u7684\u9012\u5f52\u51fd\u6570\u5982tree\u904d\u5386\u51fd\u6570\uff0c\u4e0d\u662f\u5c3e\u9012\u5f52\uff0c\u9700\u8981\u501f\u52a9\u4e8edata structure\u624d\u80fd\u591f\u6d88\u9664\u3002 \u5173\u4e8e\u6b64\u7684\u4e00\u4e2a\u5178\u578b\u7684\u4f8b\u5b50\u5c31\u662f Tree traversal \uff0c\u4ee5\u4e0b\u662f\u4ece\u8fd9\u6458\u6284\u7684code\uff1a","title":"using user stack to replace the call stack of recursion function"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion-and-iteration/#recursion","text":"preorder(node) if (node == null) return visit(node) preorder(node.left) preorder(node.right)","title":"recursion\u7684\u5b9e\u73b0"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion-and-iteration/#iteration","text":"iterativePreorder ( node ) if ( node == null ) return s \u2190 empty stack s . push ( node ) while ( not s . isEmpty ()) node \u2190 s . pop () visit ( node ) //right child is pushed first so that left is processed first if ( node . right \u2260 null ) s . push ( node . right ) if ( node . left \u2260 null ) s . push ( node . left )","title":"iteration\u7684\u5b9e\u73b0"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion-and-iteration/#recursion-vs-iteration_1","text":"\u6b63\u5982\u5728\u300a recursion-analysis-and-representation.md \u300b\u4e2d\u6240\u63cf\u8ff0\u7684\uff1a \u51fd\u6570\u7684\u8c03\u7528\u8fc7\u7a0b\u6240\u4f7f\u7528\u7684\u662f Call stack \uff0c\u6bcf\u4e00\u6b21\u7684\u51fd\u6570\u8c03\u7528\u90fd\u4f1a\u5728 Call stack \u4e0apush\u4e00\u4e2a stack frame \uff08\u53c2\u89c1 Call stack \uff09\uff1b\u9012\u5f52\u51fd\u6570\u4e00\u76f4\u6267\u884c\u7684\u662f\u540c\u4e00\u4e2a\u51fd\u6570\uff0c\u6240\u4ee5\u5b83\u7684 Call stack \u4e2d\u7684**stack frame**\u7684\u6267\u884c\u903b\u8f91\u662f\u76f8\u540c\u7684\uff08\u5165\u53c2\u53ef\u80fd\u4e0d\u540c\uff09\uff1b\u5728\u9012\u5f52\u51fd\u6570\u6267\u884c\u7684\u8fc7\u7a0b\u4e2d\uff0c\u6bcf\u6267\u884c\u4e00\u6b21\u9012\u5f52\u8c03\u7528\u5c31\u5f80 Call stack \u4e0apush\uff08\u5165\u6808\uff09\u4e00\u4e2a stack frame \uff0c\u76f4\u5230\u67d0\u4e2a\u9012\u5f52\u51fd\u6570\u6267\u884c\u5230\u4e86base case\uff0c\u5219\u5b83\u4f1areturn\uff0c\u8fd9\u5c31\u610f\u5473\u4e2d\u5b83\u7684 **stack frame**\u4f1apop\uff08\u51fa\u6808\uff09\uff0c\u5219\u63a7\u5236\u4f1a\u8fd4\u56de\u5230\u8c03\u7528\u5b83\u7684\u51fd\u6570\uff1b\u663e\u7136\uff0c\u524d\u9762\u6240\u63cf\u8ff0\u7684\u8fc7\u7a0b\u5bf9\u5e94\u7740 \u6811\u7684\u6df1\u5ea6\u4f18\u5148\u904d\u5386 \uff0c\u6240\u4ee5\u6211\u4eec\u8bf4\uff1a\u9012\u5f52\u51fd\u6570\u7684\u6267\u884c\u8fc7\u7a0b\u662f\u5bf9\u9012\u5f52\u8c03\u7528\u6811\u8fdb\u884c\u6df1\u5ea6\u4f18\u5148\u904d\u5386\u3002 \u5728\u9012\u5f52\u7684\u5b9e\u73b0\u4e2d\uff0c\u51fd\u6570 preorder \u7684\u6267\u884c\u8fc7\u7a0b\u4e2d\uff0c\u4f1a\u4e0d\u65ad\u5730\u5f80 Call stack \u4e2dpush stack frame\uff0c\u8fd9\u4e9bstack frame\u4e2d\u5c31\u5305\u542b\u4e86\u4e00\u4e2a\u4e00\u4e2a\u7684**\u8282\u70b9**\u4fe1\u606f\uff0c\u76f4\u81f3\u9047\u5230base case\uff0c Call stack \u4e2d\u7684stack frame\u624d\u4f1a\u51fa\u6808\uff1b\u73b0\u5728\u53ea\u5206\u6790 preorder \u4e2d\u5173\u4e8e preorder \u7684\u8c03\u7528\uff0c\u5728\u6bcf\u4e00\u6b21\u8c03\u7528\u4e2d\u4f1a\u5148\u6267\u884c preorder(node.left) \uff0c\u8fd9\u8bf4\u660e preorder \u4f1a\u4f18\u5148\u5904\u7406 node.left \uff0c\u800c\u5c06 node.right \u7559\u5728stack frame\u4e2d\uff08\u51fd\u6570\u6682\u65f6\u6ca1\u6709\u6267\u884c\u5230\u8fd9\u91cc\uff0c\u5f85 preorder(node.left) \u8fd4\u56de\u540e\uff0c\u624d\u4f1a\u6267\u884c\u5230\u5b83\uff09\uff0c\u800c\u5f85\u63a7\u5236\u8fd4\u56de\u65f6\u624d\u8fdb\u884c\u5904\u7406\uff1b\u8fd9\u5c31\u662f\u4f7f\u7528call stack\u6765\u4fdd\u5b58deferred node\uff0c\u6b63\u5982 Tree traversal \u4e2d\u6240\u8ff0\uff1a Traversing a tree involves iterating over all nodes in some manner. Because from a given node there is more than one possible next node (it is not a linear data structure), then, assuming sequential computation (not parallel), some nodes must be deferred\u2014stored in some way for later visiting. This is often done via a stack (LIFO) or queue (FIFO). As a tree is a self-referential (recursively defined) data structure, traversal can be defined by recursion or, more subtly, corecursion , in a very natural and clear fashion; in these cases the deferred nodes are stored implicitly in the call stack . \u663e\u7136\uff0c\u5728\u4f7f\u7528iteration\u7684\u65f6\u5019\uff0c\u5c31\u9700\u8981\u7528\u6237\u5b9a\u4e49\u4e00\u4e2astack\u6765\u5145\u5f53calling stack\u5728recursion\u4e2d\u7684\u89d2\u8272\u4e86\uff1a\u5728recursion\u4e2d\uff0c preorder(node.left) \u7684\u6267\u884c\u5728 preorder(node.right) \u4e4b\u524d\uff0c\u8fd9\u5c31\u610f\u5473\u4e2d\uff0c\u4f18\u5148\u5904\u7406 node.left \uff0c\u6240\u4ee5\u5728iteration\u7684\u5b9e\u73b0\u4e2d\uff0c\u8981\u5148\u5165\u6808 node.right \uff0c\u518d\u5165\u6808 node.left \uff08\u56e0\u4e3astack\u662f\u540e\u8fdb\u5148\u51fa\uff09\uff0c\u4ece\u800c\u6a21\u62df\u4e86\u4e0a\u8ff0\u7cfb\u7edf\u8c03\u7528\u4e2d\u5c06 node.right \u4fdd\u5b58\u5728call stack\u4e2d\u3002 \u518d\u6765\u770b\u770b**\u4e2d\u5e8f\u904d\u5386** inorder(node) if (node == null) return inorder(node.left) visit(node) inorder(node.right) \u4e0d\u65ad\u5730\u5c06\u5de6\u8282\u70b9\u538b\u5165call stack\u4e2d\uff0c\u77e5\u9053\u5de6\u8282\u70b9\u4e3aNULL\uff0c\u624d\u8fd4\u56de\uff08\u51fa\u6808\uff09\uff0c\u624dvisit\u8282\u70b9\uff1b iterativeInorder(node) s \u2190 empty stack while (not s.isEmpty() or node \u2260 null) if (node \u2260 null) s.push(node) node \u2190 node.left else node \u2190 s.pop() visit(node) node \u2190 node.right \u4e2d\u5e8f\u904d\u5386\u7684recursion\u7248\u672c\u8981\u6bd4\u5148\u5e8f\u904d\u5386\u7684\u590d\u6742\u5730\u591a\u3002\u5176\u5b9e\u5bf9\u4ed6\u7684\u5206\u6790\u8fd8\u662f\u8981\u4ece\u4ececall stack\u5230user stack\u3002\u4e2d\u5e8f\u904d\u5386\u4e2d\uff0c\u5f53\u9012\u5f52\u51fd\u6570\u8fd4\u56de\u5230\u5b83\u7684\u4e3b\u8c03\u51fd\u6570\u7684\u65f6\u5019\uff0c\u8fd8\u9700\u8981\u8bbf\u95ee\u8282\u70b9 node \uff08\u5728call stack\u4e2d\u4fdd\u5b58\u4e86\u8fd9\u4e9b\u4fe1\u606f\uff09\uff0c\u4f46\u662f\u5728\u5148\u5e8f\u904d\u5386\u4e2d\uff0c\u5f53\u9012\u5f52\u51fd\u6570\u8fd4\u56de\u5230\u5b83\u7684\u4e3b\u8c03\u51fd\u6570\u7684\u65f6\u5019\uff0c\u65e0\u9700\u5728\u8bbf\u95ee\u8282\u70b9 node \u4e86\uff1b\u6240\u4ee5\u5728\u5148\u5e8f\u904d\u5386\u7684iteration\u7248\u672c\u4e2d\uff0c node \u8282\u70b9\u5728\u672c\u8f6e\u4f7f\u7528\u4e86\u4e4b\u540e\uff0c\u5c31\u65e0\u9700\u7ee7\u7eed\u7559\u5728user stack\u4e2d\u4e86\uff0c\u6240\u4ee5\u5728\u6bcf\u8f6e\u7684\u5faa\u73af\u5f00\u59cb\u7684\u65f6\u5019\uff0c\u5c31\u5c06\u5b83\u4eceuser stack\u4e2d\u53d6\u51fa\uff1b\u4f46\u662f\u4e2d\u5e8f\u904d\u5386\u7684iteration\u7248\u672c\u4e2d\uff0c\u5c31\u4e0d\u80fd\u591f\u8fd9\u6837\u4e86\uff0c\u53ea\u6709\u5f53node\u6ca1\u6709\u4e86left node\u540e\uff0c\u624d\u80fd\u591f\u5c06\u5b83\u4eceuser stack\u4e2d\u53d6\u51fa\uff1b user stack\u7684\u51fa\u6808\u5bf9\u5e94\u7740call stack\u4e2d\u7684\u4ece\u9012\u5f52\u51fd\u6570\u4e2d\u8fd4\u56de\uff0cuser stack\u4e2d\u8fdb\u6808\u5219\u5bf9\u5e94\u4e2d\u8c03\u7528\u9012\u5f52\u51fd\u6570\uff1b \u5bf9\u6bd4\u4e0a\u8ff0\u4ee3\u7801\uff0c\u53ef\u4ee5\u53d1\u73b0\uff0c\u5982\u4e0b\u4e24\u4e2a\u8bed\u53e5\u662f\u5728\u4e00\u8d77\u7684\uff1a node \u2190 s.pop() visit(node) \u5176\u5b9e\u8fd9\u662f\u4e00\u4e2a\u7406\u89e3\u95ee\u9898\u672c\u8d28\u7684\u6240\u5728\uff0c\u65e0\u8bba\u54ea\u79cd\u65b9\u5f0f\uff0c\u4ece\u6808\u4e2d\u53d6\u51fa\u5143\u7d20\uff0c\u7136\u540e\u8fdb\u884cvisit\uff0c\u4e0d\u540c\u7684\u662f\u6df1\u5ea6\u4f18\u5148\u5148\u5e8f\u904d\u5386\u662f\u5728\u6bcf\u6b21\u5148\u4ece\u6808\u4e2d\u53d6\u51fa\u5143\u7d20\u8fdb\u884cvisit\u3002\u6df1\u5ea6\u4f18\u5148\u7684\u4e2d\u5e8f\u904d\u5386\u5219\u662f\u5728\u5de6\u5b50\u6811\u90fd\u8bbf\u95ee\u5b8c\u4e86\u540e\u624d\u4ece\u6808\u4e2d\u53d6\u51fa\u5143\u7d20\u8fdb\u884cvisit\u3002","title":"recursion\u7684\u5b9e\u73b0 VS iteration\u7684\u5b9e\u73b0"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion/","text":"Recursion # \u672c\u6587\u63cf\u8ff0Recursion\uff0c\u5176\u5b9e\u4e0a\u4e00\u7bc7 Recursive-definition \u4e2d\u7684\u5185\u5bb9\u662f\u66f4\u52a0\u5bb9\u6613\u7406\u89e3\u7684\u3002 \u7ef4\u57fa\u767e\u79d1 Recursion # Recursion (adjective: recursive ) occurs when a thing is defined in terms of itself or of its type. NOTE: \u5176\u5b9e\u4e0a\u8ff0\u5b9a\u4e49\u5c31\u662f\u7684\u542b\u4e49\u5176\u5b9e\u5c31\u662f recursive definition \u3002\u5728\u7ef4\u57fa\u767e\u79d1 Recursive acronym \u4e2d\u4f7f\u7528 \u201crefers to itself\u201d \u6765\u8868\u8fbe\u8fd9\u79cd\u542b\u4e49\u3002 Recursion is used in a variety of disciplines ranging from linguistics to logic . The most common application of recursion is in mathematics and computer science , where a function being defined is applied within its own definition. While this apparently defines an infinite number of instances (function values), it is often done in such a way that no loop or infinite chain of references can occur. NOTE: \u5982\u679c\u51fa\u73b0loop\u6216\u8005infinite chain\uff0c\u5219\u7a0b\u5e8f\u5c31\u4f1a\u51fa\u73b0\u6b7b\u5faa\u73af\uff1b Formal definitions # In mathematics and computer science, a class of objects or methods exhibits recursive behavior when it can be defined by two properties: A simple base case (or cases)\u2014a terminating scenario that does not use recursion to produce an answer A set of rules that reduces \uff08\u8fd9\u4e2a\u8bcd\u7528\u5f97\u975e\u5e38\u597d\uff09 all other cases toward the base case NOTE: \u201creduce\u201d\u8bf4\u660erecursion\u662f\u81ea\u9876\u5411\u4e0b\u7684\u3002 The Fibonacci sequence is a classic example of recursion: $ {\\text{Fib}}(0)=0{\\text{ as base case 1,}} $ $ {\\text{Fib}}(1)=1{\\text{ as base case 2,}} $ $ {\\text{For all integers }}n>1,~{\\text{ Fib}}(n):={\\text{Fib}}(n-1)+{\\text{Fib}}(n-2). $ Many mathematical axioms\uff08\u516c\u7406\uff09 are based upon recursive rules . For example, the formal definition of the natural numbers by the Peano axioms can be described as: 0 is a natural number, and each natural number has a successor, which is also a natural number. By this base case and recursive rule, one can generate the set of all natural numbers. Recursively defined mathematical objects include functions , sets , and especially fractals . NOTE: \u8f6f\u4ef6\u5de5\u7a0b\u5e08\u5e94\u8be5\u5bf9recursive definition\u654f\u611f\u3002 In mathematics # Recursively defined sets # \u53c2\u89c1\u6587\u7ae0 Recursive definition \u3002 Example: the natural numbers # Example: Proof procedure # Functional recursion # \u9012\u5f52\u51fd\u6570 A function may be recursively defined in terms of itself. A familiar example is the Fibonacci number sequence: F ( n ) = F ( n \u2212 1) + F ( n \u2212 2). For such a definition to be useful, it must be reducible to non-recursively defined values: in this case F (0) = 0 and F (1) = 1. A famous recursive function is the Ackermann function , which, unlike the Fibonacci sequence, cannot be expressed without recursion. Finite subdivision rules # Main article: Finite subdivision rule The recursion theorem # \u9012\u5f52\u5b9a\u7406 In set theory , this is a theorem guaranteeing that recursively defined functions exist. Given a set X , an element a of X and a function $ f:X\\rightarrow X $, the theorem states that there is a unique function $ F:\\mathbb {N} \\rightarrow X $ (where $ \\mathbb {N} $ denotes the set of natural numbers including zero) such that $ F(0)=a $ $ F(n+1)=f(F(n)) $ for any natural number n . NOTE: \u5e76\u6ca1\u6709\u641e\u61c2 In computer science # \u53c2\u89c1\u5de5\u7a0b\u6587\u7ae0 Recursion(computer-science) \u3002","title":"Recursion"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion/#recursion","text":"\u672c\u6587\u63cf\u8ff0Recursion\uff0c\u5176\u5b9e\u4e0a\u4e00\u7bc7 Recursive-definition \u4e2d\u7684\u5185\u5bb9\u662f\u66f4\u52a0\u5bb9\u6613\u7406\u89e3\u7684\u3002","title":"Recursion"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion/#recursion_1","text":"Recursion (adjective: recursive ) occurs when a thing is defined in terms of itself or of its type. NOTE: \u5176\u5b9e\u4e0a\u8ff0\u5b9a\u4e49\u5c31\u662f\u7684\u542b\u4e49\u5176\u5b9e\u5c31\u662f recursive definition \u3002\u5728\u7ef4\u57fa\u767e\u79d1 Recursive acronym \u4e2d\u4f7f\u7528 \u201crefers to itself\u201d \u6765\u8868\u8fbe\u8fd9\u79cd\u542b\u4e49\u3002 Recursion is used in a variety of disciplines ranging from linguistics to logic . The most common application of recursion is in mathematics and computer science , where a function being defined is applied within its own definition. While this apparently defines an infinite number of instances (function values), it is often done in such a way that no loop or infinite chain of references can occur. NOTE: \u5982\u679c\u51fa\u73b0loop\u6216\u8005infinite chain\uff0c\u5219\u7a0b\u5e8f\u5c31\u4f1a\u51fa\u73b0\u6b7b\u5faa\u73af\uff1b","title":"\u7ef4\u57fa\u767e\u79d1Recursion"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion/#formal-definitions","text":"In mathematics and computer science, a class of objects or methods exhibits recursive behavior when it can be defined by two properties: A simple base case (or cases)\u2014a terminating scenario that does not use recursion to produce an answer A set of rules that reduces \uff08\u8fd9\u4e2a\u8bcd\u7528\u5f97\u975e\u5e38\u597d\uff09 all other cases toward the base case NOTE: \u201creduce\u201d\u8bf4\u660erecursion\u662f\u81ea\u9876\u5411\u4e0b\u7684\u3002 The Fibonacci sequence is a classic example of recursion: $ {\\text{Fib}}(0)=0{\\text{ as base case 1,}} $ $ {\\text{Fib}}(1)=1{\\text{ as base case 2,}} $ $ {\\text{For all integers }}n>1,~{\\text{ Fib}}(n):={\\text{Fib}}(n-1)+{\\text{Fib}}(n-2). $ Many mathematical axioms\uff08\u516c\u7406\uff09 are based upon recursive rules . For example, the formal definition of the natural numbers by the Peano axioms can be described as: 0 is a natural number, and each natural number has a successor, which is also a natural number. By this base case and recursive rule, one can generate the set of all natural numbers. Recursively defined mathematical objects include functions , sets , and especially fractals . NOTE: \u8f6f\u4ef6\u5de5\u7a0b\u5e08\u5e94\u8be5\u5bf9recursive definition\u654f\u611f\u3002","title":"Formal definitions"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion/#in-mathematics","text":"","title":"In mathematics"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion/#recursively-defined-sets","text":"\u53c2\u89c1\u6587\u7ae0 Recursive definition \u3002","title":"Recursively defined sets"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion/#example-the-natural-numbers","text":"","title":"Example: the natural numbers"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion/#example-proof-procedure","text":"","title":"Example: Proof procedure"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion/#functional-recursion","text":"\u9012\u5f52\u51fd\u6570 A function may be recursively defined in terms of itself. A familiar example is the Fibonacci number sequence: F ( n ) = F ( n \u2212 1) + F ( n \u2212 2). For such a definition to be useful, it must be reducible to non-recursively defined values: in this case F (0) = 0 and F (1) = 1. A famous recursive function is the Ackermann function , which, unlike the Fibonacci sequence, cannot be expressed without recursion.","title":"Functional recursion"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion/#finite-subdivision-rules","text":"Main article: Finite subdivision rule","title":"Finite subdivision rules"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion/#the-recursion-theorem","text":"\u9012\u5f52\u5b9a\u7406 In set theory , this is a theorem guaranteeing that recursively defined functions exist. Given a set X , an element a of X and a function $ f:X\\rightarrow X $, the theorem states that there is a unique function $ F:\\mathbb {N} \\rightarrow X $ (where $ \\mathbb {N} $ denotes the set of natural numbers including zero) such that $ F(0)=a $ $ F(n+1)=f(F(n)) $ for any natural number n . NOTE: \u5e76\u6ca1\u6709\u641e\u61c2","title":"The recursion theorem"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursion/#in-computer-science","text":"\u53c2\u89c1\u5de5\u7a0b\u6587\u7ae0 Recursion(computer-science) \u3002","title":"In computer science"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursive-data-type/","text":"Recursive data type # \u672c\u6587\u662f\u7ef4\u57fa\u767e\u79d1 Recursive data type \u7684\u9605\u8bfb\u7b14\u8bb0\u3002 \u5982\u679c\u5c06\u5404\u79cddata structure\u770b\u505a\u662f\u4e00\u79cd\u7c7b\u578b\uff0c\u90a3\u4e9b\u5177\u5907 \u9012\u5f52\u6027 \u7684data structure\uff0c\u5c31\u662f\u672c\u8282\u6807\u9898\u6240\u8ff0\u201c recursive data type \u201d\uff0c\u8fd9\u4e2a\u672f\u8bed\u8868\u8fbe\u4e86\u6570\u636e\u7c7b\u578b\u7684\u9012\u5f52\u6027\u7279\u5f81\u3002\u5bf9\u4e8erecursive data type\uff0c\u90fd\u53ef\u4ee5\u7ed9\u51fa\u5b83\u7684 recursive definition \u3002 \u7ef4\u57fa\u767e\u79d1 Recursive data type \u4e2d\u5173\u4e8e\u5b83\u7684\u63cf\u8ff0\u662f\u4f7f\u7528\u7684\u7ef4\u57fa\u767e\u79d1 Recursive definition \u4e2d\u201crecursively defined set\u201d\u7684\u63cf\u8ff0\u65b9\u5f0f\u3002 \u6700\u6700\u5178\u578b\u7684recursive data type\u5c31\u662f\uff1a list tree \u5728\u7ef4\u57fa\u767e\u79d1 Recursive data type \u7684 Example \u8282\u7ed9\u51fa\u4e86\u4e0a\u8ff0\u4e24\u79cdrecursive data type\u7684 recursive definition \u3002 Recursive data type \u548c Structural induction \u7d27\u5bc6\u76f8\u5173\uff1b","title":"Recursive-data-type"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursive-data-type/#recursive-data-type","text":"\u672c\u6587\u662f\u7ef4\u57fa\u767e\u79d1 Recursive data type \u7684\u9605\u8bfb\u7b14\u8bb0\u3002 \u5982\u679c\u5c06\u5404\u79cddata structure\u770b\u505a\u662f\u4e00\u79cd\u7c7b\u578b\uff0c\u90a3\u4e9b\u5177\u5907 \u9012\u5f52\u6027 \u7684data structure\uff0c\u5c31\u662f\u672c\u8282\u6807\u9898\u6240\u8ff0\u201c recursive data type \u201d\uff0c\u8fd9\u4e2a\u672f\u8bed\u8868\u8fbe\u4e86\u6570\u636e\u7c7b\u578b\u7684\u9012\u5f52\u6027\u7279\u5f81\u3002\u5bf9\u4e8erecursive data type\uff0c\u90fd\u53ef\u4ee5\u7ed9\u51fa\u5b83\u7684 recursive definition \u3002 \u7ef4\u57fa\u767e\u79d1 Recursive data type \u4e2d\u5173\u4e8e\u5b83\u7684\u63cf\u8ff0\u662f\u4f7f\u7528\u7684\u7ef4\u57fa\u767e\u79d1 Recursive definition \u4e2d\u201crecursively defined set\u201d\u7684\u63cf\u8ff0\u65b9\u5f0f\u3002 \u6700\u6700\u5178\u578b\u7684recursive data type\u5c31\u662f\uff1a list tree \u5728\u7ef4\u57fa\u767e\u79d1 Recursive data type \u7684 Example \u8282\u7ed9\u51fa\u4e86\u4e0a\u8ff0\u4e24\u79cdrecursive data type\u7684 recursive definition \u3002 Recursive data type \u548c Structural induction \u7d27\u5bc6\u76f8\u5173\uff1b","title":"Recursive data type"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursive-definition/","text":"Recursive definition # \u8f6f\u4ef6\u5de5\u7a0b\u5e08\uff0c\u5bf9\u4e8edefinition\uff08\u5b9a\u4e49\uff09\u8fd9\u4e2a\u8bcd\u80af\u5b9a\u4e0d\u4f1a\u964c\u751f\uff0c\u56e0\u4e3a\u6211\u4eec\u6bcf\u5929\u90fd\u5728\u201c\u5b9a\u4e49\u4e00\u4e2a\u51fd\u6570\u201d\u3001\u201c\u5b9a\u4e49\u4e00\u4e2a\u7c7b\u201d\u3002\u7ef4\u57fa\u767e\u79d1\u7684 definition \u5185\u5bb9\u6bd4\u8f83\u6df1\u5965\uff0c\u672c\u6587\u5c06\u7b80\u5355\u5730\u6765\u8bf4definition\uff0c\u5b9a\u4e49\u5c31\u662f\u5728\u524d\u6587\u4e2d\u6240\u63d0\u53ca\u7684\u201c\u63cf\u8ff0\u201d\uff0c\u4e0d\u8fc7\u5b9a\u4e49\u6709\u7740\u66f4\u591a\u9650\u5236\u3002\u672c\u6587\u91cd\u70b9\u7b80\u8ff0\u7684\u662f Recursive definition \uff0c\u5728\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\uff0c recursion \u65e0\u5904\u4e0d\u5728\uff0c\u8f6f\u4ef6\u5de5\u7a0b\u5e08\u5e94\u8be5\u5bf9\u5b83\u4fdd\u6301\u654f\u611f\uff0c\u5bf9\u4e8e\u6240\u6709\u5177\u5907 recursion \u7279\u6027\u7684\uff08\u5305\u62ec\u7c7b\u578b\u3001\u8fc7\u7a0b\u7b49\uff09\uff0c\u90fd\u80fd\u591f\u7ed9\u51fa\u5176 Recursive definition \u3002 Recursive definition # In mathematics and computer science , a recursive definition , or inductive definition \uff08\u5f52\u7eb3\u5b9a\u4e49\uff09, is used to define the elements in a set in terms of other elements in the set ( Aczel 1977:740ff). Some examples of recursively-definable objects include factorials , natural numbers , Fibonacci numbers , and the Cantor ternary set . NOTE: \u4e0a\u8ff0\u5bf9recursive definition\u7684\u63cf\u8ff0\u4f7f\u7528\u7684\u662f\u6570\u5b66\u4e2d\u7684set\u7684\u6982\u5ff5\uff0c\u6570\u5b66\u4e2d\u7684set\u8868\u793a\u6240\u6709\u5177\u5907\u67d0\u4e00\u7279\u6027\u7684object\u7684\u96c6\u5408\uff0c\u6bd4\u5982\u6211\u4eec\u53ef\u4ee5\u5c06\u6240\u6709\u5177\u5907\u76f8\u540ctype\u7684object\u653e\u5230\u4e00\u4e2aset\u4e2d\u3002\u4e0b\u9762\u6211\u5c06\u5b83\u8f6c\u6362\u4e3asoftware engineer\u66f4\u52a0\u719f\u6089\u7684type\uff08\u7c7b\u578b\uff09\u7684\u6982\u5ff5\uff1a \u89c4\u5b9a\u5c5e\u4e8e\u540c\u4e00\u4e2aset\u7684\u6240\u6709\u5143\u7d20\u90fd\u662f\u5177\u6709\u76f8\u540c\u7c7b\u578b\u7684\u5143\u7d20\uff0c\u5219recursively-definable object\u662f\u7531\u76f8\u540c\u7c7b\u578b\u7684\u5176\u4ed6object\uff08\u5373\u8fd9\u4e2a\u96c6\u5408\u4e2d\u7684\u5176\u4ed6\u5143\u7d20\uff09\u6765\u8fdb\u884c\u5b9a\u4e49\u7684\uff08\u6784\u6210\uff09\u3002 \u53ef\u4ee5\u770b\u5230\uff0c\u5f53\u6211\u4eec\u5c06set\u7406\u89e3\u4e3atype\u540e\uff0c\u539f\u6765\u7684\u63cf\u8ff0\u5c31\u53d8\u6210\u4e86software engineer\u975e\u5e38\u4efb\u610f\u7406\u89e3\u7684\u4e86\u3002 \u4e0a\u8ff0\u5b9a\u4e49\u662f\u975e\u5e38\u4e25\u8c28\u7684\uff0c\u4f7f\u7528\u4e86\u6570\u5b66\u4e2d\u7684 set \u7684\u6982\u5ff5\uff0c\u53ef\u4ee5\u8ba4\u4e3a\u5b83\u4f7f\u7528\u7684\u662f\u4e00\u79cd\u6570\u5b66\u8bed\u8a00\u3002\u5728\u5176\u4ed6\u6587\u7ae0\u4e2d\u90fd\u53ef\u4ee5\u770b\u5230\u5b8c\u5168\u4f7f\u7528\u81ea\u7136\u8bed\u8a00\u63cf\u8ff0\u7684recursive definition\uff0c\u6bd4\u5982\uff1a \u5728\u7ef4\u57fa\u767e\u79d1 Recursion \u4e2d\uff1a Recursion (adjective: recursive ) occurs when a thing is defined in terms of itself or of its type. \u5728\u7ef4\u57fa\u767e\u79d1 Recursive acronym \u4e2d\uff1a A recursive acronym is an acronym that refers to itself . \u663e\u7136\u4f7f\u7528\u81ea\u7136\u8bed\u8a00\u7684\u63cf\u8ff0\u662f\u66f4\u52a0\u5bb9\u6613\u7406\u89e3\u7684\u3002 \u5982\u4f55\u7406\u89e3recursively defined function\uff1f \u663e\u7136\uff0c\u4e00\u4e2arecursively defined function\u5c31\u662f\u201c defined in terms of itself or of its type \u201d A recursive definition of a function defines values of the function for some inputs in terms of the values of the same function for other (usually smaller) inputs. For example, the factorial function n ! is defined by the rules 0! = 1. ( n + 1)! = ( n + 1)\u00b7 n !. NOTE: \u539f\u6587\u4e2d\u7ed9\u51fa\u4e86\u4e24\u79cd**recursive definition**\uff1arecursively defined functions and recursive defined objects Form of recursive definitions # Most recursive definitions have two foundations: a base case (basis) and an inductive clause . NOTE: \u201cinductive clause\u201d\u7684\u542b\u4e49\u662f\u201c\u5f52\u7eb3\u5b50\u53e5\u201d\uff0c\u5173\u4e8e\u201cinductive \u201d\uff0c\u53c2\u89c1 Induction \u3002 That recursive definitions are valid \u2013 meaning that a recursive definition identifies a unique function \u2013 is a theorem of set theory known as the recursion theorem , the proof of which is non-trivial. Where the domain of the function is the natural numbers , sufficient conditions for the definition to be valid are that the value of f(0) (i.e., base case) is given, and that for n > 0, an algorithm is given for determining f(n) in terms of f(0) , f(1) , ... , f(n-1) (i.e., inductive clause). More generally, recursive definitions of functions can be made whenever the domain is a well-ordered set , using the principle of transfinite recursion . The formal criteria for what constitutes a valid recursive definition are more complex for the general case. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u5e76\u6ca1\u6709\u7406\u89e3\u3002 \u603b\u7ed3 # \u6309\u7167\u539f\u6587\u7b2c\u4e00\u6bb5\u4e2d\u5bf9recursive definition\u7684\u63cf\u8ff0\uff0c\u53d1\u73b0\u5176\u5b9e\u5b83\u975e\u5e38\u7c7b\u4f3c\u4e8einduction\uff08\u5f52\u7eb3\u6cd5\uff09\uff0c\u6211\u4eec\u77e5\u9053\uff0cinduction\u662fbottom-up\u7684\uff0c\u5c24\u5176\u662f natural numbers \u7684\u4f8b\u5b50\u3002\u800c\u6211\u5bf9recursion\u7684\u60ef\u5e38\u5370\u8c61\u662f\u5b83\u662ftop-down\u3002\u8fd9\u4e24\u8005\u4e0d\u662f\u77db\u76fe\u5417\uff1f \u201crecursive definition\u201d\u662f\u4e00\u79cd\u63cf\u8ff0\u65b9\u5f0f\uff0c\u5b83\u4e0d\u6d89\u53ca\u5b9e\u73b0\u7684\u95ee\u9898\uff0c\u5b83\u7684\u63cf\u8ff0\u53ef\u4ee5\u662f\u7c7b\u4f3cinduction\u7684\u81ea\u5e95\u5411\u4e0a\uff0c\u4e5f\u53ef\u4ee5\u662f\u81ea\u9876\u5411\u4e0b\uff0c\u6b63\u5982\u539f\u6587\u7b2c\u4e00\u6bb5\u6240\u8ff0\u7684\uff1a recursive definition \u4e5f\u53ef\u4ee5\u53eb\u505a**inductive definition**\u3002\u201crecursive definition\u201d\u672c\u8d28\u5728\u4e8e\u201c defined in terms of itself or of its type \u201d\uff0c\u6b63\u5982\u672c\u6587\u7b2c\u4e00\u6bb5\u6240\u63cf\u8ff0\u7684\uff1a In mathematics and computer science , a recursive definition , or inductive definition \uff08\u5f52\u7eb3\u5b9a\u4e49\uff09, is used to define the elements in a set in terms of other elements in the set \u5173\u4e8e\u201crecursive definition\u201d\u7684\u4e00\u4e2a\u4f8b\u5b50\u5c31\u662f Recursive grammar \uff0c\u6bd4\u5982\u5728\u7ef4\u57fa\u767e\u79d1 Recursion (computer science) \u7684 Recursive data types \u6bb5\u4e2d\u7ed9\u51fa\u4e86\u8fd9\u6837\u7684\u4e00\u4e2a\u4f8b\u5b50\uff1a <expr> ::= <number> | (<expr> * <expr>) | (<expr> + <expr>) \u53ef\u4ee5\u770b\u5230\uff0c <expr> \u7684\u5b9a\u4e49\u4e2d\u5c31\u5305\u542b\u4e86\"itself\"\u3002 \u201c\u6211\u5bf9recursion\u7684\u60ef\u5e38\u5370\u8c61\u662f\u5b83\u662ftop-down\u201d\u662f\u6e90\u4e8e\u6211\u662f\u4ecerecursion function\u7684\u89d2\u5ea6\u6765\u770b\u5f85\u7684\u3002\u663e\u7136\uff0c\u8fd9\u662f\u63cf\u8ff0\u4e0e\u5b9e\u73b0\u7684\u5dee\u5f02\u3002\u5728\u539f\u6587\u7684 Form of recursive definitions \u4e2d\u7ed9\u51fa\u4e86recursive definition\u6240\u5bf9\u5e94\u7684function\uff0c\u663e\u7136\u5bf9\u4e8e\u8fd9\u4e2afunction\u7684\u5b9e\u73b0\uff0c\u6211\u4eec\u53ef\u4ee5\u91c7\u7528\u7684\u5b9e\u73b0\u65b9\u5f0f\u6709\u4e24\u79cd\uff1a \u81ea\u5e95\u5411\u4e0a \u81ea\u9876\u5411\u4e0b Examples of recursive definitions # Recursive grammar # \u53c2\u89c1\uff1a \u7ef4\u57fa\u767e\u79d1 Recursive grammar \u9f99\u4e66 2.2.1 Definition of Grammars Recursive definition in computer science # \u6709\u592a\u591a\u592a\u591a\u7684\u7b97\u6cd5\u3001\u7ed3\u6784\u90fd\u662f\u53ef\u4ee5\u4f7f\u7528recursive definition\u7684\u3002 \u4e00\u822c\u5e26\u6709\u201csub\u201d\u7684\u90fd\u662f\u53ef\u4ee5\u8fdb\u884crecursive definition\u7684\uff0c\u6bd4\u5982subtree\uff0csublist \u80fd\u591frecursive definition\u7684\uff0c\u79f0\u5b83\u5177\u5907\u9012\u5f52\u6027\u3002 \u5728\u7ef4\u57fa\u767e\u79d1 Structural induction \u4e2d\u6240\u63d0\u53ca\u7684\uff1a recursively defined structure, such as formulas , lists , or trees Recursive definition and closure # \u6309\u7167recursively defined sets\u7684\u6982\u5ff5\uff0c\u8fd9\u4e2aset\u5728\u6784\u9020\u65b0\u5143\u7d20\u7684operation\u4e0b\u662fclosed\u7684\uff08\u53c2\u89c1 Closure (mathematics) \uff09\u3002 Recursive definition and structure # Recursive data types \u4e2d\u4e13\u95e8\u63cf\u8ff0\u53ef\u4ee5\u4f7f\u7528recursive definition\u7684structure\uff0c\u8fd9\u5728 data-structure \u4e2d\u4f1a\u8fdb\u884c\u8ba8\u8bba\u3002 \u53ef\u4ee5\u4f7f\u7528recursive definition\u8fdb\u884c\u5b9a\u4e49\u7684structure\uff0c\u90fd\u5177\u5907\u9012\u5f52\u7279\u6027\u3002","title":"Recursive-Definition"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursive-definition/#recursive-definition","text":"\u8f6f\u4ef6\u5de5\u7a0b\u5e08\uff0c\u5bf9\u4e8edefinition\uff08\u5b9a\u4e49\uff09\u8fd9\u4e2a\u8bcd\u80af\u5b9a\u4e0d\u4f1a\u964c\u751f\uff0c\u56e0\u4e3a\u6211\u4eec\u6bcf\u5929\u90fd\u5728\u201c\u5b9a\u4e49\u4e00\u4e2a\u51fd\u6570\u201d\u3001\u201c\u5b9a\u4e49\u4e00\u4e2a\u7c7b\u201d\u3002\u7ef4\u57fa\u767e\u79d1\u7684 definition \u5185\u5bb9\u6bd4\u8f83\u6df1\u5965\uff0c\u672c\u6587\u5c06\u7b80\u5355\u5730\u6765\u8bf4definition\uff0c\u5b9a\u4e49\u5c31\u662f\u5728\u524d\u6587\u4e2d\u6240\u63d0\u53ca\u7684\u201c\u63cf\u8ff0\u201d\uff0c\u4e0d\u8fc7\u5b9a\u4e49\u6709\u7740\u66f4\u591a\u9650\u5236\u3002\u672c\u6587\u91cd\u70b9\u7b80\u8ff0\u7684\u662f Recursive definition \uff0c\u5728\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\uff0c recursion \u65e0\u5904\u4e0d\u5728\uff0c\u8f6f\u4ef6\u5de5\u7a0b\u5e08\u5e94\u8be5\u5bf9\u5b83\u4fdd\u6301\u654f\u611f\uff0c\u5bf9\u4e8e\u6240\u6709\u5177\u5907 recursion \u7279\u6027\u7684\uff08\u5305\u62ec\u7c7b\u578b\u3001\u8fc7\u7a0b\u7b49\uff09\uff0c\u90fd\u80fd\u591f\u7ed9\u51fa\u5176 Recursive definition \u3002","title":"Recursive definition"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursive-definition/#recursive-definition_1","text":"In mathematics and computer science , a recursive definition , or inductive definition \uff08\u5f52\u7eb3\u5b9a\u4e49\uff09, is used to define the elements in a set in terms of other elements in the set ( Aczel 1977:740ff). Some examples of recursively-definable objects include factorials , natural numbers , Fibonacci numbers , and the Cantor ternary set . NOTE: \u4e0a\u8ff0\u5bf9recursive definition\u7684\u63cf\u8ff0\u4f7f\u7528\u7684\u662f\u6570\u5b66\u4e2d\u7684set\u7684\u6982\u5ff5\uff0c\u6570\u5b66\u4e2d\u7684set\u8868\u793a\u6240\u6709\u5177\u5907\u67d0\u4e00\u7279\u6027\u7684object\u7684\u96c6\u5408\uff0c\u6bd4\u5982\u6211\u4eec\u53ef\u4ee5\u5c06\u6240\u6709\u5177\u5907\u76f8\u540ctype\u7684object\u653e\u5230\u4e00\u4e2aset\u4e2d\u3002\u4e0b\u9762\u6211\u5c06\u5b83\u8f6c\u6362\u4e3asoftware engineer\u66f4\u52a0\u719f\u6089\u7684type\uff08\u7c7b\u578b\uff09\u7684\u6982\u5ff5\uff1a \u89c4\u5b9a\u5c5e\u4e8e\u540c\u4e00\u4e2aset\u7684\u6240\u6709\u5143\u7d20\u90fd\u662f\u5177\u6709\u76f8\u540c\u7c7b\u578b\u7684\u5143\u7d20\uff0c\u5219recursively-definable object\u662f\u7531\u76f8\u540c\u7c7b\u578b\u7684\u5176\u4ed6object\uff08\u5373\u8fd9\u4e2a\u96c6\u5408\u4e2d\u7684\u5176\u4ed6\u5143\u7d20\uff09\u6765\u8fdb\u884c\u5b9a\u4e49\u7684\uff08\u6784\u6210\uff09\u3002 \u53ef\u4ee5\u770b\u5230\uff0c\u5f53\u6211\u4eec\u5c06set\u7406\u89e3\u4e3atype\u540e\uff0c\u539f\u6765\u7684\u63cf\u8ff0\u5c31\u53d8\u6210\u4e86software engineer\u975e\u5e38\u4efb\u610f\u7406\u89e3\u7684\u4e86\u3002 \u4e0a\u8ff0\u5b9a\u4e49\u662f\u975e\u5e38\u4e25\u8c28\u7684\uff0c\u4f7f\u7528\u4e86\u6570\u5b66\u4e2d\u7684 set \u7684\u6982\u5ff5\uff0c\u53ef\u4ee5\u8ba4\u4e3a\u5b83\u4f7f\u7528\u7684\u662f\u4e00\u79cd\u6570\u5b66\u8bed\u8a00\u3002\u5728\u5176\u4ed6\u6587\u7ae0\u4e2d\u90fd\u53ef\u4ee5\u770b\u5230\u5b8c\u5168\u4f7f\u7528\u81ea\u7136\u8bed\u8a00\u63cf\u8ff0\u7684recursive definition\uff0c\u6bd4\u5982\uff1a \u5728\u7ef4\u57fa\u767e\u79d1 Recursion \u4e2d\uff1a Recursion (adjective: recursive ) occurs when a thing is defined in terms of itself or of its type. \u5728\u7ef4\u57fa\u767e\u79d1 Recursive acronym \u4e2d\uff1a A recursive acronym is an acronym that refers to itself . \u663e\u7136\u4f7f\u7528\u81ea\u7136\u8bed\u8a00\u7684\u63cf\u8ff0\u662f\u66f4\u52a0\u5bb9\u6613\u7406\u89e3\u7684\u3002 \u5982\u4f55\u7406\u89e3recursively defined function\uff1f \u663e\u7136\uff0c\u4e00\u4e2arecursively defined function\u5c31\u662f\u201c defined in terms of itself or of its type \u201d A recursive definition of a function defines values of the function for some inputs in terms of the values of the same function for other (usually smaller) inputs. For example, the factorial function n ! is defined by the rules 0! = 1. ( n + 1)! = ( n + 1)\u00b7 n !. NOTE: \u539f\u6587\u4e2d\u7ed9\u51fa\u4e86\u4e24\u79cd**recursive definition**\uff1arecursively defined functions and recursive defined objects","title":"Recursive definition"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursive-definition/#form-of-recursive-definitions","text":"Most recursive definitions have two foundations: a base case (basis) and an inductive clause . NOTE: \u201cinductive clause\u201d\u7684\u542b\u4e49\u662f\u201c\u5f52\u7eb3\u5b50\u53e5\u201d\uff0c\u5173\u4e8e\u201cinductive \u201d\uff0c\u53c2\u89c1 Induction \u3002 That recursive definitions are valid \u2013 meaning that a recursive definition identifies a unique function \u2013 is a theorem of set theory known as the recursion theorem , the proof of which is non-trivial. Where the domain of the function is the natural numbers , sufficient conditions for the definition to be valid are that the value of f(0) (i.e., base case) is given, and that for n > 0, an algorithm is given for determining f(n) in terms of f(0) , f(1) , ... , f(n-1) (i.e., inductive clause). More generally, recursive definitions of functions can be made whenever the domain is a well-ordered set , using the principle of transfinite recursion . The formal criteria for what constitutes a valid recursive definition are more complex for the general case. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u5e76\u6ca1\u6709\u7406\u89e3\u3002","title":"Form of recursive definitions"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursive-definition/#_1","text":"\u6309\u7167\u539f\u6587\u7b2c\u4e00\u6bb5\u4e2d\u5bf9recursive definition\u7684\u63cf\u8ff0\uff0c\u53d1\u73b0\u5176\u5b9e\u5b83\u975e\u5e38\u7c7b\u4f3c\u4e8einduction\uff08\u5f52\u7eb3\u6cd5\uff09\uff0c\u6211\u4eec\u77e5\u9053\uff0cinduction\u662fbottom-up\u7684\uff0c\u5c24\u5176\u662f natural numbers \u7684\u4f8b\u5b50\u3002\u800c\u6211\u5bf9recursion\u7684\u60ef\u5e38\u5370\u8c61\u662f\u5b83\u662ftop-down\u3002\u8fd9\u4e24\u8005\u4e0d\u662f\u77db\u76fe\u5417\uff1f \u201crecursive definition\u201d\u662f\u4e00\u79cd\u63cf\u8ff0\u65b9\u5f0f\uff0c\u5b83\u4e0d\u6d89\u53ca\u5b9e\u73b0\u7684\u95ee\u9898\uff0c\u5b83\u7684\u63cf\u8ff0\u53ef\u4ee5\u662f\u7c7b\u4f3cinduction\u7684\u81ea\u5e95\u5411\u4e0a\uff0c\u4e5f\u53ef\u4ee5\u662f\u81ea\u9876\u5411\u4e0b\uff0c\u6b63\u5982\u539f\u6587\u7b2c\u4e00\u6bb5\u6240\u8ff0\u7684\uff1a recursive definition \u4e5f\u53ef\u4ee5\u53eb\u505a**inductive definition**\u3002\u201crecursive definition\u201d\u672c\u8d28\u5728\u4e8e\u201c defined in terms of itself or of its type \u201d\uff0c\u6b63\u5982\u672c\u6587\u7b2c\u4e00\u6bb5\u6240\u63cf\u8ff0\u7684\uff1a In mathematics and computer science , a recursive definition , or inductive definition \uff08\u5f52\u7eb3\u5b9a\u4e49\uff09, is used to define the elements in a set in terms of other elements in the set \u5173\u4e8e\u201crecursive definition\u201d\u7684\u4e00\u4e2a\u4f8b\u5b50\u5c31\u662f Recursive grammar \uff0c\u6bd4\u5982\u5728\u7ef4\u57fa\u767e\u79d1 Recursion (computer science) \u7684 Recursive data types \u6bb5\u4e2d\u7ed9\u51fa\u4e86\u8fd9\u6837\u7684\u4e00\u4e2a\u4f8b\u5b50\uff1a <expr> ::= <number> | (<expr> * <expr>) | (<expr> + <expr>) \u53ef\u4ee5\u770b\u5230\uff0c <expr> \u7684\u5b9a\u4e49\u4e2d\u5c31\u5305\u542b\u4e86\"itself\"\u3002 \u201c\u6211\u5bf9recursion\u7684\u60ef\u5e38\u5370\u8c61\u662f\u5b83\u662ftop-down\u201d\u662f\u6e90\u4e8e\u6211\u662f\u4ecerecursion function\u7684\u89d2\u5ea6\u6765\u770b\u5f85\u7684\u3002\u663e\u7136\uff0c\u8fd9\u662f\u63cf\u8ff0\u4e0e\u5b9e\u73b0\u7684\u5dee\u5f02\u3002\u5728\u539f\u6587\u7684 Form of recursive definitions \u4e2d\u7ed9\u51fa\u4e86recursive definition\u6240\u5bf9\u5e94\u7684function\uff0c\u663e\u7136\u5bf9\u4e8e\u8fd9\u4e2afunction\u7684\u5b9e\u73b0\uff0c\u6211\u4eec\u53ef\u4ee5\u91c7\u7528\u7684\u5b9e\u73b0\u65b9\u5f0f\u6709\u4e24\u79cd\uff1a \u81ea\u5e95\u5411\u4e0a \u81ea\u9876\u5411\u4e0b","title":"\u603b\u7ed3"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursive-definition/#examples-of-recursive-definitions","text":"","title":"Examples of recursive definitions"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursive-definition/#recursive-grammar","text":"\u53c2\u89c1\uff1a \u7ef4\u57fa\u767e\u79d1 Recursive grammar \u9f99\u4e66 2.2.1 Definition of Grammars","title":"Recursive grammar"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursive-definition/#recursive-definition-in-computer-science","text":"\u6709\u592a\u591a\u592a\u591a\u7684\u7b97\u6cd5\u3001\u7ed3\u6784\u90fd\u662f\u53ef\u4ee5\u4f7f\u7528recursive definition\u7684\u3002 \u4e00\u822c\u5e26\u6709\u201csub\u201d\u7684\u90fd\u662f\u53ef\u4ee5\u8fdb\u884crecursive definition\u7684\uff0c\u6bd4\u5982subtree\uff0csublist \u80fd\u591frecursive definition\u7684\uff0c\u79f0\u5b83\u5177\u5907\u9012\u5f52\u6027\u3002 \u5728\u7ef4\u57fa\u767e\u79d1 Structural induction \u4e2d\u6240\u63d0\u53ca\u7684\uff1a recursively defined structure, such as formulas , lists , or trees","title":"Recursive definition in computer science"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursive-definition/#recursive-definition-and-closure","text":"\u6309\u7167recursively defined sets\u7684\u6982\u5ff5\uff0c\u8fd9\u4e2aset\u5728\u6784\u9020\u65b0\u5143\u7d20\u7684operation\u4e0b\u662fclosed\u7684\uff08\u53c2\u89c1 Closure (mathematics) \uff09\u3002","title":"Recursive definition and closure"},{"location":"Guide/Induction-and-Recursion/Recursion/Recursive-definition/#recursive-definition-and-structure","text":"Recursive data types \u4e2d\u4e13\u95e8\u63cf\u8ff0\u53ef\u4ee5\u4f7f\u7528recursive definition\u7684structure\uff0c\u8fd9\u5728 data-structure \u4e2d\u4f1a\u8fdb\u884c\u8ba8\u8bba\u3002 \u53ef\u4ee5\u4f7f\u7528recursive definition\u8fdb\u884c\u5b9a\u4e49\u7684structure\uff0c\u90fd\u5177\u5907\u9012\u5f52\u7279\u6027\u3002","title":"Recursive definition and structure"},{"location":"Guide/Induction-and-Recursion/Recursion/Term-with-recursion-in-computer-science/","text":"Term with recursion in computer science # Recursive grammar Recursion theory\uff08Computability theory\uff09 Recursive language Recursive set Recursively enumerable set","title":"Term-with-recursion-in-computer-science"},{"location":"Guide/Induction-and-Recursion/Recursion/Term-with-recursion-in-computer-science/#term-with-recursion-in-computer-science","text":"Recursive grammar Recursion theory\uff08Computability theory\uff09 Recursive language Recursive set Recursively enumerable set","title":"Term with recursion in computer science"},{"location":"Guide/Iteration/","text":"\u5173\u4e8e\u672c\u7ae0 # \u5728 Recursion \u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u63d0\u53ca\u4e86iteration\uff0c\u672c\u7ae0\u8be6\u7ec6\u63cf\u8ff0iteration\u3002","title":"Introduction"},{"location":"Guide/Iteration/#_1","text":"\u5728 Recursion \u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u63d0\u53ca\u4e86iteration\uff0c\u672c\u7ae0\u8be6\u7ec6\u63cf\u8ff0iteration\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Guide/Iteration/Iteration/","text":"Iteration # \u6211\u4eec\u5df2\u7ecf\u7814\u7a76\u4e86 recursion \uff0c\u73b0\u5728\u6765\u770b\u548crecursion\u5bc6\u5207\u76f8\u5173\u7684\u53e6\u5916\u4e00\u79cd\u5728\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u5e7f\u6cdb\u5b58\u5728\u7684\uff1aiteration\u3002 \u6211\u89c9\u5f97\u4e4b\u6240\u4ee5recursion\u548citeration\u5982\u6b64\u91cd\u8981\uff0c\u662f\u56e0\u4e3acomputer science\u4e2d\uff0c \u79bb\u6563 \u662f\u5e7f\u6cdb\u5b58\u5728\u7684\uff0c\u5728\u57fa\u4e8e\u8fd9\u4e9b\u79bb\u6563\u7ed3\u6784\u8fdb\u884c\u8ba1\u7b97\u7684\u65f6\u5019\uff0c\u6211\u4eec\u6700\u6700\u5e38\u7528\u7684\u5c31\u662frecursion\u548citeration\u3002 \u6b63\u5982\u5728\u7ef4\u57fa\u767e\u79d1 Iteration \u4e2d\u6709\u8fd9\u6837\u7684\u603b\u7ed3\uff1a In mathematics and computer science , iteration (along with the related technique of recursion ) is a standard element of algorithms . \u4e0eiteration\u76f8\u5173\u7684\u91cd\u8981\u6982\u5ff5\u6709\uff1a Iterator Iterator pattern \u7ef4\u57fa\u767e\u79d1\uff1a Category:Iteration in programming stream\u662f\u4e00\u79cd\u7ebf\u6027\u7ed3\u6784\u3002 \u4e0d\u540c\u7684programming language\uff0c\u4ee5\u4e0d\u540c\u7684\u65b9\u5f0f\u6765\u652f\u6301iteration\u7684\u65b9\u5f0f\u662f\u4e0d\u540c\u7684\uff0cc\u4e2d\u76f4\u63a5\u4f7f\u7528\u88f8\u6307\u9488\u6765\u652f\u6301iteration\uff0cc++\u4e2d\u62bd\u8c61\u51fa\u6765iterator\uff08\u53c2\u89c1 Iterator library \uff09\u3002python\u4e2d\u4f7f\u7528magic function\u6765\u652f\u6301iteration\u3002python\u4e2d\u5e76\u6ca1\u6709\u663e\u5f0f\u5730\u5b9a\u4e49iterator\u7c7b\u578b\u3002 \u7f16\u5199\u8ba1\u5212 # \u5c06iteration\u548c\u653e\u5230recursion\u4e4b\u4e0b\u3002\u4e0e\u5b83\u4eec\u76f8\u5173\u7684\u53e6\u5916\u4e00\u4e2a\u6982\u5ff5\u5c31\u662fdiscrete\u3001structure\u3002 \u5bb9\u5668\u4e0e\u7b97\u6cd5\u7684\u5206\u79bb # \u6b63\u5982\u7ef4\u57fa\u767e\u79d1 Iterator pattern \u4e2d\u6240\u603b\u7ed3\u7684\uff1a The iterator pattern decouples algorithms from containers; in some cases, algorithms are necessarily container-specific and thus cannot be decoupled. iteration and algorithm # \u5728algorithm\u4e2d\uff0c\u6700\u6700\u5e38\u4f7f\u7528\u7684\u5c31\u662fiteration\u4e86\uff0c\u800citerator pattern\u6b63\u662f\u5c06\u4e24\u8005\u8fdb\u884c\u5206\u79bb\u3002visitor pattern\u611f\u89c9\u5c31\u662f\u8fd0\u7528\u7b97\u6cd5\u3002","title":"Iteration"},{"location":"Guide/Iteration/Iteration/#iteration","text":"\u6211\u4eec\u5df2\u7ecf\u7814\u7a76\u4e86 recursion \uff0c\u73b0\u5728\u6765\u770b\u548crecursion\u5bc6\u5207\u76f8\u5173\u7684\u53e6\u5916\u4e00\u79cd\u5728\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u5e7f\u6cdb\u5b58\u5728\u7684\uff1aiteration\u3002 \u6211\u89c9\u5f97\u4e4b\u6240\u4ee5recursion\u548citeration\u5982\u6b64\u91cd\u8981\uff0c\u662f\u56e0\u4e3acomputer science\u4e2d\uff0c \u79bb\u6563 \u662f\u5e7f\u6cdb\u5b58\u5728\u7684\uff0c\u5728\u57fa\u4e8e\u8fd9\u4e9b\u79bb\u6563\u7ed3\u6784\u8fdb\u884c\u8ba1\u7b97\u7684\u65f6\u5019\uff0c\u6211\u4eec\u6700\u6700\u5e38\u7528\u7684\u5c31\u662frecursion\u548citeration\u3002 \u6b63\u5982\u5728\u7ef4\u57fa\u767e\u79d1 Iteration \u4e2d\u6709\u8fd9\u6837\u7684\u603b\u7ed3\uff1a In mathematics and computer science , iteration (along with the related technique of recursion ) is a standard element of algorithms . \u4e0eiteration\u76f8\u5173\u7684\u91cd\u8981\u6982\u5ff5\u6709\uff1a Iterator Iterator pattern \u7ef4\u57fa\u767e\u79d1\uff1a Category:Iteration in programming stream\u662f\u4e00\u79cd\u7ebf\u6027\u7ed3\u6784\u3002 \u4e0d\u540c\u7684programming language\uff0c\u4ee5\u4e0d\u540c\u7684\u65b9\u5f0f\u6765\u652f\u6301iteration\u7684\u65b9\u5f0f\u662f\u4e0d\u540c\u7684\uff0cc\u4e2d\u76f4\u63a5\u4f7f\u7528\u88f8\u6307\u9488\u6765\u652f\u6301iteration\uff0cc++\u4e2d\u62bd\u8c61\u51fa\u6765iterator\uff08\u53c2\u89c1 Iterator library \uff09\u3002python\u4e2d\u4f7f\u7528magic function\u6765\u652f\u6301iteration\u3002python\u4e2d\u5e76\u6ca1\u6709\u663e\u5f0f\u5730\u5b9a\u4e49iterator\u7c7b\u578b\u3002","title":"Iteration"},{"location":"Guide/Iteration/Iteration/#_1","text":"\u5c06iteration\u548c\u653e\u5230recursion\u4e4b\u4e0b\u3002\u4e0e\u5b83\u4eec\u76f8\u5173\u7684\u53e6\u5916\u4e00\u4e2a\u6982\u5ff5\u5c31\u662fdiscrete\u3001structure\u3002","title":"\u7f16\u5199\u8ba1\u5212"},{"location":"Guide/Iteration/Iteration/#_2","text":"\u6b63\u5982\u7ef4\u57fa\u767e\u79d1 Iterator pattern \u4e2d\u6240\u603b\u7ed3\u7684\uff1a The iterator pattern decouples algorithms from containers; in some cases, algorithms are necessarily container-specific and thus cannot be decoupled.","title":"\u5bb9\u5668\u4e0e\u7b97\u6cd5\u7684\u5206\u79bb"},{"location":"Guide/Iteration/Iteration/#iteration-and-algorithm","text":"\u5728algorithm\u4e2d\uff0c\u6700\u6700\u5e38\u4f7f\u7528\u7684\u5c31\u662fiteration\u4e86\uff0c\u800citerator pattern\u6b63\u662f\u5c06\u4e24\u8005\u8fdb\u884c\u5206\u79bb\u3002visitor pattern\u611f\u89c9\u5c31\u662f\u8fd0\u7528\u7b97\u6cd5\u3002","title":"iteration and algorithm"},{"location":"Guide/Relation/","text":"\u5173\u4e8e\u672c\u7ae0 # \u201crelation\u201d\u5373\u5173\u7cfb\uff0c\u8fd9\u4e2a\u8bcd\u662f\u6211\u4eec\u7ecf\u5e38\u8bf4\u8d77\u7684\uff0c\u5728\u6570\u5b66\u4e2d\uff0cRelation\u662f\u4e13\u95e8\u7814\u7a76\u5b83\u7684\u4e00\u4e2a\u6570\u5b66\u5206\u652f\u3002\u672c\u6587\u5feb\u901f\u68b3\u7406Relation\u76f8\u5173\u77e5\u8bc6\uff0c\u4e3b\u8981\u662f\u57fa\u4e8e\u7ef4\u57fa\u767e\u79d1 Finitary relation \u3002\u53e6\u5916\u5728\u7ecf\u5178\u6559\u6750 Discrete Mathematics and Its Applications \u4e2d\u4e5f\u6709\u4e13\u95e8\u7684\u7ae0\u8282\u8ba8\u8bbaRelation\u3002","title":"Introduction"},{"location":"Guide/Relation/#_1","text":"\u201crelation\u201d\u5373\u5173\u7cfb\uff0c\u8fd9\u4e2a\u8bcd\u662f\u6211\u4eec\u7ecf\u5e38\u8bf4\u8d77\u7684\uff0c\u5728\u6570\u5b66\u4e2d\uff0cRelation\u662f\u4e13\u95e8\u7814\u7a76\u5b83\u7684\u4e00\u4e2a\u6570\u5b66\u5206\u652f\u3002\u672c\u6587\u5feb\u901f\u68b3\u7406Relation\u76f8\u5173\u77e5\u8bc6\uff0c\u4e3b\u8981\u662f\u57fa\u4e8e\u7ef4\u57fa\u767e\u79d1 Finitary relation \u3002\u53e6\u5916\u5728\u7ecf\u5178\u6559\u6750 Discrete Mathematics and Its Applications \u4e2d\u4e5f\u6709\u4e13\u95e8\u7684\u7ae0\u8282\u8ba8\u8bbaRelation\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Guide/Relation/Relation/","text":"Relation # \u73b0\u4ee3\u6570\u5b66\u7684\u5f88\u591a\u6982\u5ff5\u90fd\u662f\u5efa\u7acb\u5728 Set \u7684\u57fa\u7840\u4e4b\u4e0a\uff0c\u6bd4\u5982\u6211\u4eec\u719f\u77e5\u7684 Function \u6982\u5ff5\uff0cRelation\u4e5f\u662f\u5982\u6b64\uff0c\u7ef4\u57fa\u767e\u79d1\u4e2d\u4ecb\u7ecdRelation\u7684\u662f Finitary relation \u3002 Finitary relation # Finitary relation \u7684\u542b\u4e49\u662f\u201c\u6709\u9650\u5143\u5173\u7cfb\u201d\uff0c\u6211\u4eec\u4e3b\u8981\u8ba8\u8bba\u7684\u662f Binary relation \uff08\u4e8c\u5143\u5173\u7cfb\uff09\u3002 Binary relation # In mathematics , a binary relation over two sets A and B is a set of ordered pairs ( a , b ), consisting of elements a of A and elements b of B . That is, it is a subset of the Cartesian product A \u00d7 B . It encodes the information of relation: an element a is related to an element b , if and only if the pair ( a , b ) belongs to the set. relation\u7684\u672c\u8d28\u4e0a\u662fset\u3002 \u67e5\u770b Binary relation \u548c Function \u53ef\u77e5\uff0c Binary relation \u662f\u4e00\u4e2a\u6bd4 Function \u66f4\u52a0\u5bbd\u6cdb\u7684\u6982\u5ff5\uff1a Function \u662f\u4e00\u79cd Binary relation \uff0c\u4f46\u662f\u53cd\u4e4b\u5219\u4e0d\u4e00\u5b9a\u6210\u7acb\u3002 \u5173\u7cfb\u7684\u6027\u8d28 # Transitive relation # \"transitive\"\u7684\u4e2d\u6587\u610f\u601d\u662f\u201c\u4f20\u9012\u6027\u201d Transitivity is a key property of both partial orders and equivalence relations \u3002 Reflexive relation # \u201creflexive\u201d\u5373\u201c\u53cd\u5c04\u6027\u201d\u3002 Symmetric relation # \u201csymmetric\u201d\u5373\u201c\u5bf9\u79f0\u201d Relational algebra # \u5173\u7cfb\u4ee3\u6570\uff0c\u8fd9\u662fDBMS\u7684\u57fa\u7840\u3002","title":"Relation"},{"location":"Guide/Relation/Relation/#relation","text":"\u73b0\u4ee3\u6570\u5b66\u7684\u5f88\u591a\u6982\u5ff5\u90fd\u662f\u5efa\u7acb\u5728 Set \u7684\u57fa\u7840\u4e4b\u4e0a\uff0c\u6bd4\u5982\u6211\u4eec\u719f\u77e5\u7684 Function \u6982\u5ff5\uff0cRelation\u4e5f\u662f\u5982\u6b64\uff0c\u7ef4\u57fa\u767e\u79d1\u4e2d\u4ecb\u7ecdRelation\u7684\u662f Finitary relation \u3002","title":"Relation"},{"location":"Guide/Relation/Relation/#finitary-relation","text":"Finitary relation \u7684\u542b\u4e49\u662f\u201c\u6709\u9650\u5143\u5173\u7cfb\u201d\uff0c\u6211\u4eec\u4e3b\u8981\u8ba8\u8bba\u7684\u662f Binary relation \uff08\u4e8c\u5143\u5173\u7cfb\uff09\u3002","title":"Finitary relation"},{"location":"Guide/Relation/Relation/#binary-relation","text":"In mathematics , a binary relation over two sets A and B is a set of ordered pairs ( a , b ), consisting of elements a of A and elements b of B . That is, it is a subset of the Cartesian product A \u00d7 B . It encodes the information of relation: an element a is related to an element b , if and only if the pair ( a , b ) belongs to the set. relation\u7684\u672c\u8d28\u4e0a\u662fset\u3002 \u67e5\u770b Binary relation \u548c Function \u53ef\u77e5\uff0c Binary relation \u662f\u4e00\u4e2a\u6bd4 Function \u66f4\u52a0\u5bbd\u6cdb\u7684\u6982\u5ff5\uff1a Function \u662f\u4e00\u79cd Binary relation \uff0c\u4f46\u662f\u53cd\u4e4b\u5219\u4e0d\u4e00\u5b9a\u6210\u7acb\u3002","title":"Binary relation"},{"location":"Guide/Relation/Relation/#_1","text":"","title":"\u5173\u7cfb\u7684\u6027\u8d28"},{"location":"Guide/Relation/Relation/#transitive-relation","text":"\"transitive\"\u7684\u4e2d\u6587\u610f\u601d\u662f\u201c\u4f20\u9012\u6027\u201d Transitivity is a key property of both partial orders and equivalence relations \u3002","title":"Transitive relation"},{"location":"Guide/Relation/Relation/#reflexive-relation","text":"\u201creflexive\u201d\u5373\u201c\u53cd\u5c04\u6027\u201d\u3002","title":"Reflexive relation"},{"location":"Guide/Relation/Relation/#symmetric-relation","text":"\u201csymmetric\u201d\u5373\u201c\u5bf9\u79f0\u201d","title":"Symmetric relation"},{"location":"Guide/Relation/Relation/#relational-algebra","text":"\u5173\u7cfb\u4ee3\u6570\uff0c\u8fd9\u662fDBMS\u7684\u57fa\u7840\u3002","title":"Relational algebra"},{"location":"Guide/Relation/Order-theory/Application/","text":"Application # \u4e00\u4e9b\u4e0eorder theory\u76f8\u5173\u7684\u5e94\u7528\u3002 Topological sorting # \u5728\u9f99\u4e66\u7684chapter 5.2 Evaluation Orders for SDD's\u4e2d\u6709\u5173\u4e8e\u6b64\u7684\u8ba8\u8bba\u3002","title":"Application"},{"location":"Guide/Relation/Order-theory/Application/#application","text":"\u4e00\u4e9b\u4e0eorder theory\u76f8\u5173\u7684\u5e94\u7528\u3002","title":"Application"},{"location":"Guide/Relation/Order-theory/Application/#topological-sorting","text":"\u5728\u9f99\u4e66\u7684chapter 5.2 Evaluation Orders for SDD's\u4e2d\u6709\u5173\u4e8e\u6b64\u7684\u8ba8\u8bba\u3002","title":"Topological sorting"},{"location":"Guide/Relation/Order-theory/Greatest-and-least-elements/","text":"Greatest and least elements # \u6700\u5927\u5143\u7d20\u4e0e\u6700\u5c0f\u5143\u7d20\uff0c\u6211\u4eec\u5bfb\u5e38\u7684\u7406\u89e3\u662f\u6309\u7167\u5927\u5c0f\u6765\u8fdb\u884c\u6392\u5e8f\uff0c\u4e0b\u9762\u770b\u770border theory\u4e2d\u5982\u4f55\u6765\u5b9a\u4e49\u6700\u5927\u5143\u7d20\u4e0e\u6700\u5c0f\u5143\u7d20\u3002 \u7ef4\u57fa\u767e\u79d1 Greatest and least elements #","title":"Greatest-and-least-elements"},{"location":"Guide/Relation/Order-theory/Greatest-and-least-elements/#greatest-and-least-elements","text":"\u6700\u5927\u5143\u7d20\u4e0e\u6700\u5c0f\u5143\u7d20\uff0c\u6211\u4eec\u5bfb\u5e38\u7684\u7406\u89e3\u662f\u6309\u7167\u5927\u5c0f\u6765\u8fdb\u884c\u6392\u5e8f\uff0c\u4e0b\u9762\u770b\u770border theory\u4e2d\u5982\u4f55\u6765\u5b9a\u4e49\u6700\u5927\u5143\u7d20\u4e0e\u6700\u5c0f\u5143\u7d20\u3002","title":"Greatest and least elements"},{"location":"Guide/Relation/Order-theory/Greatest-and-least-elements/#greatest-and-least-elements_1","text":"","title":"\u7ef4\u57fa\u767e\u79d1Greatest and least elements"},{"location":"Guide/Relation/Order-theory/Order-theory/","text":"Order theory # \u6392\u5e8f\u95ee\u9898 \u662f\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u7684\u4e00\u7c7b\u5178\u578b\u95ee\u9898\uff0c \u6709\u5f88\u591a\u7684\u95ee\u9898\u6700\u7ec8\u90fd\u53ef\u4ee5\u8f6c\u6362\u4e3a\u6392\u5e8f\u95ee\u9898\uff0c\u6bd4\u5982\uff08TODO \u589e\u52a0\u4e00\u4e9b\u4f8b\u5b50\uff0c\u5982\u5faa\u73af\u4f9d\u8d56\u56fe\uff09\uff0c\u672c\u7ae0\u5c06\u7814\u7a76\u6392\u5e8f\u7684\u7406\u8bba\uff1aorder theory\u8fdb\u884c\u603b\u7ed3\uff0c\u7ecf\u8fc7\u672c\u7ae0\uff0c\u6211\u4eec\u5c06\u5bf9order\u6709\u4e00\u4e2a\u66f4\u52a0\u79d1\u5b66\u7684\u8ba4\u8bc6\u3002 \u7ef4\u57fa\u767e\u79d1 Order theory # \u7b14\u8bb0 # \u901a\u8fc7\u7ef4\u57fa\u767e\u79d1 Order theory \uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\uff0cOrder theory\u662f\u5efa\u7acb\u5728 binary relation \u4e4b\u4e0a\u7684\uff0c\u5b83\u6240\u7814\u7a76\u7684\u662f**\u540c\u4e00**\u96c6\u5408\u4e2d\u7684\u5143\u7d20\u4e4b\u95f4\u7684\u5173\u7cfb\u3002 Order theory \u5c06\u201c\u6392\u5e8f\u201d\u7684\u6982\u5ff5\u8fdb\u884c\u4e86\u62d3\u5e7f\uff0c\u5b83\u544a\u8bc9\u6211\u4eec\u96c6\u5408\u4e2d\u7684\u5143\u7d20\u6309\u7167\u600e\u6837\u7684\u5173\u7cfb\u6765\u8fdb\u884c\u7ec4\u7ec7\uff0c\u5219\u5b83\u4eec\u662f\u53ef\u4ee5\u8fdb\u884c\u201c\u6392\u5e8f\u201d\u7684\uff0c\u4e0b\u9762\u7684 Binary relations \u7ae0\u8282\u5bf9\u6b64\u8fdb\u884c\u4e86\u603b\u7ed3\u3002 \u540e\u9762\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4f9d\u636e\u8fd9\u4e2a\u7406\u8bba\uff0c\u5efa\u7acb\u8d77\u975e\u5e38\u591a\u7684\u6982\u5ff5\uff0c\u8fd9\u4e9b\u6982\u5ff5\u6709\u4e00\u4e9b\u662f\u6211\u4eec\u5e73\u65f6\u6240\u719f\u77e5\u7684\uff0c\u4f46\u662f\u4eceorder theory\u7684\uff0c\u6211\u4eec\u5c06\u4f1a\u83b7\u5f97\u65b0\u7684\u8ba4\u77e5\u3002 Binary relations # \u4e0b\u9762\u662f\u7ef4\u57fa\u767e\u79d1 Binary relations \u4e2d\u6240\u603b\u7ed3\u7684\u4e00\u4e9bbinary relation\uff0c\u6211\u4eec\u91cd\u70b9\u5173\u6ce8\u7684\u662forder\u3002 Symmetric Antisymmetric Connex Well-founded Has joins Has meets Equivalence relation \u2713 \u2717 \u2717 \u2717 \u2717 \u2717 Preorder (Quasiorder) \u2717 \u2717 \u2717 \u2717 \u2717 \u2717 Partial order \u2717 \u2713 \u2717 \u2717 \u2717 \u2717 Total preorder \u2717 \u2717 \u2713 \u2717 \u2717 \u2717 Total order \u2717 \u2713 \u2713 \u2717 \u2717 \u2717 Prewellordering \u2717 \u2717 \u2713 \u2713 \u2717 \u2717 Well-quasi-ordering \u2717 \u2717 \u2717 \u2713 \u2717 \u2717 Well-ordering \u2717 \u2713 \u2713 \u2713 \u2717 \u2717 Lattice \u2717 \u2713 \u2717 \u2717 \u2713 \u2713 Join-semilattice \u2717 \u2713 \u2717 \u2717 \u2713 \u2717 Meet-semilattice \u2717 \u2713 \u2717 \u2717 \u2717 \u2713 A \"\u2713\" indicates that the column property is required in the row definition. For example, the definition of an equivalence relation requires it to be symmetric. All definitions tacitly require transitivity and reflexivity . NOTE: transitivity \u662f\u53ef\u4ee5\u8fdb\u884c\u201c\u6392\u5e8f\u201d\u7684\u524d\u63d0\u6761\u4ef6\u3002","title":"Introduction"},{"location":"Guide/Relation/Order-theory/Order-theory/#order-theory","text":"\u6392\u5e8f\u95ee\u9898 \u662f\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u7684\u4e00\u7c7b\u5178\u578b\u95ee\u9898\uff0c \u6709\u5f88\u591a\u7684\u95ee\u9898\u6700\u7ec8\u90fd\u53ef\u4ee5\u8f6c\u6362\u4e3a\u6392\u5e8f\u95ee\u9898\uff0c\u6bd4\u5982\uff08TODO \u589e\u52a0\u4e00\u4e9b\u4f8b\u5b50\uff0c\u5982\u5faa\u73af\u4f9d\u8d56\u56fe\uff09\uff0c\u672c\u7ae0\u5c06\u7814\u7a76\u6392\u5e8f\u7684\u7406\u8bba\uff1aorder theory\u8fdb\u884c\u603b\u7ed3\uff0c\u7ecf\u8fc7\u672c\u7ae0\uff0c\u6211\u4eec\u5c06\u5bf9order\u6709\u4e00\u4e2a\u66f4\u52a0\u79d1\u5b66\u7684\u8ba4\u8bc6\u3002","title":"Order theory"},{"location":"Guide/Relation/Order-theory/Order-theory/#order-theory_1","text":"","title":"\u7ef4\u57fa\u767e\u79d1Order theory"},{"location":"Guide/Relation/Order-theory/Order-theory/#_1","text":"\u901a\u8fc7\u7ef4\u57fa\u767e\u79d1 Order theory \uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\uff0cOrder theory\u662f\u5efa\u7acb\u5728 binary relation \u4e4b\u4e0a\u7684\uff0c\u5b83\u6240\u7814\u7a76\u7684\u662f**\u540c\u4e00**\u96c6\u5408\u4e2d\u7684\u5143\u7d20\u4e4b\u95f4\u7684\u5173\u7cfb\u3002 Order theory \u5c06\u201c\u6392\u5e8f\u201d\u7684\u6982\u5ff5\u8fdb\u884c\u4e86\u62d3\u5e7f\uff0c\u5b83\u544a\u8bc9\u6211\u4eec\u96c6\u5408\u4e2d\u7684\u5143\u7d20\u6309\u7167\u600e\u6837\u7684\u5173\u7cfb\u6765\u8fdb\u884c\u7ec4\u7ec7\uff0c\u5219\u5b83\u4eec\u662f\u53ef\u4ee5\u8fdb\u884c\u201c\u6392\u5e8f\u201d\u7684\uff0c\u4e0b\u9762\u7684 Binary relations \u7ae0\u8282\u5bf9\u6b64\u8fdb\u884c\u4e86\u603b\u7ed3\u3002 \u540e\u9762\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4f9d\u636e\u8fd9\u4e2a\u7406\u8bba\uff0c\u5efa\u7acb\u8d77\u975e\u5e38\u591a\u7684\u6982\u5ff5\uff0c\u8fd9\u4e9b\u6982\u5ff5\u6709\u4e00\u4e9b\u662f\u6211\u4eec\u5e73\u65f6\u6240\u719f\u77e5\u7684\uff0c\u4f46\u662f\u4eceorder theory\u7684\uff0c\u6211\u4eec\u5c06\u4f1a\u83b7\u5f97\u65b0\u7684\u8ba4\u77e5\u3002","title":"\u7b14\u8bb0"},{"location":"Guide/Relation/Order-theory/Order-theory/#binary-relations","text":"\u4e0b\u9762\u662f\u7ef4\u57fa\u767e\u79d1 Binary relations \u4e2d\u6240\u603b\u7ed3\u7684\u4e00\u4e9bbinary relation\uff0c\u6211\u4eec\u91cd\u70b9\u5173\u6ce8\u7684\u662forder\u3002 Symmetric Antisymmetric Connex Well-founded Has joins Has meets Equivalence relation \u2713 \u2717 \u2717 \u2717 \u2717 \u2717 Preorder (Quasiorder) \u2717 \u2717 \u2717 \u2717 \u2717 \u2717 Partial order \u2717 \u2713 \u2717 \u2717 \u2717 \u2717 Total preorder \u2717 \u2717 \u2713 \u2717 \u2717 \u2717 Total order \u2717 \u2713 \u2713 \u2717 \u2717 \u2717 Prewellordering \u2717 \u2717 \u2713 \u2713 \u2717 \u2717 Well-quasi-ordering \u2717 \u2717 \u2717 \u2713 \u2717 \u2717 Well-ordering \u2717 \u2713 \u2713 \u2713 \u2717 \u2717 Lattice \u2717 \u2713 \u2717 \u2717 \u2713 \u2713 Join-semilattice \u2717 \u2713 \u2717 \u2717 \u2713 \u2717 Meet-semilattice \u2717 \u2713 \u2717 \u2717 \u2717 \u2713 A \"\u2713\" indicates that the column property is required in the row definition. For example, the definition of an equivalence relation requires it to be symmetric. All definitions tacitly require transitivity and reflexivity . NOTE: transitivity \u662f\u53ef\u4ee5\u8fdb\u884c\u201c\u6392\u5e8f\u201d\u7684\u524d\u63d0\u6761\u4ef6\u3002","title":"Binary relations"},{"location":"Guide/Relation/Order-theory/Partially-order/","text":"Partially ordered set # \u201cpartially ordered set\u201d\u5373\u201c\u504f\u5e8f\u96c6\u201d\u3002 \u7ef4\u57fa\u767e\u79d1 Partially ordered set # \u7b14\u8bb0 # Partial order VS total order # \u5728\u539f\u6587\u4e2d\u7684\u5bf9\u4e00\u6bb5\u4e2d\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u4e86\u8be6\u7ec6\u5206\u6790\u3002 Partial order\u7684 reflexive \u7684\u601d\u8003\uff1f # \u5728\u539f\u6587\u7b2c\u4e8c\u6bb5\u4e2d\uff1a Formally, a partial order is any binary relation that is reflexive (each element is comparable to itself), antisymmetric (no two different elements precede each other), and transitive (the start of a chain of precedence relations must precede the end of the chain). \u5176\u4e2d\u5f3a\u8c03\u4e86partial order\u9700\u8981\u662f reflexive \uff0c\u4f46\u662f\u7b2c\u4e09\u6bb5\u4e2d\u6240\u679a\u4e3e\u7684 genealogical descendancy \u663e\u7136\u662f\u4e0d\u5177\u5907 reflexive \u7684\u3002","title":"Partially-order"},{"location":"Guide/Relation/Order-theory/Partially-order/#partially-ordered-set","text":"\u201cpartially ordered set\u201d\u5373\u201c\u504f\u5e8f\u96c6\u201d\u3002","title":"Partially ordered set"},{"location":"Guide/Relation/Order-theory/Partially-order/#partially-ordered-set_1","text":"","title":"\u7ef4\u57fa\u767e\u79d1Partially ordered set"},{"location":"Guide/Relation/Order-theory/Partially-order/#_1","text":"","title":"\u7b14\u8bb0"},{"location":"Guide/Relation/Order-theory/Partially-order/#partial-order-vs-total-order","text":"\u5728\u539f\u6587\u4e2d\u7684\u5bf9\u4e00\u6bb5\u4e2d\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u4e86\u8be6\u7ec6\u5206\u6790\u3002","title":"Partial order VS total order"},{"location":"Guide/Relation/Order-theory/Partially-order/#partial-order-reflexive","text":"\u5728\u539f\u6587\u7b2c\u4e8c\u6bb5\u4e2d\uff1a Formally, a partial order is any binary relation that is reflexive (each element is comparable to itself), antisymmetric (no two different elements precede each other), and transitive (the start of a chain of precedence relations must precede the end of the chain). \u5176\u4e2d\u5f3a\u8c03\u4e86partial order\u9700\u8981\u662f reflexive \uff0c\u4f46\u662f\u7b2c\u4e09\u6bb5\u4e2d\u6240\u679a\u4e3e\u7684 genealogical descendancy \u663e\u7136\u662f\u4e0d\u5177\u5907 reflexive \u7684\u3002","title":"Partial order\u7684 reflexive \u7684\u601d\u8003\uff1f"},{"location":"Guide/Relation/Order-theory/Preorder/","text":"Preorder # \u201cpreorder\u201d\u5373\u201c\u524d\u5e8f\u201d \u7ef4\u57fa\u767e\u79d1 Preorder #","title":"Preorder"},{"location":"Guide/Relation/Order-theory/Preorder/#preorder","text":"\u201cpreorder\u201d\u5373\u201c\u524d\u5e8f\u201d","title":"Preorder"},{"location":"Guide/Relation/Order-theory/Preorder/#preorder_1","text":"","title":"\u7ef4\u57fa\u767e\u79d1Preorder"},{"location":"Guide/Relation/Order-theory/Total-order/","text":"Total order # \u201ctotal order\u201d\u5373\u5168\u5e8f\u3002 \u7ef4\u57fa\u767e\u79d1 Total order # \u7b14\u8bb0 # Formal definition # \u539f\u6587\u4e2d\u7684\u5bf9\u201ctotal order\u201d\u7684\u201cformal definition\u201d\u5982\u4e0b\uff1a Formally, a binary relation $\\leq $ is a total order on a set X X if the following statements hold for all a,b a,b and c c in X X : Antisymmetry If a\\leq b a\\leq b and $ b\\leq a$ then a=b a=b ; Transitivity If a\\leq b a\\leq b and $ b\\leq c$then a\\leq c a\\leq c ; Connexity a\\leq b a\\leq b or b\\leq a b\\leq a }. $\\leq $\u8868\u793a\u7684\u662f\u4e00\u4e2abinary relation\uff0c\u800c\u975e\u6211\u4eec\u76f4\u89c2\u7406\u89e3\u7684\u201c\u5c0f\u4e8e\u7b49\u4e8e\u201d\u3002\u53e6\u5916\u4e00\u70b9\u662f\uff0c\u4e0a\u8ff0\u5b9a\u4e49\u4e2d\u201call\u201d\u5f3a\u8c03\u4e86\u96c6\u5408\u4e2d\u7684\u6240\u6709\u5143\u7d20\u90fd\u9700\u8981\u6ee1\u8db3\u8fd9\u79cd\u5173\u7cfb\u3002 Chain # \u5bf9\u201ctotal order\u201d\u7684\u76f4\u89c2\u7406\u89e3\u662f\u5b83\u662f\u4e00\u4e2a\u80fd\u591f\u5c06\u8fd9\u4e2a\u96c6\u5408\u201c\u4e32\u201d\u8d77\u6765\u7684\u5173\u7cfb\uff0c\u8fd9\u6837\u8fd9\u4e2a\u96c6\u5408\u5c31\u5f62\u6210\u4e86\u201cchain\u201d\uff0c\u663e\u7136\uff0c\u201cchain\u201d\u662f\u4ece\u89c6\u89c9\u76f4\u89c2\u89d2\u5ea6\u6765\u5bf9\u5176\u8fdb\u884c\u547d\u540d\u7684\uff0c\u5bf9\u6b64\u5728\u539f\u6587\u4e2d\u6709\u8fd9\u6837\u7684\u63cf\u8ff0\uff1a A set paired with a total order is called a chain , a totally ordered set , a simply ordered set , or a linearly ordered set . \u539f\u6587\u7684 Chains \u7ae0\u8282\u5bf9\u6b64\u8fdb\u884c\u4e86\u8be6\u7ec6\u5206\u6790\u3002 Connex relation # \u201cconnex relation\u201d\u5373\u201c\u8fde\u901a\u5173\u7cfb\u201d \u7ef4\u57fa\u767e\u79d1 Connex relation #","title":"Total-order"},{"location":"Guide/Relation/Order-theory/Total-order/#total-order","text":"\u201ctotal order\u201d\u5373\u5168\u5e8f\u3002","title":"Total order"},{"location":"Guide/Relation/Order-theory/Total-order/#total-order_1","text":"","title":"\u7ef4\u57fa\u767e\u79d1Total order"},{"location":"Guide/Relation/Order-theory/Total-order/#_1","text":"","title":"\u7b14\u8bb0"},{"location":"Guide/Relation/Order-theory/Total-order/#formal-definition","text":"\u539f\u6587\u4e2d\u7684\u5bf9\u201ctotal order\u201d\u7684\u201cformal definition\u201d\u5982\u4e0b\uff1a Formally, a binary relation $\\leq $ is a total order on a set X X if the following statements hold for all a,b a,b and c c in X X : Antisymmetry If a\\leq b a\\leq b and $ b\\leq a$ then a=b a=b ; Transitivity If a\\leq b a\\leq b and $ b\\leq c$then a\\leq c a\\leq c ; Connexity a\\leq b a\\leq b or b\\leq a b\\leq a }. $\\leq $\u8868\u793a\u7684\u662f\u4e00\u4e2abinary relation\uff0c\u800c\u975e\u6211\u4eec\u76f4\u89c2\u7406\u89e3\u7684\u201c\u5c0f\u4e8e\u7b49\u4e8e\u201d\u3002\u53e6\u5916\u4e00\u70b9\u662f\uff0c\u4e0a\u8ff0\u5b9a\u4e49\u4e2d\u201call\u201d\u5f3a\u8c03\u4e86\u96c6\u5408\u4e2d\u7684\u6240\u6709\u5143\u7d20\u90fd\u9700\u8981\u6ee1\u8db3\u8fd9\u79cd\u5173\u7cfb\u3002","title":"Formal definition"},{"location":"Guide/Relation/Order-theory/Total-order/#chain","text":"\u5bf9\u201ctotal order\u201d\u7684\u76f4\u89c2\u7406\u89e3\u662f\u5b83\u662f\u4e00\u4e2a\u80fd\u591f\u5c06\u8fd9\u4e2a\u96c6\u5408\u201c\u4e32\u201d\u8d77\u6765\u7684\u5173\u7cfb\uff0c\u8fd9\u6837\u8fd9\u4e2a\u96c6\u5408\u5c31\u5f62\u6210\u4e86\u201cchain\u201d\uff0c\u663e\u7136\uff0c\u201cchain\u201d\u662f\u4ece\u89c6\u89c9\u76f4\u89c2\u89d2\u5ea6\u6765\u5bf9\u5176\u8fdb\u884c\u547d\u540d\u7684\uff0c\u5bf9\u6b64\u5728\u539f\u6587\u4e2d\u6709\u8fd9\u6837\u7684\u63cf\u8ff0\uff1a A set paired with a total order is called a chain , a totally ordered set , a simply ordered set , or a linearly ordered set . \u539f\u6587\u7684 Chains \u7ae0\u8282\u5bf9\u6b64\u8fdb\u884c\u4e86\u8be6\u7ec6\u5206\u6790\u3002","title":"Chain"},{"location":"Guide/Relation/Order-theory/Total-order/#connex-relation","text":"\u201cconnex relation\u201d\u5373\u201c\u8fde\u901a\u5173\u7cfb\u201d","title":"Connex relation"},{"location":"Guide/Relation/Order-theory/Total-order/#connex-relation_1","text":"","title":"\u7ef4\u57fa\u767e\u79d1Connex relation"},{"location":"Guide/Relation/Order-theory/Well-order/","text":"Well-order # \u5728\u9605\u8bfb\u7ef4\u57fa\u767e\u79d1 Recursive definition \u7684 Form of recursive definitions \u7ae0\u8282\u65f6\uff0c\u53d1\u73b0\u4e86\u8fd9\u4e2a\u6982\u5ff5\uff0c\u9042\u5bf9\u5b83\u8fdb\u884c\u4e86\u6574\u7406\u3002 \u7ef4\u57fa\u767e\u79d1 Well-order # \u7b14\u8bb0 # Well-order VS total order # \u539f\u6587\u5bf9 Well-order \u7684\u5b9a\u4e49\u5982\u4e0b\uff1a In mathematics , a well-order (or well-ordering or well-order relation ) on a set S is a total order on S with the property that every non-empty subset of S has a least element in this ordering. \u663e\u7136\uff0c\u5b83\u662f\u5728 total order \u7684\u57fa\u7840\u4e0a\u6dfb\u52a0\u4e86\u4e00\u4e2a\u9650\u5236\uff0c\u90a3\u8fd9\u9650\u5236\u6709\u4f55\u610f\u4e49\u5462\uff1f\u662f\u4fdd\u8bc1 S \u7684\u6bcf\u4e2a\u5b50\u96c6\u4f9d\u7136\u6ee1\u8db3 total order \uff1f \u5176\u5b9e\u7406\u89e3well order\u7684\u4e00\u4e2a\u5f88\u597d\u7684\u65b9\u6cd5\u662f\u7ed3\u5408\u5b9e\u4f8b\u6765\u8fdb\u884c\u7406\u89e3\uff0cset theory\u6240\u63cf\u8ff0\u7684tree\u5c31\u662f\u4e00\u4e2a\u5178\u578b\u7684well order\uff0c\u5728\u7ef4\u57fa\u767e\u79d1 Tree (set theory) \uff1a In set theory , a tree is a partially ordered set ( T , <) such that for each t \u2208 T , the set { s \u2208 T : s < t } is well-ordered by the relation <. Frequently trees are assumed to have only one root (i.e. minimal element ), as the typical questions investigated in this field are easily reduced to questions about single-rooted trees. \u7ef4\u57fa\u767e\u79d1Well-founded relation # \u5e76\u6ca1\u6709\u7406\u89e3\u7ef4\u57fa\u767e\u79d1 Well-founded relation \u3002","title":"Well-order"},{"location":"Guide/Relation/Order-theory/Well-order/#well-order","text":"\u5728\u9605\u8bfb\u7ef4\u57fa\u767e\u79d1 Recursive definition \u7684 Form of recursive definitions \u7ae0\u8282\u65f6\uff0c\u53d1\u73b0\u4e86\u8fd9\u4e2a\u6982\u5ff5\uff0c\u9042\u5bf9\u5b83\u8fdb\u884c\u4e86\u6574\u7406\u3002","title":"Well-order"},{"location":"Guide/Relation/Order-theory/Well-order/#well-order_1","text":"","title":"\u7ef4\u57fa\u767e\u79d1Well-order"},{"location":"Guide/Relation/Order-theory/Well-order/#_1","text":"","title":"\u7b14\u8bb0"},{"location":"Guide/Relation/Order-theory/Well-order/#well-order-vs-total-order","text":"\u539f\u6587\u5bf9 Well-order \u7684\u5b9a\u4e49\u5982\u4e0b\uff1a In mathematics , a well-order (or well-ordering or well-order relation ) on a set S is a total order on S with the property that every non-empty subset of S has a least element in this ordering. \u663e\u7136\uff0c\u5b83\u662f\u5728 total order \u7684\u57fa\u7840\u4e0a\u6dfb\u52a0\u4e86\u4e00\u4e2a\u9650\u5236\uff0c\u90a3\u8fd9\u9650\u5236\u6709\u4f55\u610f\u4e49\u5462\uff1f\u662f\u4fdd\u8bc1 S \u7684\u6bcf\u4e2a\u5b50\u96c6\u4f9d\u7136\u6ee1\u8db3 total order \uff1f \u5176\u5b9e\u7406\u89e3well order\u7684\u4e00\u4e2a\u5f88\u597d\u7684\u65b9\u6cd5\u662f\u7ed3\u5408\u5b9e\u4f8b\u6765\u8fdb\u884c\u7406\u89e3\uff0cset theory\u6240\u63cf\u8ff0\u7684tree\u5c31\u662f\u4e00\u4e2a\u5178\u578b\u7684well order\uff0c\u5728\u7ef4\u57fa\u767e\u79d1 Tree (set theory) \uff1a In set theory , a tree is a partially ordered set ( T , <) such that for each t \u2208 T , the set { s \u2208 T : s < t } is well-ordered by the relation <. Frequently trees are assumed to have only one root (i.e. minimal element ), as the typical questions investigated in this field are easily reduced to questions about single-rooted trees.","title":"Well-order VS  total order"},{"location":"Guide/Relation/Order-theory/Well-order/#well-founded-relation","text":"\u5e76\u6ca1\u6709\u7406\u89e3\u7ef4\u57fa\u767e\u79d1 Well-founded relation \u3002","title":"\u7ef4\u57fa\u767e\u79d1Well-founded relation"},{"location":"Structure/Discrete-structure/","text":"Discrete structure # \u6709\u4e86 discrete \u6982\u5ff5\u548c structure \u6982\u5ff5\uff0c\u90a3\u4e48\u7406\u89e3what is discrete structure\u5c31\u6bd4\u8f83\u5bb9\u6613\u4e86\u3002\u4e0b\u9762\u662f\u4e00\u4e9b\u5173\u4e8ediscrete structure\u7684\u5185\u5bb9\uff1a Explain what is the role of Discrete Structures in Computer Science # Discrete structures is study of mathematical structures that are fundamentally discrete (that is not continuous). This is usually the first mathematics course for computer science students; it helps them to start thinking about problems in a way computers can solve. ACM Discrete structures # Discrete Mathematics and Its Applications # \u5728\u8fd9\u672c\u4e66\u7684 Preface \u3001 chapter 2 \u3001 chapter 9 \u4e2d\u6709\u5bf9discrete structure\u7684\u63cf\u8ff0\u3002","title":"Discrete-structure"},{"location":"Structure/Discrete-structure/#discrete-structure","text":"\u6709\u4e86 discrete \u6982\u5ff5\u548c structure \u6982\u5ff5\uff0c\u90a3\u4e48\u7406\u89e3what is discrete structure\u5c31\u6bd4\u8f83\u5bb9\u6613\u4e86\u3002\u4e0b\u9762\u662f\u4e00\u4e9b\u5173\u4e8ediscrete structure\u7684\u5185\u5bb9\uff1a","title":"Discrete structure"},{"location":"Structure/Discrete-structure/#explain-what-is-the-role-of-discrete-structures-in-computer-science","text":"Discrete structures is study of mathematical structures that are fundamentally discrete (that is not continuous). This is usually the first mathematics course for computer science students; it helps them to start thinking about problems in a way computers can solve.","title":"Explain what is the role of Discrete Structures in Computer Science"},{"location":"Structure/Discrete-structure/#acm-discrete-structures","text":"","title":"ACM Discrete structures"},{"location":"Structure/Discrete-structure/#discrete-mathematics-and-its-applications","text":"\u5728\u8fd9\u672c\u4e66\u7684 Preface \u3001 chapter 2 \u3001 chapter 9 \u4e2d\u6709\u5bf9discrete structure\u7684\u63cf\u8ff0\u3002","title":"Discrete Mathematics and Its Applications"},{"location":"Structure/Structure/","text":"Structure # \u201cstructure\u201d\u5373\u201c\u7ed3\u6784\u201d\uff0c\u5728\u9605\u8bfb\u7ef4\u57fa\u767e\u79d1computer science\u3001\u6570\u5b66\u76f8\u5173\u7684\u6587\u7ae0\u4e2d\uff0c\u7ecf\u5e38\u78b0\u5230\u201cstructure\u201d\u6982\u5ff5\uff0c\u8fd9\u5f15\u8d77\u4e86\u6211\u601d\u8003\uff1awhat is structure\uff1f\u672c\u6587\u5c31\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u5256\u6790\u3002 Structure\u662f\u4e00\u4e2a\u5b8f\u5927\u7684\u8bdd\u9898\uff0cstructure\u4e0d\u4ec5\u4ec5\u5c40\u9650\u4e8e\u6211\u4eec\u8089\u773c\u53ef\u89c1\u7684\u7269\u7406structure\uff0c\u5b83\u8fd8\u5305\u62ec\u6211\u4eec\u8089\u773c\u65e0\u6cd5\u770b\u5230\u7684\u903b\u8f91\uff08\u62bd\u8c61\uff09structure\u3002 What is structure? # \u4e0b\u9762\u662f\u7ef4\u57fa\u767e\u79d1 Structure \u4e2d\u7ed9\u51fa\u7684\u5b9a\u4e49\uff1a A structure is an arrangement and organization of interrelated\uff08\u76f8\u4e92\u5173\u8054\uff09 elements in a material object or system , or the object or system so organized. Material structures include man-made objects such as buildings and machines and natural objects such as biological organisms , minerals and chemicals . Abstract structures include data structures in computer science and musical form . \u4e0a\u8ff0\u5b9a\u4e49\u4e2d\u7684\u201cmaterial structures\u201d\u662f\u6307\u7269\u7406\u7684\u3001\u8089\u773c\u53ef\u89c1\u7684\u7ed3\u6784\u3002\u4e0a\u8ff0\u5b9a\u4e49\u662fgeneral\u7684\uff0c\u4e0b\u9762\u770b\u770b\u4e0e\u8ba1\u7b97\u673a\u79d1\u5b66\u6700\u6700\u201d\u4eb2\u5bc6\u201c\u7684\u6570\u5b66\u4e2d\u5bf9structure\u7684\u5b9a\u4e49\uff1a Mathematical structure In mathematics , a structure is a set endowed\uff08\u8d4b\u4e88\uff09 with some additional features on the set (e.g., operation , relation , metric , topology ). Often, the additional features are attached or related to the set, so as to provide it with some additional meaning or significance. Structure (mathematical logic) \uff1a In universal algebra and in model theory , a structure consists of a set along with a collection of finitary operations and relations that are defined on it. Algebraic structure In mathematics , more specifically in abstract algebra and universal algebra , an algebraic structure consists of a set A (called the underlying set , carrier set or domain ), a collection of operations on A of finite arity (typically binary operations ), and a finite set of identities , known as axioms , that these operations must satisfy. \u7b80\u8a00\u4e4b\uff0c\u5728\u6570\u5b66\u4e2d\uff0c\u5f53\u8c08\u53castructure\u7684\u65f6\u5019\uff0c\u5b83\u8868\u793a\u7684\u662f\u4e00\u4e2aset\u4ee5\u53ca\u8d4b\u4e88\u7ed9\u5b83\u7684feature\u3002 \u6570\u5b66\u4e2d\u7684\u5b9a\u4e49\u6240\u4f7f\u7528\u7684\u662f \u6570\u5b66\u8bed\u8a00 \uff0cgeneral\u5b9a\u4e49\u4e2d\u7684\u201celements\u201d\u4f7f\u7528 \u6570\u5b66\u8bed\u8a00 \u6765\u63cf\u8ff0\u662f set \uff0cgeneral\u5b9a\u4e49\u4e2d\u7684\u201cinterrelated\u201d\u4f7f\u7528 \u6570\u5b66\u8bed\u8a00 \u6765\u63cf\u8ff0\u662f operations \u6216 relations \u3002 \u9605\u8bfb\u4e86\u4e0a\u8ff0\u5b9a\u4e49\uff0c\u76f4\u89c2\u611f\u53d7\u5c31\u662f\uff1a structure**\u4e0d\u4ec5\u4ec5\u5173\u4e4e\u5143\u7d20\uff0c\u800c\u4e14\u5173\u4e4e\u5b83\u4eec\u4e4b\u95f4\u7684**\u5173\u7cfb \u3002\u603b\u7684\u6765\u8bf4\uff1a**structure**\u6240\u63cf\u8ff0\u7684\u662f\u5143\u7d20\u4ee5\u53ca\u5143\u7d20\u4e4b\u95f4\u7684\u5173\u7cfb\u3002 \u76f8\u540c\u7684\u5143\u7d20\uff0c\u5982\u679c\u4f7f\u7528\u4e0d\u540c\u7684**\u5173\u7cfb**\u6765\u8fdb\u884c\u7ec4\u7ec7\uff0c\u5c31\u662f\u4e0d\u540c\u7684**structure**\uff0c\u5c31\u5448\u73b0\u51fa\u4e0d\u540c\u7684\u89c6\u89c9**\u5f62\u6001**\uff08\u540e\u6587\u4e2d\uff0c\u6211\u4eec\u628a\u8fd9\u79f0\u4e4b\u4e3a\u201c \u5f62\u72b6 \u201d\uff09\uff0c\u6240\u4ee5\uff0c\u5728\u6b64\uff0c\u6211\u4eec\u8bf4\uff1a \u5173\u7cfb\u51b3\u5b9a\uff08\u6216\u8005\u8bf4\uff1a\u5b9a\u4e49\uff09\u4e86structure\uff0c\u8fdb\u800c\u51b3\u5b9a\u4e86\u5f62\u72b6 \uff0c\u6240\u4ee5\uff0c\u6211\u4eec\u5728\u7814\u7a76\u7ed3\u6784\u7684\u65f6\u5019\uff0c\u5207\u83ab\u5ffd\u89c6\u4e86\u5bf9\u5173\u7cfb\u5206\u6790\u3002 \u5728\u7ef4\u57fa\u767e\u79d1 Mathematical structure \u4e2d\uff0c\u5217\u4e3e\u4e86\u4e00\u4e9b\u6570\u5b66\u4e2d\u7684structure\uff1a A partial list of possible structures are measures , algebraic structures ( groups , fields , etc.), topologies , metric structures ( geometries ), orders , events , equivalence relations , differential structures , and categories . \u901a\u8fc7\u4e0a\u9762\u7684\u63cf\u8ff0\uff0c\u73b0\u5728\u8ba9\u6211\u4eec\u6765\u56de\u7b54\u672c\u8282\u6807\u9898\u4e2d\u7684\u95ee\u9898\uff1astructure\u662f\u6211\u4eec\u6309\u7167\u67d0\u79cd\u5173\u7cfb\u5bf9\u5143\u7d20\u8fdb\u884c\u7ec4\u7ec7\u540e\u5f62\u6210\u7684\u3002 \u5982\u4f55\u6765\u8868\u793astructure\uff1f # \u601d\u8003 # Structure of recurrence relation # \u663e\u7136recurrence relation\u4e5f\u662f\u4e00\u79cd\u7ed3\u6784\u3002 Fibonacci number \u7684\u9012\u5f52\u516c\u5f0f\u7684\u7ed3\u6784 # \u6211\u89c9\u5f97fibonacci number\u7684\u9012\u5f52\u516c\u5f0f\u7684\u7ed3\u6784\u975e\u5e38\u7c7b\u4f3c\u4e8ebinary tree\u3002","title":"Structure"},{"location":"Structure/Structure/#structure","text":"\u201cstructure\u201d\u5373\u201c\u7ed3\u6784\u201d\uff0c\u5728\u9605\u8bfb\u7ef4\u57fa\u767e\u79d1computer science\u3001\u6570\u5b66\u76f8\u5173\u7684\u6587\u7ae0\u4e2d\uff0c\u7ecf\u5e38\u78b0\u5230\u201cstructure\u201d\u6982\u5ff5\uff0c\u8fd9\u5f15\u8d77\u4e86\u6211\u601d\u8003\uff1awhat is structure\uff1f\u672c\u6587\u5c31\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u5256\u6790\u3002 Structure\u662f\u4e00\u4e2a\u5b8f\u5927\u7684\u8bdd\u9898\uff0cstructure\u4e0d\u4ec5\u4ec5\u5c40\u9650\u4e8e\u6211\u4eec\u8089\u773c\u53ef\u89c1\u7684\u7269\u7406structure\uff0c\u5b83\u8fd8\u5305\u62ec\u6211\u4eec\u8089\u773c\u65e0\u6cd5\u770b\u5230\u7684\u903b\u8f91\uff08\u62bd\u8c61\uff09structure\u3002","title":"Structure"},{"location":"Structure/Structure/#what-is-structure","text":"\u4e0b\u9762\u662f\u7ef4\u57fa\u767e\u79d1 Structure \u4e2d\u7ed9\u51fa\u7684\u5b9a\u4e49\uff1a A structure is an arrangement and organization of interrelated\uff08\u76f8\u4e92\u5173\u8054\uff09 elements in a material object or system , or the object or system so organized. Material structures include man-made objects such as buildings and machines and natural objects such as biological organisms , minerals and chemicals . Abstract structures include data structures in computer science and musical form . \u4e0a\u8ff0\u5b9a\u4e49\u4e2d\u7684\u201cmaterial structures\u201d\u662f\u6307\u7269\u7406\u7684\u3001\u8089\u773c\u53ef\u89c1\u7684\u7ed3\u6784\u3002\u4e0a\u8ff0\u5b9a\u4e49\u662fgeneral\u7684\uff0c\u4e0b\u9762\u770b\u770b\u4e0e\u8ba1\u7b97\u673a\u79d1\u5b66\u6700\u6700\u201d\u4eb2\u5bc6\u201c\u7684\u6570\u5b66\u4e2d\u5bf9structure\u7684\u5b9a\u4e49\uff1a Mathematical structure In mathematics , a structure is a set endowed\uff08\u8d4b\u4e88\uff09 with some additional features on the set (e.g., operation , relation , metric , topology ). Often, the additional features are attached or related to the set, so as to provide it with some additional meaning or significance. Structure (mathematical logic) \uff1a In universal algebra and in model theory , a structure consists of a set along with a collection of finitary operations and relations that are defined on it. Algebraic structure In mathematics , more specifically in abstract algebra and universal algebra , an algebraic structure consists of a set A (called the underlying set , carrier set or domain ), a collection of operations on A of finite arity (typically binary operations ), and a finite set of identities , known as axioms , that these operations must satisfy. \u7b80\u8a00\u4e4b\uff0c\u5728\u6570\u5b66\u4e2d\uff0c\u5f53\u8c08\u53castructure\u7684\u65f6\u5019\uff0c\u5b83\u8868\u793a\u7684\u662f\u4e00\u4e2aset\u4ee5\u53ca\u8d4b\u4e88\u7ed9\u5b83\u7684feature\u3002 \u6570\u5b66\u4e2d\u7684\u5b9a\u4e49\u6240\u4f7f\u7528\u7684\u662f \u6570\u5b66\u8bed\u8a00 \uff0cgeneral\u5b9a\u4e49\u4e2d\u7684\u201celements\u201d\u4f7f\u7528 \u6570\u5b66\u8bed\u8a00 \u6765\u63cf\u8ff0\u662f set \uff0cgeneral\u5b9a\u4e49\u4e2d\u7684\u201cinterrelated\u201d\u4f7f\u7528 \u6570\u5b66\u8bed\u8a00 \u6765\u63cf\u8ff0\u662f operations \u6216 relations \u3002 \u9605\u8bfb\u4e86\u4e0a\u8ff0\u5b9a\u4e49\uff0c\u76f4\u89c2\u611f\u53d7\u5c31\u662f\uff1a structure**\u4e0d\u4ec5\u4ec5\u5173\u4e4e\u5143\u7d20\uff0c\u800c\u4e14\u5173\u4e4e\u5b83\u4eec\u4e4b\u95f4\u7684**\u5173\u7cfb \u3002\u603b\u7684\u6765\u8bf4\uff1a**structure**\u6240\u63cf\u8ff0\u7684\u662f\u5143\u7d20\u4ee5\u53ca\u5143\u7d20\u4e4b\u95f4\u7684\u5173\u7cfb\u3002 \u76f8\u540c\u7684\u5143\u7d20\uff0c\u5982\u679c\u4f7f\u7528\u4e0d\u540c\u7684**\u5173\u7cfb**\u6765\u8fdb\u884c\u7ec4\u7ec7\uff0c\u5c31\u662f\u4e0d\u540c\u7684**structure**\uff0c\u5c31\u5448\u73b0\u51fa\u4e0d\u540c\u7684\u89c6\u89c9**\u5f62\u6001**\uff08\u540e\u6587\u4e2d\uff0c\u6211\u4eec\u628a\u8fd9\u79f0\u4e4b\u4e3a\u201c \u5f62\u72b6 \u201d\uff09\uff0c\u6240\u4ee5\uff0c\u5728\u6b64\uff0c\u6211\u4eec\u8bf4\uff1a \u5173\u7cfb\u51b3\u5b9a\uff08\u6216\u8005\u8bf4\uff1a\u5b9a\u4e49\uff09\u4e86structure\uff0c\u8fdb\u800c\u51b3\u5b9a\u4e86\u5f62\u72b6 \uff0c\u6240\u4ee5\uff0c\u6211\u4eec\u5728\u7814\u7a76\u7ed3\u6784\u7684\u65f6\u5019\uff0c\u5207\u83ab\u5ffd\u89c6\u4e86\u5bf9\u5173\u7cfb\u5206\u6790\u3002 \u5728\u7ef4\u57fa\u767e\u79d1 Mathematical structure \u4e2d\uff0c\u5217\u4e3e\u4e86\u4e00\u4e9b\u6570\u5b66\u4e2d\u7684structure\uff1a A partial list of possible structures are measures , algebraic structures ( groups , fields , etc.), topologies , metric structures ( geometries ), orders , events , equivalence relations , differential structures , and categories . \u901a\u8fc7\u4e0a\u9762\u7684\u63cf\u8ff0\uff0c\u73b0\u5728\u8ba9\u6211\u4eec\u6765\u56de\u7b54\u672c\u8282\u6807\u9898\u4e2d\u7684\u95ee\u9898\uff1astructure\u662f\u6211\u4eec\u6309\u7167\u67d0\u79cd\u5173\u7cfb\u5bf9\u5143\u7d20\u8fdb\u884c\u7ec4\u7ec7\u540e\u5f62\u6210\u7684\u3002","title":"What is structure?"},{"location":"Structure/Structure/#structure_1","text":"","title":"\u5982\u4f55\u6765\u8868\u793astructure\uff1f"},{"location":"Structure/Structure/#_1","text":"","title":"\u601d\u8003"},{"location":"Structure/Structure/#structure-of-recurrence-relation","text":"\u663e\u7136recurrence relation\u4e5f\u662f\u4e00\u79cd\u7ed3\u6784\u3002","title":"Structure of  recurrence relation"},{"location":"Structure/Structure/#fibonacci-number","text":"\u6211\u89c9\u5f97fibonacci number\u7684\u9012\u5f52\u516c\u5f0f\u7684\u7ed3\u6784\u975e\u5e38\u7c7b\u4f3c\u4e8ebinary tree\u3002","title":"Fibonacci number\u7684\u9012\u5f52\u516c\u5f0f\u7684\u7ed3\u6784"},{"location":"What-is-discrete-math/","text":"\u5173\u4e8e\u672c\u7ae0 # \u672c\u7ae0\u56de\u7b54\u201cwhat is discrete math\u201d\uff0c\u5e76\u4e14\u5206\u6790discrete math and computer science\u3002","title":"Introduction"},{"location":"What-is-discrete-math/#_1","text":"\u672c\u7ae0\u56de\u7b54\u201cwhat is discrete math\u201d\uff0c\u5e76\u4e14\u5206\u6790discrete math and computer science\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"What-is-discrete-math/Discrete-math/","text":"What is discrete math? # \u672c\u6587\u56de\u7b54\u201cwhat is discrete math\u201d\uff0c\u4ee5\u53ca\u770b\u770btopics in discrete mathematics\u3002 \u7ef4\u57fa\u767e\u79d1 Discrete mathematics # Discrete mathematics is the study of mathematical structures that are fundamentally discrete rather than continuous . In contrast to real numbers that have the property of varying \"smoothly\", the objects studied in discrete mathematics \u2013 such as integers , graphs , and statements in logic \u2013 do not vary smoothly in this way, but have distinct, separated values. Discrete mathematics therefore excludes topics in \"continuous mathematics\" such as calculus or Euclidean geometry . Discrete objects can often be enumerated by integers. More formally, discrete mathematics has been characterized as the branch of mathematics dealing with countable sets (finite sets or sets with the same cardinality as the natural numbers). NOTE: \u7ef4\u57fa\u767e\u79d1\u7684\u8fd9\u4e00\u6bb5\u603b\u7ed3\u7684\u975e\u5e38\u597d\u3002 Topics in discrete mathematics # Property of discrete # \u672c\u8282\u603b\u7ed3\u7531discrete\u884d\u751f\u51fa\u6765\u7684\u4e00\u7cfb\u5217\u7279\u6027\uff0c\u663e\u7136discrete objects\u9664\u4e86\u5177\u5907discrete\u7279\u6027\uff0c\u8fd8\u5177\u5907\u5982\u4e0b\u7279\u6027\u3002 Enumerable # \u201cenumerable\u201d\u5373\u201c\u53ef\u679a\u4e3e\u7684\u201d\uff0c\u8fd9\u4e2a\u7279\u6027\u975e\u5e38\u91cd\u8981\u3002 \u7ef4\u57fa\u767e\u79d1 Discrete mathematics \uff1a Discrete objects can often be enumerated by integers. Countable # \u5173\u4e8e\u201ccountable\u201d\uff0c\u53ef\u4ee5\u53c2\u89c1\u7ef4\u57fa\u767e\u79d1 Countable set \u3002 discrete objects\u4e00\u822c\u662fcountable\u7684\uff08\u6709\u7684\u662f\u65e0\u6cd5count\u7684\uff09\u3002 Computable # \u5173\u4e8e\u201ccomputable\u201d\uff0c\u53c2\u89c1\u7ef4\u57fa\u767e\u79d1 Computability theory \u3001\u7ef4\u57fa\u767e\u79d1 Computability \u3002 \u5173\u4e8ediscrete objects\u7684\u95ee\u9898\uff0c\u4e00\u822c\u662fcomputable\u7684\u3002 Discrete VS continuous # \u201cdiscrete\u201d\u5373\u201c\u79bb\u6563\u201d\uff0c\u201ccontinuous\u201d\u5373\u201c\u8fde\u7eed\u201d\uff0c\u4e24\u8005\u53ef\u4ee5\u770b\u505a\u662f\u4e00\u5bf9\u53cd\u4e49\u8bcd\uff0c\u5982\u679c\u662fdiscrete\u7684\u8bdd\uff0c\u5219\u5fc5\u7136\u5c31\u4e0d\u662fcontinuous\u7684\u3002 \u5173\u4e8e\u201cdiscrete\u201d\u7684\u6982\u5ff5\uff0c\u7ef4\u57fa\u767e\u79d1 Discrete space \u7ed9\u51fa\u4e86\u89e3\u91ca\u3002\u6211\u7684\u76f4\u89c2\u7406\u89e3\u5c31\u662f\u4e0d\u76f8\u8fde\u7684\u3001\u662f\u4e00\u4e2a\u4e00\u4e2anode\u3002 \u5173\u4e8e\u201ccontinuous\u201d\u7684\u6982\u5ff5\uff0c\u7ef4\u57fa\u767e\u79d1 Continuous function \u7ed9\u51fa\u4e86\u89e3\u91ca\uff0c\u6211\u7684\u76f4\u89c2\u7406\u89e3\u662f\u76f8\u8fde\u7684\u3001\u662f\uff08\u5e73\u6ed1\u7684\uff09\u66f2\u7ebf\u3002 \u5173\u4e8e\u8fd9\u4e2a\u95ee\u9898\uff0c\u7ef4\u57fa\u767e\u79d1 Discrete mathematics \u7684\u7b2c\u4e00\u6bb5\u7684\u8bba\u8ff0\u4e5f\u662f\u6bd4\u8f83\u597d\u7684\u3002 \u6839\u636e\u8fd9\u4e24\u4e2a\u6027\u8d28\uff0c\u53ef\u4ee5\u5c06\u6570\u5b66\u5b66\u79d1\u8fdb\u884c\u5206\u7c7b\u3002","title":"Discrete-math"},{"location":"What-is-discrete-math/Discrete-math/#what-is-discrete-math","text":"\u672c\u6587\u56de\u7b54\u201cwhat is discrete math\u201d\uff0c\u4ee5\u53ca\u770b\u770btopics in discrete mathematics\u3002","title":"What is discrete math?"},{"location":"What-is-discrete-math/Discrete-math/#discrete-mathematics","text":"Discrete mathematics is the study of mathematical structures that are fundamentally discrete rather than continuous . In contrast to real numbers that have the property of varying \"smoothly\", the objects studied in discrete mathematics \u2013 such as integers , graphs , and statements in logic \u2013 do not vary smoothly in this way, but have distinct, separated values. Discrete mathematics therefore excludes topics in \"continuous mathematics\" such as calculus or Euclidean geometry . Discrete objects can often be enumerated by integers. More formally, discrete mathematics has been characterized as the branch of mathematics dealing with countable sets (finite sets or sets with the same cardinality as the natural numbers). NOTE: \u7ef4\u57fa\u767e\u79d1\u7684\u8fd9\u4e00\u6bb5\u603b\u7ed3\u7684\u975e\u5e38\u597d\u3002","title":"\u7ef4\u57fa\u767e\u79d1Discrete mathematics"},{"location":"What-is-discrete-math/Discrete-math/#topics-in-discrete-mathematics","text":"","title":"Topics in discrete mathematics"},{"location":"What-is-discrete-math/Discrete-math/#property-of-discrete","text":"\u672c\u8282\u603b\u7ed3\u7531discrete\u884d\u751f\u51fa\u6765\u7684\u4e00\u7cfb\u5217\u7279\u6027\uff0c\u663e\u7136discrete objects\u9664\u4e86\u5177\u5907discrete\u7279\u6027\uff0c\u8fd8\u5177\u5907\u5982\u4e0b\u7279\u6027\u3002","title":"Property of discrete"},{"location":"What-is-discrete-math/Discrete-math/#enumerable","text":"\u201cenumerable\u201d\u5373\u201c\u53ef\u679a\u4e3e\u7684\u201d\uff0c\u8fd9\u4e2a\u7279\u6027\u975e\u5e38\u91cd\u8981\u3002 \u7ef4\u57fa\u767e\u79d1 Discrete mathematics \uff1a Discrete objects can often be enumerated by integers.","title":"Enumerable"},{"location":"What-is-discrete-math/Discrete-math/#countable","text":"\u5173\u4e8e\u201ccountable\u201d\uff0c\u53ef\u4ee5\u53c2\u89c1\u7ef4\u57fa\u767e\u79d1 Countable set \u3002 discrete objects\u4e00\u822c\u662fcountable\u7684\uff08\u6709\u7684\u662f\u65e0\u6cd5count\u7684\uff09\u3002","title":"Countable"},{"location":"What-is-discrete-math/Discrete-math/#computable","text":"\u5173\u4e8e\u201ccomputable\u201d\uff0c\u53c2\u89c1\u7ef4\u57fa\u767e\u79d1 Computability theory \u3001\u7ef4\u57fa\u767e\u79d1 Computability \u3002 \u5173\u4e8ediscrete objects\u7684\u95ee\u9898\uff0c\u4e00\u822c\u662fcomputable\u7684\u3002","title":"Computable"},{"location":"What-is-discrete-math/Discrete-math/#discrete-vs-continuous","text":"\u201cdiscrete\u201d\u5373\u201c\u79bb\u6563\u201d\uff0c\u201ccontinuous\u201d\u5373\u201c\u8fde\u7eed\u201d\uff0c\u4e24\u8005\u53ef\u4ee5\u770b\u505a\u662f\u4e00\u5bf9\u53cd\u4e49\u8bcd\uff0c\u5982\u679c\u662fdiscrete\u7684\u8bdd\uff0c\u5219\u5fc5\u7136\u5c31\u4e0d\u662fcontinuous\u7684\u3002 \u5173\u4e8e\u201cdiscrete\u201d\u7684\u6982\u5ff5\uff0c\u7ef4\u57fa\u767e\u79d1 Discrete space \u7ed9\u51fa\u4e86\u89e3\u91ca\u3002\u6211\u7684\u76f4\u89c2\u7406\u89e3\u5c31\u662f\u4e0d\u76f8\u8fde\u7684\u3001\u662f\u4e00\u4e2a\u4e00\u4e2anode\u3002 \u5173\u4e8e\u201ccontinuous\u201d\u7684\u6982\u5ff5\uff0c\u7ef4\u57fa\u767e\u79d1 Continuous function \u7ed9\u51fa\u4e86\u89e3\u91ca\uff0c\u6211\u7684\u76f4\u89c2\u7406\u89e3\u662f\u76f8\u8fde\u7684\u3001\u662f\uff08\u5e73\u6ed1\u7684\uff09\u66f2\u7ebf\u3002 \u5173\u4e8e\u8fd9\u4e2a\u95ee\u9898\uff0c\u7ef4\u57fa\u767e\u79d1 Discrete mathematics \u7684\u7b2c\u4e00\u6bb5\u7684\u8bba\u8ff0\u4e5f\u662f\u6bd4\u8f83\u597d\u7684\u3002 \u6839\u636e\u8fd9\u4e24\u4e2a\u6027\u8d28\uff0c\u53ef\u4ee5\u5c06\u6570\u5b66\u5b66\u79d1\u8fdb\u884c\u5206\u7c7b\u3002","title":"Discrete VS continuous"}]}